{"aid": "40094798", "title": "Journey to Poom (Doom on PICO-8)", "url": "https://freds72.itch.io/poom/devlog/241700/journey-to-poom", "domain": "freds72.itch.io", "votes": 1, "user": "sea6ear", "posted_at": "2024-04-20 04:24:50", "comments": 0, "source_title": "Journey to Poom - POOM by freds72, Paranoid Cactus", "source_text": "Journey to Poom - POOM by freds72, Paranoid Cactus\n\n  * View all by freds72freds72\n  * Follow freds72FollowFollowing freds72Following\n  * Add To CollectionCollection\n  * Comments\n  * Devlog\n  * Submission to 7dfps 2020\n  * Related gamesRelated\n\n# POOM\n\n# Journey to Poom\n\nPOOM \u00bb Devlog\n\nLike55\n\n2 years ago by freds72 (@FSouchu)\n\nShare this post:\n\nShare on TwitterShare on Facebook\n\n## Doomed Assault\n\nAs in many gamedev stories, Poom should not have existed.\n\nIt came to be possible on Pico8 thanks to a (still unpublished) project, an\nAssault demake - a game I used to play at arcades as a kid (dual stick!\nexcellent music! ultra low bass explosions!).\n\nEarly 2020, quite proud of my silky smooth rotozoom engine running entirely in\nmemory, well below 50% cpu with enemy units.\n\n@Eniko & @Electricgryphon had already paved the way, I went slightly further:\n\n> load #assault (requires a 0.1.12c version to run at full speed)\n\nEngine is looking good, time to export to HTML and demo it. I run a couple of\ntests on my home computers and mobiles...\n\nIt did not went well, performance was all over the place and required a\npowerful PC to run at full speed.\n\nReporting the bug (?) to Zep (Joseph White, Pico8 author), it became apparent\nthe game relied too much on binary operations and trashed the web player. The\ndelicate balance of simulated API costs did not account for so many \"low\nlevel\" operations per frame.\n\nToo much binary ops? Nah...\n\n    \n    \n    poke4( mem, bor( bor( bor(rotr(band(shl(m[bor(band(mx,0xffff), band(lshr(srcy,16),0x0.ffff))],shl(band(srcx,7),2)),0xf000),28), rotr(band(shl(m[bor(band(mx+mdx1,0xffff), band(lshr(srcy-ddy1,16),0x0.ffff))],shl(band(srcx+ddx1,7),2)),0xf000),24)), bor(rotr(band(shl(m[bor(band(mx+mdx2,0xffff), band(lshr(srcy-ddy2,16),0x0.ffff))],shl(band(srcx+ddx2,7),2)),0xf000),20), rotr(band(shl(m[bor(band(mx+mdx3,0xffff), band(lshr(srcy-ddy3,16),0x0.ffff))],shl(band(srcx+ddx3,7),2)),0xf000),16)) ), bor( bor(rotr(band(shl(m[bor(band(mx+mdx4,0xffff), band(lshr(srcy-ddy4,16),0x0.ffff))],shl(band(srcx+ddx4,7),2)),0xf000),12), rotr(band(shl(m[bor(band(mx+mdx5,0xffff), band(lshr(srcy-ddy5,16),0x0.ffff))],shl(band(srcx+ddx5,7),2)),0xf000),8)), bor(rotr(band(shl(m[bor(band(mx+mdx6,0xffff), band(lshr(srcy-ddy6,16),0x0.ffff))],shl(band(srcx+ddx6,7),2)),0xf000),4), band(shl(m[bor(band(mx+mdx7,0xffff), band(lshr(srcy-ddy7,16),0x0.ffff))],shl(band(srcx+ddx7,7),2)),0xf000)) ) )\n\nLong story short, Pico8 0.2 is out shortly after - binary operators and tline\n(\"textured line\") are a thing...\n\nThe new addition to the Pico8 API manual reads:\n\n    \n    \n    tline x0 y0 x1 y1 mx my [mdx mdy] [layers] Draw a textured line from (x0,y0) to (x1,y1), sampling colour values from the map.\n\nAssault port to tline proved the huge potential of the function:\n\n> 45% cpu - 1024x1024 pix map - rotating enemies - nuklear blast!\n\nHalf joking I told Zep about the flood of Doom clones we will have in no\ntime...\n\nWhat if, say, I dig myself a bit more into binary space partitioning (BSP\ntrees) & portals?\n\nA sign that current project is going to have some competition...\n\n## Doom Engine? Nah!\n\nGood thing approaching a (very successful) game 30 years late is that\ndocumentation & tooling is top notch!\n\nDriven by portability & extensibility, level geometry is now expressed using\nan open text format (UDMF), saving the need for tedious binary unpacking of\nWAD structure (to some extent...) and perfect for quick hacking.\n\nMay 9-10th: armed with Real-Time Collision Detection from Christer Ericson,\nANTLR for UDMF parsing and a good pinch of Python I got my first BSP compiler\nup and a running Pico8 renderer:\n\n> each polygon has its own color - notice split on pillar\n> https://twitter.com/FSouchu/status/1259520453128990721?s=2\n\nSorry Assault, see you on the other side!\n\nNext 2 weeks are spent digging into WAD structure (I think I know what a\nlinedef is by now...) and going over Zdoom wiki a million times.\n\nMy custom compiler was quickly dropped in favor of the \"official\" zbsp\ncompiler (nothing beats years of bug fixing!), Python code fully decodes\nbinary WAD files, complex geometry is supported, including textured walls &\nfloors:\n\n> https://twitter.com/FSouchu/status/1266474492890624011?s=20\n\nSlow motion rendering (without textures), each color represents a convex sub-\nsector:\n\n## Quake To The Rescue\n\nSince textures are in, the engine departed from \"canon\" front-to-back Doom\nrendering to back to front.\n\n> I really never thought front to back woudl work anyway - programming for\n> Pico8 is more akin to targeting a very low end GPU.\n\nAs per Doom standard, perspective correct texturing & shading work for cheap\nas long as the world is made of flat walls & floors.\n\nFast depth shading (the farther you look, the darker it is) is done using\nstandard palette swapping. Depth information indexes a gradient table, stored\nin Pico8 ram. It makes full palette swap faster than regular method pal()\ncall, saving precious cycles in the core wall & floor rasterization loop:\n\n    \n    \n    -- pal1: normalized integer depth if(pal0!=pal1) memcpy(0x5f00,0x4300|pal1<<4,16) pal0=pal1\n\nBack to front rendering means loosing natural \"narrowing\" of level scanning of\nstandard Doom (see Black Book for an extensive explanation!) and the limited\nperformance impact of large levels that comes with it.\n\nThat's where having read Mike Abrash Black Book years ago helped.\n\nI knew Quake had the same issue and solved it using a Potentially Visible Set\n(PVS). A PVS, generated at compile time, is the set of all potentially visible\nconvex sub-sectors from any given given sub-sector (read it twice, slowly!).\n\nOf course, zbsp doesn't generate such information...\n\nSome more Python code & maths (and cursing!), it works!!!\n\n> bold numbers are all sub-sectors visibles from sub-sector 38\n\nSurprisingly, there is little literature on how to generate a proper PVS, most\nnotable sources I found:\n\nSource Engine PVS - A Closer Look\n\nPotentially Visible Sets explained\n\nPVS is encoded as a bitfield, stored as 32bits chunks to keep memory usage\nunder control (a much simpler version than RLE encoding of Quake PVS):\n\n    \n    \n    -- pvs (packed as a bit array) unpack_array(function() -- visible sub-sector id (16 bits) local id=unpack_variant() -- pack as a bitfield pvs[id\\32]=bor(pvs[id\\32],0x0.0001<<(id&31)) end)\n\n## Virtual Sprites\n\nWorking some more on getting rotating sprites into game engine, it is obvious\nsprite real-estate is going to be a major pain point. For reference, a single\nsoldier pose is eating almost half of the space available. And that's for a\n\"small\" sprite...\n\nI knew the game would be multi-cart, that is, storage may not be my main\nconcern and Pico8 has a large 2MB of LUA ram to play with.\n\nWhat if sprites could fit in memory, how to then best use built-in Pico8\nsprite scaling capabilities (read, sspr)?\n\nWhat if I had some kind of fast memory allocator? Last recenly used cache is a\ngood design pattern for this case, simple enough if chunks are of fixed size.\n\nWhat if I split sprites into little (but not too small) chunks, say 16x16 and\nget their actual sprite location from that \"virtual memory\" allocator?\n\nJuly 15th, this is indeed a very workable approach - memcpy is fast enough to\nswap required sprite tiles on the fly. Sprites can be up to 16 tiles, e.g. up\n64 by 64 pixels, allowing large monsters like Cyberdemon at 1/2 of their\noriginal size.\n\n> Say hi to Cyb'!\n\nVirtual Sprite Engine (tm!) integrated in game - monsters can be much more\nthan a blurry pixelated mess!\n\nActors are registered in each sub-sector they are touching, based on their\nradius. Multiple actors on a given sub-sector are sorted using a basic\ninsertion sort, assuming the number of \"co-located\" actors is usually low:\n\n    \n    \n    -- all things in sub-sector for thing,_ in pairs(segs.things) do local x,y=thing[1],thing[2] local ax,az=m1*x+m3*y+m4,m9*x+m11*y+m12 -- todo: take radius into account if az>8 and az<854 and ax<az and -ax<az then -- default: insert at end of sorted array local w,thingi=128/az,#things+1 -- basic insertion sort for i,otherthing in ipairs(things) do if(otherthing[1]>w) thingi=i break end -- perspective scaling add(things,{w,thing,63.5+ax*w,63.5-(thing[3]+m8)*w},thingi) end end\n\nOnce sorted, sprites are rendered right after sector's polygons.\n\nNote that registering actor into multiple sub-sector also solves the issue of\noverlapping sprite/polygons.\n\nSee how back to front rendering of convex sectors are erasing part of\nCacodaemon in below gif. Sprite is rendered multiple times, and the last\nrender (in the nearest sub-sector) fixes the image:\n\nRegistering actors per sub-sector (e.g. BSP leaves) is also used to speed up\nplayer/actor & actor/actor collision detection.\n\nSummer time, at this point, my goal is clear: make the engine as easy as\npossible to work with an artist, I'll need a team to realize the vision.\n\nOn to gameplay!\n\n## Decorate Love Letter\n\nThe DECORATE format is brilliant!\n\nEach \"thing\" runs it's own little state machine, can reference sprites and\ncall game functions:\n\n    \n    \n    actor ZombieMan : Monster 3004 { Health 20 Radius 20 Height 56 Speed 8 States { Spawn: POSS A 10 A_Look; Loop See: POSS A 8 POSS B 8 A_Chase; Loop Missile: POSS E 10 A_FaceTarget; POSS F 8 A_FireBullets(22.5, 0, 1, 9, \"BulletPuff\"); POSS E 8 Goto See Death: POSS H 5 POSS I 5 // A_Scream POSS J 5 // A_NoBlocking POSS K 5 POSS L 60 Stop } }\n\nThe Python compiler supports a limited set of features, but enough to support\nkey Doom gameplay elements (states, animations, function calls with\nparameters).\n\nThe runtime part is simple enough to fit in less than 20 lines of code:\n\n    \n    \n    -- vm update tick=function(self) while ticks!=-1 do -- wait (+reset random startup delay) if(ticks>0) ticks+=delay-1 delay=0 return true -- done, next step if(ticks==0) i+=1 ::loop:: local state=states[i] -- stop (or end of vm instructions) if(not state or state.jmp==-1) del_thing(self) return -- loop or goto if(state.jmp) self:jump_to(state.jmp) goto loop -- effective state self.state=state -- get ticks ticks=state[1] -- trigger function (if any) -- provide owner and self (eg. for weapons) if(state.fn) state.fn(self.owner or self,self) end end\n\nBest of all, everything in game is described using the same syntax: weapons,\nbullets, items & monsters!\n\nBy August, I have a Python package that can be easily installed. Compiler\nsupports many of key Doom features (doors, platforms, monsters, infigthing,\nmultiple weapons, pick ups, difficulty levels...).\n\nMain \"compilation\" pipeline steps:\n\n  * Read WAD entries\n  * Extract normal & pain palettes\n  * Read actors (from DECORATE file)\n\n    * Split actor sprites into unique tiles\n    * Read properties\n    * Decode state machine & function bindings\n    * Decode sprite properties\n  * For all maps (from gameinfo file)\n\n    * Convert texture into unique set of tiles (max. 128)\n    * Read skybox image (if any)\n    * Read level data\n\n      * sectors, sides, vertices, linedefs, pvs, sub-sector & BSP nodes\n      * specials (triggers)\n      * active textures\n      * things (e.g. monsters, weapons...)\n  * Actors & map data is packed into multiple carts\n\n## The Right Match\n\nEnd August, I am reaching out to Paranoid Cactus (of X-Zero fame and I am\ntotal fan of his work!), let's wait and see...\n\nParanoid Cactus (Simon Hulsinga IRL) replies a couple of days after and seems\nto be interested - good news!\n\nSeptember 9th, Simon delivers a first test level:\n\n> wow (it became my favorite expression throughout the project)\n\nCode is almost complete, we should be shipping by what, end September?\n\n....\n\nIf we knew...\n\n## 8192 Tokens Forever\n\nIt so happens that Simon is a multi-classed gamedev, mastering code, art,\nmusic & gameplay (yeah, life is unfair!).\n\nParanoid Cactus takes the lead on gameplay decisions, we both get into a\nroutine of challenging current features, reworking the engine to support ever\nincreasing details while keeping tokens in check. To name a few:\n\n  * Dedicated title screen\n  * Weapon wheel\n  * Save player state between levels\n  * Flying monster support\n  * Transparent textures\n  * Secret sectors\n  * Skybox\n  * Sound blocked by walls\n  * Non-bullet weapons (e.g. hands)\n\nCode goes into massive refactoring, always close to the danger zone, always\nfinding new ways to squeeze our last idea in!\n\nExample token optimization technique, where item identifier, property name and\nunpacking function are declared as a large text block:\n\n    \n    \n    -- layout: -- property mask -- property class name -- property unpack function local properties_factory=split(\"0x0.0001,health,unpack_variant,0x0.0002,armor,unpack_variant,0x0.0004,amount,unpack_variant,0x0.0008,maxamount,unpack_variant,0x0.0010,icon,unpack_chr,0x0.0020,slot,mpeek,0x0.0040,ammouse,unpack_variant,0x0.0080,speed,unpack_variant,0x0.0100,damage,unpack_variant,0x0.0200,ammotype,unpack_ref,0x0.0800,mass,unpack_variant,0x0.1000,pickupsound,unpack_variant,0x0.2000,attacksound,unpack_variant,0x0.4000,hudcolor,unpack_variant,0x0.8000,deathsound,unpack_variant,0x1,meleerange,unpack_variant,0x2,maxtargetrange,unpack_variant,0x4,ammogive,unpack_variant,0x8,trailtype,unpack_ref,0x10,drag,unpack_fixed\",\",\",1) -- properties: property bitfield of current actor for i=1,#properties_factory,3 do if properties_factory[i]&properties!=0 then -- unpack & assign value to actor actor[properties_factory[i+1]]=_ENV[properties_factory[i+2]](actors) end end\n\n## Bumpy Zone\n\nSo far it looks like everything went smooth and nice... It did not!\n\n### Collisions\n\nCollision went through major refactoring multiple times to make world feels\nsolid - one of the key point of Doom.\n\nI was actually surprised to find that Doom used a different data model to\nhandle collision (well known BLOCKMAP), when BSP would have a perfect match\n(Black Book & Carmack notes confirm it was a missed opportunity).\n\nPoom collision code generates a list of linedefs traversed along a ray, using\nthe BSP to traverse the world in order.\n\nOne day you have a super solid collision routine, the next day you got that\ngif:\n\nRoot cause is that a BSP tree loose sector spatial relationship, e.g. 2 walls\nmight be on 2 different part of the tree, leaving a kind of \"gap\" when\nhandling collision in sequence.\n\nSolution was to treat each wall as a capsule (e.g. a ray with a radius),\nensuring player path cannot fall in between wall segments.\n\n### Black sectors\n\nPVS calculation has also been quite tricky to get right in all cases. When\nfailing, whole sectors would end up disapearing from screen (dubbed \"black\nsectors\" by me and Simon).\n\nLeft side: standing in red sector, zone circled yellow is clearly MIA!\n\nGetting back to Chris Ericson reference, correct PVS calculation algorithm\nended up as:\n\n    \n    \n    from a given sub-sector (convex zone): iterate over all double sided linedef register connected sub-sector (\"other sub-sector\") # find all anti-portals for all double sided linedef from other sub-sector: if other linedef is front or straddling current linedef: register linedef pair as a portal # clip & find visible geometry while portal set is not empty: create clip region (\"anti-penumbra\") for all sides of destination portal: if side is back or straddling: clip segment if anything remains: register a new portal mark sub-sector visible\n\n### Compression\n\nCompression was not supported until late in game developpement, I had already\na LZW encoder for Assault that worked rather well.\n\nThing is, I soon realized that LZW decompression is a memory hog, certainly\nnot compatible with a game already stretching available RAM...\n\nGoogle to the rescue, I was sure the embedded crowd had something for me.\n\nA random post on some Arduino forum lead me to this:\nhttps://www.excamera.com/sphinx/article-compression.html\n\nCompression code in Python, decompression code small enough to fit token\nbudget and best of all, fixed memory cap!\n\nCompression ratio is about 50%, does a good enough job on picture and world\ndata.\n\nThanks James Bowman!\n\n### Out of Memory\n\nThat roadblock was a big one - playing levels back to back would tip the game\nover the 2MB limit.\n\nBelow is the kind of chart I used to find out if I was battling a garbage\ncollection bug or dependency cycles or some other bugs...\n\nThe game went though heavy refactoring at this point:\n\n  * hot reload after death was removed (ensures clean memory slate)\n  * most data structures where converted to arrays, code lisibility suffered but memory usage went back to safe zone\n\n    \n    \n    -- 11KB for i=1,100 do add(buf,{id=1,tex=2,sp=3,hp=4}) end -- 7Kb for i=1,100 do add(buf,{1,2,3,4}) end\n\n### Artwork & Level Design\n\nPoom appeal would have been nothing without the right pixels - and we needed\nmany many pixels...\n\n> Left to right: Original Doom Imp | automatic 50% scaling + palette conversion| hand fixed\n\nBest part of the September to December was spent redrawing the selected cast\nto reach the right level of quality.\n\n## What Went Right\n\n### Choices\n\nPico8 games are all about making choices, even with such a large game, not\nevery idea could make it.\n\nFun & gameplay came mostly first, second \"hey, it fits\"! I trusted Simon when\nit came to game design decisions, still trying to lure him with new engine\nfeatures like transparent textures!\n\n### Beta Test\n\nMid November game is ready for testing.\n\nAs obvious as it seems, once you have spent some months working on a game,\nhaving a pair of fresh eyes is invaluable.\n\nSending out invites to Tom Hall (of Doom design fame and resident Pico8\nDiscord member) and Henri Stadolnik (of Fuz fame), they quickly proposed a\ngood number of quality of life tweaks & great insight into level progression.\n\nThe most notable addition was mouse support (quoting Tom \"I want mouse\nsupport\"), wiring \"mouse lock\" browser handler to Pico8 GPIO to communicate\ncoordinates back to the game.\n\nDemoing that to Zep certainly helped bring mouse lock as a native Pico8\nfeature (with a under the cover patch delivered in the wee hours of the\nnight!) - Thanks!\n\n## Conclusion\n\nBehond the technique, the main take away is that such large game would have\nbeen difficult to pull out without teamwork, kind words & contributions from\nthe extended Pico8 community (hey @farbs, @nucleartide, @sam, @valeradhd...!)\n.\n\nGame was our biggest success so far totalling 10K+ downloads, 100K+ web\nsessions, hundreds of comments...\n\nThank you all for that (and thanks Id Software for such a timeless game)!\n\nReading gave you some new gameplay ideas, want to rework sprites or try to\nimprove engine? Hesitate no more, a full blown SDK is there - the same tools\nwe used to make the game! Poom SDK (support Discord:\nhttps://discord.gg/Bmc4nxjfuE)\n\n## Get POOM\n\nDownload NowName your own price\n\n### POOM\n\nDOOM reinvented for PICO8\n\nAdd Game To Collection\n\nStatus| Released  \n---|---  \nAuthors| freds72, Paranoid Cactus  \nGenre| Shooter  \nTags| 3D, FPS, PICO-8  \n  \n### More posts\n\n  * 1.9 standalone zip\n\n47 days ago\n\n  * Version 1.9\n\nJan 22, 2023\n\n  * Version 1.8\n\nSep 21, 2021\n\n  * Version 1.7\n\nJan 22, 2021\n\n## Comments\n\nLog in with itch.io to leave a comment.\n\nSteven53 days ago\n\nThank you\n\nReply\n\nthatsmaik2 years ago(+1)\n\nThanks for the write up and the sdk.\n\nReply\n\nfreds722 years ago(+1)\n\nhappy to know if you do anything with it!!\n\nReply\n\nBitHack2 years ago(+1)\n\nThanks a lot for the write-up, really interesting!\n\nReply\n\nPicoLate2 years ago(+1)\n\nDelightful read. Thanks for writing it all out.\n\nReply\n\nbdlio2 years ago (1 edit) (+1)\n\nThanks for sharing this log with us!\n\nReply\n\nhelloyellowlime2 years ago(+1)\n\nvery cool in-depth write-up for one of the most badass games on the site :)\n\nReply\n\nantikx2 years ago(+2)\n\nAmazing! Thanks for sharing!\n\nReply\n\nitch.io\u00b7View all by freds72\u00b7Report\n\nPOOM \u203a Blog\n\n", "frontpage": false}
