{"aid": "40046692", "title": "Google Common Lisp Style Guide", "url": "https://google.github.io/styleguide/lispguide.xml", "domain": "google.github.io", "votes": 5, "user": "susam", "posted_at": "2024-04-15 23:08:10", "comments": 0, "source_title": "Google Common Lisp Style Guide", "source_text": "Google Common Lisp Style Guide\n\n# Google Common Lisp Style Guide\n\nRevision 1.28\n\nRobert Brown Fran\u00e7ois-Ren\u00e9 Rideau In memoriam Dan Weinreb\n\nPatterns mean \"I have run out of language.\" \u2014 Rich Hickey\n\nEach style point has a summary for which additional information is available\nby toggling the accompanying arrow button that looks this way: \u25b6. You may\ntoggle all summaries with the big arrow button:\n\n\u25b6 Toggle all summaries\n\nTable of Contents\n\nMeta-Guide| Must, Should, May, or Not Permission and Forgiveness Conventions\nOld Code Future Topics  \n---|---  \nGeneral Guidelines| Principles Priorities Architecture Using Libraries Open-\nSourcing Code Development Process  \nFormatting| Spelling and Abbreviations Line length Indentation File Header\nVertical white space Horizontal white space  \nDocumentation| Document everything Comment semicolons Grammar and punctuation\nAttention Required Domain-Specific Languages  \nNaming| Symbol guidelines Denote intent, not content Global variables and\nconstants Predicate names Omit library prefixes Packages  \nLanguage usage guidelines| Mostly Functional Style Recursion Special variables\nAssignment Assertions and Conditions Type Checking CLOS  \nMeta-language guidelines| Macros EVAL-WHEN Read-time evaluation EVAL INTERN\nand UNINTERN  \nData Representation| NIL: empty-list, false and I Don't Know Do not abuse\nlists Lists vs. structures vs. multiple values Lists vs. Pairs Lists vs.\nArrays Lists vs. Sets  \nProper Forms| Defining Constants Defining Functions Conditional Expressions\nIdentity, Equality and Comparisons Iteration I/O  \nOptimization| Avoid Allocation Unsafe Operations DYNAMIC-EXTENT REDUCE vs\nAPPLY Avoid NCONC  \nPitfalls| #'FUN vs. 'FUN Pathnames SATISFIES  \n  \n## Important Note\n\n### Note: Displaying Hidden Details in this Guide\n\nlink \u25b6\n\nThis style guide contains many details that are initially hidden from view.\nThey are marked by the triangle icon, which you see here on your left. Click\nit now. You should see \"Hooray\" appear below.\n\nHooray! Now you know you can expand points to get more details. Alternatively,\nthere's an \"expand all\" at the top of this document.\n\n## Background\n\nCommon Lisp is a powerful multiparadigm programming language. With great power\ncomes great responsibility.\n\nThis guide recommends formatting and stylistic choices designed to make your\ncode easier for other people to understand. For those internal applications\nand free software libraries that we develop at Google, you should keep within\nthese guidelines when making changes. Note however that each project has its\nown rules and customs that complement or override these general guidelines;\nthe speed-oriented QPX low fare search engine notably has a very different\nstyle and feel from the QRes reservation system.\n\nIf you're writing Common Lisp code outside Google, we invite you to consider\nthese guidelines. You may find some of them useful where they don't conflict\nwith other priorities you have. We welcome remarks and constructive feedback\non how to improve our guide, and on what alternate styles work for you and\nwhy.\n\nThis guide is not a Common Lisp tutorial. For basic information about the\nlanguage, please consult Practical Common Lisp. For a language reference,\nplease consult the Common Lisp HyperSpec. For more detailed style guidance,\ntake (with a pinch of salt) a look at Peter Norvig and Kent Pitman's style\nguide.\n\n## Meta-Guide\n\n### Must, Should, May, or Not\n\nlink \u25b6\n\nEach guideline's level of importance is indicated by use of the following\nkeywords and phrases, adapted from RFC 2119.\n\nMUST| This word, or the terms \"REQUIRED\" or \"SHALL\", means that the guideline\nis an absolute requirement. You must ask permission to violate a MUST.  \n---|---  \nMUST NOT| This phrase, or the phrase \"SHALL NOT\", means that the guideline is\nan absolute prohibition. You must ask permission to violate a MUST NOT.  \nSHOULD| This word, or the adjective \"RECOMMENDED\", means that there may exist\nvalid reasons in particular circumstances to ignore the demands of the\nguideline, but the full implications must be understood and carefully weighed\nbefore choosing a different course. You must ask forgiveness for violating a\nSHOULD.  \nSHOULD NOT| This phrase, or the phrase \"NOT RECOMMENDED\", means that there may\nexist valid reasons in particular circumstances to ignore the prohibitions of\nthis guideline, but the full implications should be understood and carefully\nweighed before choosing a different course. You must ask forgiveness for\nviolating a SHOULD NOT.  \nMAY| This word, or the adjective \"OPTIONAL\", means that an item is truly\noptional.  \n  \nUnlike RFCs, we don't capitalize every instance of one of the above keywords\nwhen it is used.\n\n### Permission and Forgiveness\n\nlink \u25b6\n\nThere are cases where transgression of some of these rules is useful or even\nnecessary. In some cases, you must seek permission or obtain forgiveness from\nthe proper people.\n\nPermission comes from the owners of your project.\n\nForgiveness is requested in a comment near the point of guideline violation,\nand is granted by your code reviewer. The original comment should be signed by\nyou, and the reviewer should add a signed approval to the comment at review\ntime.\n\n### Conventions\n\nlink \u25b6\n\nYou MUST follow conventions. They are not optional.\n\nSome of these guidelines are motivated by universal principles of good\nprogramming. Some guidelines are motivated by technical peculiarities of\nCommon Lisp. Some guidelines were once motivated by a technical reason, but\nthe guideline remained after the reason subsided. Some guidelines, such those\nabout as comments and indentation, are based purely on convention, rather than\non clear technical merit. Whatever the case may be, you must still follow\nthese guidelines, as well as other conventional guidelines that have not been\nformalized in this document.\n\nYou MUST follow conventions. They are important for readability. When\nconventions are followed by default, violations of the convention are a signal\nthat something notable is happening and deserves attention. When conventions\nare systematically violated, violations of the convention are a distracting\nnoise that needs to be ignored.\n\nConventional guidelines are indoctrination. Their purpose is to make you\nfollow the mores of the community, so you can more effectively cooperate with\nexisting members. It is still useful to distinguish the parts that are\ntechnically motivated from the parts that are mere conventions, so you know\nwhen best to defy conventions for good effect, and when not to fall into the\npitfalls that the conventions are there to help avoid.\n\n### Old Code\n\nlink \u25b6\n\nFix old code as you go.\n\nA lot of our code was written before these guidelines existed. You should fix\nviolations as you encounter them in the course of your normal coding.\n\nYou must not fix violations en masse without warning other developers and\ncoordinating with them, so as not to make the merging of large branches more\ndifficult than it already is.\n\n### Future Topics\n\nlink \u25b6\n\nThere are many topics for additional standardization not covered by current\nversion of this document, but deferred to future versions.\n\n  * File and directory structure\n  * Packages and modularity\n  * Threads and locking\n  * How to add configurable components\n  * CLOS style: initforms, slot and accessor names, etc.\n  * Recommendations on max number of slots per class.\n  * More concrete examples of good code:\n\n    * exceptions\n    * transactions, with retry\n    * XML\n    * typing\n    * encapsulation / abstraction\n    * class and slot names\n    * etc.\n  * When (not) to use conditional compilation:\n\n    * modifying the product\n    * conditional debugging/console output/etc.\n    * \"temporarily\" commenting-out blocks of code\n    * etc.\n\n## General Guidelines\n\n### Principles\n\nlink \u25b6\n\nThere are some basic principles for team software development that every\ndeveloper must keep in mind. Whenever the detailed guidelines are inadequate,\nconfusing or contradictory, refer back to these principles for guidance:\n\n  * Every developer's code must be easy for another developer to read, understand, and modify \u2014 even if the first developer isn't around to explain it. (This is the \"hit by a truck\" principle.)\n  * Everybody's code should look the same. Ideally, there should be no way to look at lines of code and recognize it as \"Fred's code\" by its style.\n  * Be precise.\n  * Be concise.\n  * KISS \u2014 Keep It Simple, Stupid.\n  * Use the smallest hammer for the job.\n  * Use common sense.\n  * Keep related code together. Minimize the amount of jumping around someone has to do to understand an area of code.\n\n### Priorities\n\nlink \u25b6\n\nWhen making decisions about how to write a given piece of code, aim for the\nfollowing -ilities in this priority order:\n\n  * Usability by the customer\n  * Debuggability/Testability\n  * Readability/Comprehensibility\n  * Extensibility/Modifiability\n  * Efficiency (of the Lisp code at runtime)\n\nMost of these are obvious.\n\nUsability by the customer means that the system has to do what the customer\nrequires; it has to handle the customer's transaction volumes, uptime\nrequirements; etc.\n\nFor the Lisp efficiency point, given two options of equivalent complexity,\npick the one that performs better. (This is often the same as the one that\nconses less, i.e. allocates less storage from the heap.)\n\nGiven two options where one is more complex than the other, pick the simpler\noption and revisit the decision only if profiling shows it to be a performance\nbottleneck.\n\nHowever, avoid premature optimization. Don't add complexity to speed up\nsomething that runs rarely, since in the long run, it matters less whether\nsuch code is fast.\n\n### Architecture\n\nlink \u25b6\n\nTo build code that is robust and maintainable, it matters a lot how the code\nis divided into components, how these components communicate, how changes\npropagate as they evolve, and more importantly how the programmers who develop\nthese components communicate as these components evolve.\n\nIf your work affects other groups, might be reusable across groups, adds new\ncomponents, has an impact on other groups (including QA or Ops), or otherwise\nisn't purely local, you must write it up using at least a couple of\nparagraphs, and get a design approval from the other parties involved before\nstarting to write code \u2014 or be ready to scratch what you have when they\nobject.\n\nIf you don't know or don't care about these issues, ask someone who does.\n\n### Using Libraries\n\nlink \u25b6\n\nOften, the smallest hammer is to use an existing library. Or one that doesn't\nexist yet. In such cases, you are encouraged to use or develop such a library,\nbut you must take appropriate precautions.\n\n  * You MUST NOT start a new library unless you established that none is already available that can be fixed or completed into becoming what you need. That's a rule against the NIH syndrome (\"Not Invented Here\"), which is particularly strong amongst Lisp hackers.\n  * Whichever library, old or new, you pick, you MUST get permission to incorporate third-party code into the code base. You must discuss the use of such library in the appropriate mailing-list, and have your code reviewed by people knowledgeable in the domain and/or the Lisp library ecosystem (if any). Please be ready to argue why this particular solution makes sense as compared to other available libraries.\n  * Some libraries are distributed under licenses not compatible with the software you're writing, and must not be considered available for use. Be aware of these issues, or consult with people who are.\n\n### Open-Sourcing Code\n\nlink \u25b6\n\nIf you write a general-purpose library, or modify an existing open-source\nlibrary, you are encouraged to publish the result separate from your main\nproject and then have your project import it like any other open-source\nlibrary.\n\nUse your judgment to distinguish general-purpose versus business-specific\ncode, and open-source the general-purpose parts, while keeping the business-\nspecific parts a trade secret.\n\nOpen-Sourcing code has many advantages, including being able to leverage third\nparties for development, letting the development of features be user-directed,\nand keeping you honest with respect to code quality. Whatever code you write,\nyou will have to maintain anyway, and make sure its quality is high enough to\nsustain use in production. There should therefore be no additional burden to\nOpen-Sourcing, even of code that (at least initially) is not directly usable\nby third parties.\n\n### Development Process\n\nlink \u25b6\n\nDevelopment process is outside the scope of this document. However, developers\nshould remember at least these bits: get reviewed, write tests, eliminate\nwarnings, run tests, avoid mass-changes.\n\n  * All code changes must be reviewed. You should expect that your code will be reviewed by other hackers, and that you will be assigned other hackers' code to review. Part of the review criteria will be that code obeys the coding standards in this document.\n  * You must write and check-in tests for new code that you write and old bugs you fix. There must be a unit test for every API function, and any previously failing case. Your work is not truly done until this activity is complete. Estimating tasks must include the time it takes to produce such tests.\n  * Your code must compile without any compilation error or warning messages whatsoever. If the compiler issues warnings that should be ignored, muffle those warnings using the UIOP:WITH-MUFFLED-COMPILER-CONDITIONS and UIOP:*UNINTERESTING-COMPILER-CONDITIONS* framework (part of UIOP, part of ASDF 3), either around the entire project, or around individual files (using ASDF's :around-compile hooks).\n  * All code should be checked in an appropriate source control system, in a way that allows for complete reproducibility of build, test and execution of the code that is, has been or may be deployed.\n  * You must run the \"precheckin\" tests, and each component must pass its unit tests successfully before you commit any code.\n  * You should incorporate code coverage into your testing process. Tests are not sufficient if they do not cover all new and updated code; code that for whatever reason cannot be included in coverage results should be clearly marked as such including the reason.\n  * Many people develop on branches. You must get permission to undertake mass-changes (e.g. mass reindentations) so that we can coordinate in advance, and give branch residents time to get back on the mainline\n\n## Formatting\n\n### Spelling and Abbreviations\n\nlink \u25b6\n\nYou must use correct spelling in your comments, and most importantly in your\nidentifiers.\n\nWhen several correct spellings exist (including American vs English), and\nthere isn't a consensus amongst developers as which to use, you should choose\nthe shorter spelling.\n\nYou must use only common and domain-specific abbreviations, and must be\nconsistent with these abbreviations. You may abbreviate lexical variables of\nlimited scope in order to avoid overly-long symbol names.\n\nIf you're not sure, consult a dictionary, Google for alternative spellings, or\nask a local expert.\n\nHere are examples of choosing the correct spelling:\n\n  * Use \"complimentary\" in the sense of a meal or beverage that is not paid for by the recipient, not \"complementary\".\n  * Use \"existent\" and \"nonexistent\", not \"existant\". Use \"existence\", not \"existance\".\n  * Use \"hierarchy\" not \"heirarchy\".\n  * Use \"precede\" not \"preceed\".\n  * Use \"weird\", not \"wierd\".\n\nHere are examples of choosing the shorter spelling:\n\n  * Use \"canceled\", not \"cancelled\"\n  * Use \"queuing\", not \"queueing\".\n  * Use \"signaled\", not \"signalled\";\n  * Use \"traveled\", not \"travelled\".\n  * Use \"aluminum\", not \"aluminium\"\n  * Use \"oriented\", not \"orientated\"\n  * Use \"color\", not \"colour\"\n  * Use \"behavior\", not \"behaviour\"\n\nMake appropriate exceptions for industry standard nomenclature/jargon,\nincluding plain misspellings. For instance:\n\n  * Use \"referer\", not \"referrer\", in the context of the HTTP protocol.\n\n### Line length\n\nlink \u25b6\n\nYou should format source code so that no line is longer than 100 characters.\n\nSome line length restriction is better than none at all. While old text\nterminals used to make 80 columns the standard, these days, allowing 100\ncolumns seems better, since good style encourages the use of descriptive\nvariables and function names.\n\n### Indentation\n\nlink \u25b6\n\nIndent your code the way a properly configured GNU Emacs does.\n\nMaintain a consistent indentation style throughout a project.\n\nIndent carefully to make the code easier to understand.\n\nCommon Lisp indentation in Emacs is provided by the cl-indent library. The\nlatest version of cl-indent is packaged with SLIME (under contrib/slime-cl-\nindent.el). After installing SLIME, set up Emacs to load SLIME automatically\nusing these instructions, adding slime-indentation to the list of contrib\nlibraries to be loaded in the call to slime-setup.\n\nIdeally, use the default indentation settings provided by slime-indentation.\nIf necessary, customize indentation parameters to maintain a consistent\nindentation style throughout an existing project. Parameters can be customized\nusing the :variables setting in define-common-lisp-style. Indentation of\nspecific forms can be customized using the :indentation setting of define-\ncommon-lisp-style. This is particularly useful when creating forms that behave\nlike macros or special operators that are indented differently than standard\nfunction calls (e.g. defun, labels, or let). Add a hook to 'lisp-mode-hook\nthat calls common-lisp-set-style to set the appropriate style automatically.\n\nUse indentation to make complex function applications easier to read. When an\napplication does not fit on one line or the function takes many arguments,\nconsider inserting newlines between the arguments so that each one is on a\nseparate line. However, do not insert newlines in a way that makes it hard to\ntell how many arguments the function takes or where an argument form starts\nand ends.\n\n    \n    \n    ;; Bad (do-something first-argument second-argument (lambda (x) (frob x)) fourth-argument last-argument)\n    \n    \n    ;; Better (do-something first-argument second-argument #'(lambda (x) (frob x)) fourth-argument last-argument)\n\n### File Header\n\nlink \u25b6\n\nYou should include a description at the top of each source file.\n\nYou should include neither authorship nor copyright information in a source\nfile.\n\nEvery source file should begin with a brief description of the contents of\nthat file.\n\nAfter that description, every file should start the code itself with an (in-\npackage #:package-name) form.\n\nAfter that in-package form, every file should follow with any file-specific\n(declaim (optimize ...)) declaration that is not covered by an ASDF :around-\ncompile hook.\n\n    \n    \n    ;;;; Variable length encoding for integers and floating point numbers. (in-package #:varint) (declaim #.*optimize-default*)\n\nYou should not include authorship information at the top of a file: better\ninformation is available from version control, and such a mention will only\ncause confusion and grief. Indeed, whoever was the main author at the time\nsuch a mention was included might not be who eventually made the most\nsignificant contributions to the file, and even less who is responsible for\nthe file at the moment.\n\nYou should not include copyright information in individual source code files.\nAn exception is made for files meant to be disseminated as standalone.\n\n### Vertical white space\n\nlink \u25b6\n\nVertical white space: one blank line between top-level forms.\n\nYou should include one blank line between top-level forms, such as function\ndefinitions. Exceptionally, blank lines can be omitted between simple, closely\nrelated defining forms of the same kind, such as a group of related type\ndeclarations or constant definitions.\n\n    \n    \n    (defconstant +mix32+ #x12b9b0a1 \"pi, an arbitrary number\") (defconstant +mix64+ #x2b992ddfa23249d6 \"more digits of pi\") (defconstant +golden-ratio32+ #x9e3779b9 \"the golden ratio\") (defconstant +golden-ratio64+ #xe08c1d668b756f82 \"more digits of the golden ratio\") (defmacro incf32 (x y) \"Like INCF, but for integers modulo 2**32\" `(setf ,x (logand (+ ,x ,y) #xffffffff))) (defmacro incf64 (x y) \"Like INCF, but for integers modulo 2**64\" `(setf ,x (logand (+ ,x ,y) #xffffffffffffffff)))\n\nBlank lines can be used to separate parts of a complicated function.\nGenerally, however, you should break a large function into smaller ones\ninstead of trying to make it more readable by adding vertical space. If you\ncan't, you should document with a ;; comment what each of the separated parts\nof the function does.\n\nYou should strive to keep top-level forms, including comments but excluding\nthe documentation string, of appropriate length; preferably short. Forms\nextending beyond a single page should be rare and their use should be\njustified. This applies to each of the forms in an eval-when, rather than to\nthe eval-when itself. Additionally, defpackage forms may be longer, since they\nmay include long lists of symbols.\n\n### Horizontal white space\n\nlink \u25b6\n\nHorizontal white space: none around parentheses. No tabs.\n\nYou must not include extra horizontal whitespace before or after parentheses\nor around symbols.\n\nYou must not place right parentheses by themselves on a line. A set of\nconsecutive trailing parentheses must appear on the same line.\n\n    \n    \n    ;; Very Bad ( defun factorial ( limit ) ( let (( product 1 )) ( loop for i from 1 upto limit do (setf product ( * product i ) ) ) product ) )\n    \n    \n    ;; Better (defun factorial (limit) (let ((product 1)) (loop for i from 1 upto limit do (setf product (* product i))) product))\n\nYou should use only one space between forms.\n\nYou should not use spaces to vertically align forms in the middle of\nconsecutive lines. An exception is made when the code possesses an important\nyet otherwise not visible symmetry that you want to emphasize.\n\n    \n    \n    ;; Bad (let* ((low 1) (high 2) (sum (+ (* low low) (* high high)))) ...)\n    \n    \n    ;; Better (let* ((low 1) (high 2) (sum (+ (* low low) (* high high)))) ...))\n\nYou must align nested forms if they occur across more than one line.\n\n    \n    \n    ;; Bad (defun munge (a b c) (* (+ a b) c))\n    \n    \n    ;; Better (defun munge (a b c) (* (+ a b) c))\n\nThe convention is that the body of a binding form is indented two spaces after\nthe form. Any binding data before the body is usually indented four spaces.\nArguments to a function call are aligned with the first argument; if the first\nargument is on its own line, it is aligned with the function name.\n\n    \n    \n    (multiple-value-bind (a b c d) (function-returning-four-values x y) (declare (ignore c)) (something-using a) (also-using b d))\n\nAn exception to the rule against lonely parentheses is made for an eval-when\nform around several definitions; in this case, include a comment ; eval-when\nafter the closing parenthesis.\n\nYou must set your editor to avoid inserting tab characters in the files you\nedit. Tabs cause confusion when editors disagree on how many spaces they\nrepresent. In Emacs, do (setq-default indent-tabs-mode nil).\n\n## Documentation\n\n### Document everything\n\nlink \u25b6\n\nYou should use document strings on all visible functions to explain how to use\nyour code.\n\nUnless some bit of code is painfully self-explanatory, document it with a\ndocumentation string (also known as docstring).\n\nDocumentation strings are destined to be read by the programmers who use your\ncode. They can be extracted from functions, types, classes, variables and\nmacros, and displayed by programming tools, such as IDEs, or by REPL queries\nsuch as (describe 'foo); web-based documentation or other reference works can\nbe created based on them. Documentation strings are thus the perfect locus to\ndocument your API. They should describe how to use the code (including what\npitfalls to avoid), as opposed to how the code works (and where more work is\nneeded), which is what you'll put in comments.\n\nSupply a documentation string when defining top-level functions, types,\nclasses, variables and macros. Generally, add a documentation string wherever\nthe language allows.\n\nFor functions, the docstring should describe the function's contract: what the\nfunction does, what the arguments mean, what values are returned, what\nconditions the function can signal. It should be expressed at the appropriate\nlevel of abstraction, explaining the intended meaning rather than, say, just\nthe syntax. In documentation strings, capitalize the names of Lisp symbols,\nsuch as function arguments. For example, \"The value of LENGTH should be an\ninteger.\"\n\n    \n    \n    (defun small-prime-number-p (n) \"Return T if N, an integer, is a prime number. Otherwise, return NIL.\" (cond ((or (< n 2)) nil) ((= n 2) t) ((divisorp 2 n) nil) (t (loop for i from 3 upto (sqrt n) by 2 never (divisorp i n)))))\n    \n    \n    (defgeneric table-clear (table) (:documentation \"Like clrhash, empties the TABLE of all associations, and returns the table itself.\"))\n\nA long docstring may usefully begin with a short, single-sentence summary,\nfollowed by the larger body of the docstring.\n\nWhen the name of a type is used, the symbol may be quoted by surrounding it\nwith a back quote at the beginning and a single quote at the end. Emacs will\nhighlight the type, and the highlighting serves as a cue to the reader that\nM-. will lead to the symbol's definition.\n\n    \n    \n    (defun bag-tag-expected-itinerary (bag-tag) \"Return a list of `legacy-pnr-pax-segment' objects representing the expected itinerary of the `bag-tag' object, BAG-TAG.\" ...)\n\nEvery method of a generic function should be independently documented when the\nspecialization affects what the method does, beyond what is described in its\ngeneric function's docstring.\n\nWhen you fix a bug, consider whether what the fixed code does is obviously\ncorrect or not; if not, you must add a comment explaining the reason for the\ncode in terms of fixing the bug. Adding the bug number, if any, is also\nrecommended.\n\n### Comment semicolons\n\nlink \u25b6\n\nYou must use the appropriate number of semicolons to introduce comments.\n\nComments are explanations to the future maintainers of the code. Even if\nyou're the only person who will ever see and touch the code, even if you're\neither immortal and never going to quit, or unconcerned with what happens\nafter you leave (and have your code self-destruct in such an eventuality), you\nmay find it useful to comment your code. Indeed, by the time you revisit your\ncode, weeks, months or years later, you will find yourself a different person\nfrom the one who wrote it, and you will be grateful to that previous self for\nmaking the code readable.\n\nYou must comment anything complicated so that the next developer can\nunderstand what's going on. (Again, the \"hit by a truck\" principle.)\n\nAlso use comments as a way to guide those who read the code, so they know what\nto find where.\n\n  * File headers and important comments that apply to large sections of code in a source file should begin with four semicolons.\n  * You should use three semicolons to begin comments that apply to just one top-level form or small group of top-level forms.\n  * Inside a top-level form, you should use two semicolons to begin a comment if it appears between lines.\n  * You should use one semicolon if it is a parenthetical remark and occurs at the end of a line. You should use spaces to separate the comment from the code it refers to so the comment stands out. You should try to vertically align consecutive related end-of-line comments.\n\n    \n    \n    ;;;; project-euler.lisp ;;;; File-level comments or comments for large sections of code. ;;; Problems are described in more detail here: https://projecteuler.net/ ;;; Divisibility ;;; Comments that describe a group of definitions. (defun divisorp (d n) (zerop (mod n d))) (defun proper-divisors (n) ...) (defun divisors (n) (cons n (proper-divisors n))) ;;; Prime numbers (defun small-prime-number-p (n) (cond ((or (< n 2)) nil) ((= n 2) ; parenthetical remark here t) ; continuation of the remark ((divisorp 2 n) nil) ; different remark ;; Comment that applies to a section of code. (t (loop for i from 3 upto (sqrt n) by 2 never (divisorp i n)))))\n\nYou should include a space between the semicolon and the text of the comment.\n\n### Grammar and punctuation\n\nlink \u25b6\n\nYou should punctuate documentation correctly.\n\nWhen a comment is a full sentence, you should capitalize the initial letter of\nthe first word and end the comment with a period. In general, you should use\ncorrect punctuation.\n\n### Attention Required\n\nlink \u25b6\n\nYou must follow the convention of using TODO comments for code requiring\nspecial attention. For code using unobvious forms, you must include a comment.\n\nFor comments requiring special attention, such as incomplete code, todo items,\nquestions, breakage, and danger, include a TODO comment indicating the type of\nproblem, its nature, and any notes on how it may be addressed.\n\nThe comments begin with TODO in all capital letters, followed by the name,\ne-mail address, or other identifier of the person with the best context about\nthe problem referenced by the TODO. The main purpose is to have a consistent\nTODO that can be searched to find out how to get more details upon request. A\nTODO is not a commitment that the person referenced will fix the problem. Thus\nwhen you create a TODO, it is almost always your name that is given.\n\nWhen signing comments, you should use your username (for code within the\ncompany) or full email address (for code visible outside the company), not\njust initials.\n\n    \n    \n    ;;--- TODO(george@gmail.com): Refactor to provide a better API.\n\nBe specific when indicating times or software releases in a TODO comment and\nuse YYYY-MM-DD format for dates to make automated processing of such dates\neasier, e.g., 2038-01-20 for the end of the 32-bit signed time_t.\n\n    \n    \n    ;;--- TODO(brown): Remove this code after release 1.7 or before 2012-11-30.\n\nFor code that uses unobvious forms to accomplish a task, you must include a\ncomment stating the purpose of the form and the task it accomplishes.\n\n### Domain-Specific Languages\n\nlink \u25b6\n\nYou should document DSLs and any terse program in a DSL.\n\nYou should design your Domain Specific Language to be easy to read and\nunderstand by people familiar with the domain.\n\nYou must properly document all your Domain Specific Language.\n\nSometimes, your DSL is designed for terseness. In that case, it is important\nto document what each program does, if it's not painfully obvious from the\ncontext.\n\nNotably, when you use regular expressions (e.g. with the CL-PPCRE package),\nyou MUST ALWAYS put in a comment (usually a two-semicolon comment on the\nprevious line) explaining, at least basically, what the regular expression\ndoes, or what the purpose of using it is. The comment need not spell out every\nbit of the syntax, but it should be possible for someone to follow the logic\nof the code without actually parsing the regular expression.\n\n## Naming\n\n### Symbol guidelines\n\nlink \u25b6\n\nYou should use lower case. You should follow the rules for Spelling and\nAbbreviations You should follow punctuation conventions.\n\nUse lower case for all symbols. Consistently using lower case makes searching\nfor symbol names easier and is more readable.\n\nNote that Common Lisp is case-converting, and that the symbol-name of your\nsymbols will be upper case. Because of this case-converting, attempts to\ndistinguish symbols by case are defeated, and only result in confusion. While\nit is possible to escape characters in symbols to force lower case, you should\nnot use this capability unless this is somehow necessary to interoperate with\nthird-party software.\n\nPlace hyphens between all the words in a symbol. If you can't easily say an\nidentifier out loud, it is probably badly named.\n\nYou must not use \"/\" or \".\" instead of \"-\" unless you have a well-documented\noverarching reason to, and permission from other hackers who review your\nproposal.\n\nSee the section on Spelling and Abbreviations for guidelines on using\nabbreviations.\n\n    \n    \n    ;; Bad (defvar *default-username* \"Ann\") (defvar *max-widget-cnt* 200)\n    \n    \n    ;; Better (defvar *default-user-name* \"Ann\") (defvar *maximum-widget-count* 200)\n\nThere are conventions in Common Lisp for the use of punctuation in symbols.\nYou should not use punctuation in symbols outside these conventions.\n\nUnless the scope of a variable is very small, do not use overly short names\nlike i and zq.\n\n### Denote intent, not content\n\nlink \u25b6\n\nName your variables according to their intent, not their content.\n\nYou should name a variable according to the high-level concept that it\nrepresents, not according to the low-level implementation details of how the\nconcept is represented.\n\nThus, you should avoid embedding data structure or aggregate type names, such\nas list, array, or hash-table inside variable names, unless you're writing a\ngeneric algorithm that applies to arbitrary lists, arrays, hash-tables, etc.\nIn that case it's perfectly OK to name a variable list or array.\n\nIndeed, you should be introducing new abstract data types with DEFCLASS or\nDEFTYPE, whenever a new kind of intent appears for objects in your protocols.\nFunctions that manipulate such objects generically may then use variables the\nname of which reflect that abstract type.\n\nFor example, if a variable's value is always a row (or is either a row or\nNIL), it's good to call it row or first-row or something like that. It is\nalright is row has been DEFTYPE'd to STRING \u2014 precisely because you have\nabstracted the detail away, and the remaining salient point is that it is a\nrow. You should not name the variable STRING in this context, except possibly\nin low-level functions that specifically manipulate the innards of rows to\nprovide the suitable abstraction.\n\nBe consistent. If a variable is named row in one function, and its value is\nbeing passed to a second function, then call it row rather than, say, value\n(this was a real case).\n\n### Global variables and constants\n\nlink \u25b6\n\nName globals according to convention.\n\nThe names of global constants should start and end with plus characters.\n\nGlobal variable names should start and end with asterisks (also known in this\ncontext as earmuffs).\n\nIn some projects, parameters that are not meant to be usually modified or\nbound under normal circumstances (but may be during experimentation or\nexceptional situations) should start (but do not end) with a dollar sign. If\nsuch a convention exists within your project, you should follow it\nconsistently. Otherwise, you should avoid naming variables like this.\n\nCommon Lisp does not have global lexical variables, so a naming convention is\nused to ensure that globals, which are dynamically bound, never have names\nthat overlap with local variables. It is possible to fake global lexical\nvariables with a differently named global variable and a DEFINE-SYMBOL-MACRO.\nYou should not use this trick, unless you first publish a library that\nabstracts it away.\n\n    \n    \n    (defconstant +hash-results+ #xbd49d10d10cbee50) (defvar *maximum-search-depth* 100)\n\n### Predicate names\n\nlink \u25b6\n\nNames of predicate functions and variables end with a \"P\".\n\nYou should name boolean-valued functions and variables with a trailing \"P\" or\n\"-P\", to indicate they are predicates. Generally, you should use \"P\" when the\nrest of the function name is one word and \"-P\" when it is more than one word.\n\nA rationale for this convention is given in the CLtL2 chapter on predicates.\n\nFor uniformity, you should follow the convention above, and not one of the\nalternatives below.\n\nAn alternative rule used in some existing packages is to always use \"-P\".\nAnother alternative rule used in some existing packages is to always use \"?\".\nWhen you develop such a package, you must be consistent with the rest of the\npackage. When you start a new package, you should not use such an alternative\nrule without a very good documented reason.\n\n### Omit library prefixes\n\nlink \u25b6\n\nYou should not include a library or package name as a prefix within the name\nof symbols.\n\nWhen naming a symbol (external or internal) in a package, you should not\ninclude the package name as a prefix within the name of the symbol. Naming a\nsymbol this way makes it awkward to use from a client package accessing the\nsymbol by qualifying it with a package prefix, where the package name then\nappears twice (once as a package prefix, another time as a prefix within the\nsymbol name).\n\n    \n    \n    ;; Bad (in-package #:varint) (defun varint-length64 () ... ) (in-package #:client-code) (defconst +padding+ (varint:varint-length64 +end-token+))\n    \n    \n    ;; Better (in-package #:varint) (defun length64 () ... ) (in-package #:client-code) (defconst +padding+ (varint:length64 +end-token+))\n\nAn exception to the above rule would be to include a prefix for the names of\nvariables that would otherwise be expected to clash with variables in packages\nthat use the current one. For instance, ASDF exports a variable *ASDF-VERBOSE*\nthat controls the verbosity of ASDF only, rather than of the entire Lisp\nprogram.\n\n### Packages\n\nlink \u25b6\n\nUse packages appropriately.\n\nLisp packages are used to demarcate namespaces. Usually, each system has its\nown namespace. A package has a set of external symbols, which are intended to\nbe used from outside the package, in order to allow other modules to use this\nmodule's facilities.\n\nThe internal symbols of a package should never be referred to from other\npackages. That is, you should never have to use the double-colon :: construct.\n(e.g. QUAKE::HIDDEN-FUNCTION). If you need to use double-colons to write real\nproduction code, something is wrong and needs to be fixed.\n\nAs an exception, unit tests may use the internals of the package being tested.\nSo when you refactor, watch out for internals used by the package's unit\ntests.\n\nThe :: construct is also useful for very temporary hacks, and at the REPL. But\nif the symbol really is part of the externally-visible definition of the\npackage, export it.\n\nYou may find that some internal symbols represent concepts you usually want to\nabstract away and hide under the hood, yet at times are necessary to expose\nfor various extensions. For the former reason, you do not want to export them,\nyet for the latter reason, you have to export them. The solution is to have\ntwo different packages, one for your normal users to use, and another for the\nimplementation and its extenders to use.\n\nEach package is one of two types:\n\n  * Intended to be included in the :use specification of other packages. If package A \"uses\" package B, then the external symbols of package B can be referenced from within package A without a package prefix. We mainly use this for low-level modules that provide widely-used facilities.\n  * Not intended to be \"used\". To reference a facility provided by package B, code in package A must use an explicit package prefix, e.g. B:DO-THIS.\n\nIf you add a new package, it should always be of the second type, unless you\nhave a special reason and get permission. Usually a package is designed to be\none or the other, by virtue of the names of the functions. For example, if you\nhave an abstraction called FIFO, and it were in a package of the first type\nyou'd have functions named things like FIFO-ADD-TO and FIFO-CLEAR-ALL. If you\nused a package of the second type, you'd have names like ADD-TO and CLEAR-ALL,\nbecause the callers would be saying FIFO:ADD-TO and FIFO:CLEAR-ALL.\n(FIFO:FIFO-CLEAR-ALL is redundant and ugly.)\n\nAnother good thing about packages is that your symbol names won't \"collide\"\nwith the names of other packages, except the ones your packages \"uses\". So you\nhave to stay away from symbols that are part of the Lisp implementation (since\nyou always \"use\" that) and that are part of any other packages you \"use\", but\notherwise you are free to make up your own names, even short ones, and not\nworry about some else having used the same name. You're isolated from each\nother.\n\nYour package must not shadow (and thus effectively redefine) symbols that are\npart of the Common Lisp language. There are certain exceptions, but they\nshould be very well-justified and extremely rare:\n\n  * If you are explicitly replacing a Common Lisp symbol by a safer or more featureful version.\n  * If you are defining a package not meant to be \"used\", and have a good reason to export a symbol that clashes with Common Lisp, such as log:error and log:warn and so on.\n\n## Language usage guidelines\n\n### Mostly Functional Style\n\nlink \u25b6\n\nYou should avoid side-effects when they are not necessary.\n\nLisp is best used as a \"mostly functional\" language.\n\nAvoid modifying local variables, try rebinding instead.\n\nAvoid creating objects and the SETFing their slots. It's better to set the\nslots during initialization.\n\nMake classes as immutable as possible, that is, avoid giving slots setter\nfunctions if at all possible.\n\nUsing a mostly functional style makes it much easier to write concurrent code\nthat is thread-safe. It also makes it easier to test the code.\n\n### Recursion\n\nlink \u25b6\n\nYou should favor iteration over recursion.\n\nCommon Lisp systems are not required to implement function calls from tail\npositions without leaking stack space \u2014 which is known as proper tail calls\n(PTC), tail call elimination (TCE), or tail call optimization (TCO). This\nmeans that indefinite recursion through tail calls may quickly blow out the\nstack, which hampers functional programming. Still, most serious\nimplementations (including SBCL and CCL) do implement proper tail calls, but\nwith restrictions:\n\n  * The (DECLARE (OPTIMIZE ...)) settings must favor SPEED enough and not favor DEBUG too much, for some compiler-dependent meanings of \"enough\" and \"too much\". (For instance, in SBCL, you should avoid (SPEED 0) and (DEBUG 3) to achieve proper tail calls.)\n  * There should not be dynamic bindings around the call (even though some Scheme compilers are able to properly treat such dynamic bindings, called parameters in Scheme parlance).\n\nFor compatibility with all compilers and optimization settings, and to avoid\nstack overflow when debugging, you should prefer iteration or the built in\nmapping functions to relying on proper tail calls.\n\nIf you do rely on proper tail calls, you must prominently document the fact,\nand take appropriate measures to ensure an appropriate compiler is used with\nappropriate optimization settings. For fully portable code, you may have to\nuse trampolines instead.\n\n### Special variables\n\nlink \u25b6\n\nUse special variables sparingly.\n\nUsing Lisp \"special\" (dynamically bound) variables as implicit arguments to\nfunctions should be used sparingly, and only in cases where it won't surprise\nthe person reading the code, and where it offers significant benefits.\n\nIndeed, each special variable constitutes state. Developers have to mentally\ntrack the state of all relevant variables when trying to understand what the\ncode does and how it does it; tests have to be written and run with all\nrelevant combinations; to isolate some activity, care has to be taken to\nlocally bind all relevant variables, including those of indirectly used\nmodules. They can hide precious information from being printed in a backtrace.\nNot only is there overhead associated to each new variable, but interactions\nbetween variables can make the code exponentially more complex as the number\nof such variables increases. The benefits have to match the costs.\n\nNote though that a Lisp special variable is not a global variable in the sense\nof a global variable in, say, BASIC or C. As special variables can be\ndynamically bound to a local value, they are much more powerful than global\nvalue cells where all users necessarily interfere with each other.\n\nGood candidates for such special variables are items for which \"the current\"\ncan be naturally used as prefix, such as \"the current database connection\" or\n\"the current business data source\". They are singletons as far as the rest of\nthe code is concerned, and often passing them as an explicit argument does not\nadd anything to the readability or maintainability of the source code in\nquestion.\n\nThey can make it easier to write code that can be refactored. If you have a\nrequest processing chain, with a number of layers that all operate upon a\n\"current\" request, passing the request object explicitly to every function\nrequires that every function in the chain have a request argument. Factoring\nout code into new functions often requires that these functions also have this\nargument, which clutters the code with boilerplate.\n\nYou should treat special variables as though they are per-thread variables. By\ndefault, you should leave a special variable with no top-level binding at all,\nand each thread of control that needs the variable should bind it explicitly.\nThis will mean that any incorrect use of the variable will result in an\n\"unbound variable\" error, and each thread will see its own value for the\nvariable. Variables with a default global value should usually be locally\nbound at thread creation time. You should use suitable infrastructure to\nautomate the appropriate declaration of such variables.\n\n### Assignment\n\nlink \u25b6\n\nBe consistent in assignment forms.\n\nThere are several styles for dealing with assignment and side-effects;\nwhichever a given package is using, keep using the same consistently when\nhacking said package. Pick a style that makes sense when starting a new\npackage.\n\nRegarding multiple assignment in a same form, there are two schools: the first\nstyle groups as many assignments as possible into a single SETF or PSETF form\nthus minimizing the number of forms with side-effects; the second style splits\nassignments into as many individual SETF (or SETQ, see below) forms as\npossible, to maximize the chances of locating forms that modify a kind of\nplace by grepping for (setf (foo .... A grep pattern must actually contain as\nmany place-modifying forms as you may use in your programs, which may make\nthis rationale either convincing or moot depending on the rest of the style of\nyour code. You should follow the convention used in the package you are\nhacking. We recommend the first convention for new packages.\n\nRegarding SETF and SETQ, there are two schools: this first regards SETQ as an\narchaic implementation detail, and avoids it entirely in favor of SETF; the\nsecond regards SETF as an additional layer of complexity, and avoids it in\nfavor of SETQ whenever possible (i.e. whenever the assigned place is a\nvariable or symbol-macro). You should follow the convention used in the\npackage you are hacking. We recommend the first convention for new packages.\n\nIn the spirit of a mostly pure functional style, which makes testing and\nmaintenance easier, we invite you to consider how to do things with the fewest\nassignments required.\n\n### Assertions and Conditions\n\nlink \u25b6\n\nYou must make proper usage of assertions and conditions.\n\n  * ASSERT should be used ONLY to detect internal bugs. Code should ASSERT invariants whose failure indicates that the software is itself broken. Incorrect input should be handled properly at runtime, and must not cause an assertion violation. The audience for an ASSERT failure is a developer. Do not use the data-form and argument-form in ASSERT to specify a condition to signal. It's fine to use them to print out a message for debugging purposes (and since it's only for debugging, there's no issue of internationalization).\n  * CHECK-TYPE, ETYPECASE are also forms of assertion. When one of these fails, that's a detected bug. You should prefer to use CHECK-TYPE over (DECLARE (TYPE ...)) for the inputs of functions.\n  * Your code should use assertions and type checks liberally. The sooner a bug is discovered, the better! Only code in the critical path for performance and internal helpers should eschew explicit assertions and type checks.\n  * Invalid input, such as files that are read but do not conform to the expected format, should not be treated as assertion violations. Always check to make sure that input is valid, and take appropriate action if it is not, such as signalling a real error.\n  * ERROR should be used to detect problems with user data, requests, permissions, etc., or to report \"unusual outcomes\" to the caller.\n  * ERROR should always be called with an explicit condition type; it should never simply be called with a string. This enables internationalization.\n  * Functions that report unusual outcomes by signaling a condition should say so explicitly in their contracts (their textual descriptions, in documentation and docstrings etc.). When a function signals a condition that is not specified by its contract, that's a bug. The contract should specify the condition class(es) clearly. The function may then signal any condition that is a type-of any of those conditions. That is, signaling instances of subclasses of the documented condition classes is fine.\n  * Complex bug-checks may need to use ERROR instead of ASSERT.\n  * When writing a server, you must not call WARN. Instead, you should use the appropriate logging framework.\n  * Code must not call SIGNAL. Instead, use ERROR or ASSERT.\n  * Code should not use THROW and CATCH; instead use the restart facility.\n  * Code should not generically handle all conditions, e.g. type T, or use IGNORE-ERRORS. Instead, let unknown conditions propagate to the standard ultimate handler for processing.\n  * There are a few places where handling all conditions is appropriate, but they are rare. The problem is that handling all conditions can mask program bugs. If you do need to handle \"all conditions\", you MUST handle only ERROR, not T and not SERIOUS-CONDITION. (This is notably because CCL's process shutdown depends on being able to signal process-reset and have it handled by CCL's handler, so we must not interpose our own handler.)\n  * (error (make-condition 'foo-error ...)) is equivalent to (error 'foo-error ...) \u2014 code must use the shorter form.\n  * Code should not signal conditions from inside the cleanup form of UNWIND-PROTECT (unless they are always handled inside the cleanup form), or otherwise do non-local exits from cleanup handlers outside of the handler e.g. INVOKE-RESTART.\n  * Do not clean up by resignaling. If you do that, and the condition is not handled, the stack trace will halt at the point of the resignal, hiding the rest. And the rest is the part we really care about!\n    \n        ;; Bad (handler-case (catch 'ticket-at (etd-process-blocks)) (error (c) (reset-parser-values) (error c)))\n    \n        ;; Better (unwind-protect (catch 'ticket-at (etd-process-blocks)) (reset-parser-values))\n\n### Type Checking\n\nlink \u25b6\n\nIf you know the type of something, you should make it explicit in order to\nenable compile-time and run-time sanity-checking.\n\nIf your function is using a special variable as an implicit argument, it's\ngood to put in a CHECK-TYPE for the special variable, for two reasons: to clue\nin the person reading the code that this variable is being used implicitly as\nan argument, and also to help detect bugs.\n\nUsing (declare (type ...)) is the least-desirable mechanism to use because, as\nScott McKay puts it:\n\n> The fact is, (declare (type ...)) does different things depending on the\n> compiler settings of speed, safety, etc. In some compilers, when speed is\n> greater than safety, (declare (type ...)) will tell the compiler \"please\n> assume that these variables have these types\" without generating any type-\n> checks. That is, if some variable has the value 1432 in it, and you declare\n> it to be of type string, the compiler might just go ahead and use it as\n> though it's a string.\n>\n> Moral: don't use (declare (type ...)) to declare the contract of any API\n> functions, it's not the right thing. Sure, use it for \"helper\" functions,\n> but not API functions.\n\nYou should, of course, use appropriate declarations in internal low-level\nfunctions where these declarations are used for optimization. When you do,\nhowever, see our recommendations for Unsafe Operations.\n\n### CLOS\n\nlink \u25b6\n\nUse CLOS appropriately.\n\nWhen a generic function is intended to be called from other modules (other\nparts of the code), there should be an explicit DEFGENERIC form, with a\n:DOCUMENTATION string explaining the generic contract of the function (as\nopposed to its behavior for some specific class). It's generally good to do\nexplicit DEFGENERIC forms, but for module entry points it is mandatory.\n\nWhen the argument list of a generic function includes &KEY, the DEFGENERIC\nshould always explicitly list all of the keyword arguments that are\nacceptable, and explain what they mean. (Common Lisp does not require this,\nbut it is good form, and it may avoid spurious warnings on SBCL.)\n\nYou should avoid SLOT-VALUE and WITH-SLOTS, unless you absolutely intend to\ncircumvent any sort of method combination that might be in effect for the\nslot. Rare exceptions include INITIALIZE-INSTANCE and PRINT-OBJECT methods and\naccessing normally hidden slots in the low-level implementation of methods\nthat provide user-visible abstractions. Otherwise, you should use accessors,\nWITH-ACCESSORS\n\nAccessor names generally follow a convention of <protocol-name>-<slot-name>,\nwhere a \"protocol\" in this case loosely indicates a set of functions with\nwell-defined behavior.\n\nNo implication of a formal \"protocol\" concept is necessarily intended, much\nless first-class \"protocol\" objects. However, there may indeed be an abstract\nCLOS class or an Interface-Passing Style interface that embodies the protocol.\nFurther (sub)classes or (sub)interfaces may then implement all or part of a\nprotocol by defining some methods for (generic) functions in the protocol,\nincluding readers and writers.\n\nFor example, if there were a notional protocol called is pnr with accessors\npnr-segments and pnr-passengers, then the classes air-pnr, hotel-pnr and car-\npnr could each reasonably implement methods for pnr-segments and pnr-\npassengers as accessors.\n\nBy default, an abstract base class name is used as the notional protocol name,\nso accessor names default to <class-name>-<slot-name>; while such names are\nthus quite prevalent, this form is neither required nor even preferred. In\ngeneral, it contributes to \"symbol bloat\", and in many cases has led to a\nproliferation of \"trampoline\" methods.\n\nAccessors named <slot-name>-of should not be used.\n\nExplicit DEFGENERIC forms should be used when there are (or it is anticipated\nthat there will be) more than one DEFMETHOD for that generic function. The\nreason is that the documentation for the generic function explains the\nabstract contract for the function, as opposed to explaining what an\nindividual method does for some specific class(es).\n\nYou must not use generic functions where there is no notional protocol. To put\nit more concretely, if you have more than one generic function that\nspecializes its Nth argument, the specializing classes should all be\ndescendants of a single class. Generic functions must not be used for\n\"overloading\", i.e. simply to use the same name for two entirely unrelated\ntypes.\n\nMore precisely, it's not really whether they descend from a common superclass,\nbut whether they obey the same \"protocol\". That is, the two classes should\nhandle the same set of generic functions, as if there were an explicit\nDEFGENERIC for each method.\n\nHere's another way to put it. Suppose you have two classes, A and B, and a\ngeneric function F. There are two methods for F, which dispatch on an argument\nbeing of types A and B. Is it plausible that there might be a function call\nsomewhere in the program that calls F, in which the argument might sometimes,\nat runtime, be of class A and other times be of class B? If not, you probably\nare overloading and should not be using a single generic function.\n\nWe allow one exception to this rule: it's OK to do overloading if the\ncorresponding argument \"means\" the same thing. Typically one overloading\nallows an X object, and the other allows the name of an X object, which might\nbe a symbol or something.\n\nYou must not use MOP \"intercessory\" operations at runtime. You should not use\nMOP \"intercessory\" operations at compile-time. At runtime, they are at worst a\ndanger, at best a performance issue. At compile-time, it is usually cleaner\nthat macros should set things up the right way in one pass than have to\nrequire a second pass of fixups through intercession; but sometimes, fixups\nare necessary to resolve forward references, and intercession is allowed then.\nMOP intercession is a great tool for interactive development, and you may\nenjoy it while developping and debugging; but you should not use it in normal\napplications.\n\nIf a class definition creates a method as a :READER, :WRITER, or :ACCESSOR, do\nnot redefine that method. It's OK to add :BEFORE, :AFTER, and :AROUND methods,\nbut don't override the primary method.\n\nIn methods with keyword arguments, you must always use &KEY, even if the\nmethod does not care about the values of any keys, and you should never use\n&ALLOW-OTHER-KEYS. As long as a keyword is accepted by any method of a generic\nfunction, it's OK to use it in the generic function, even if the other methods\nof the same generic function don't mention it explicitly. This is particularly\nimportant for INITIALIZE-INSTANCE methods, since if you did use &ALLOW-OTHER-\nKEYS, it would disable error checking for misspelled or wrong keywords in\nMAKE-INSTANCE calls!\n\nA typical PRINT-OBJECT method might look like this:\n\n    \n    \n    (defmethod print-object ((p person) stream) (print-unreadable-object (p stream :type t :identity t) (with-slots (first-name last-name) p (safe-format stream \"~a ~a\" first-name last-name))))\n\n## Meta-language guidelines\n\n### Macros\n\nlink \u25b6\n\nUse macros when appropriate, which is often. Define macros when appropriate,\nwhich is seldom.\n\nMacros bring syntactic abstraction, which is a wonderful thing. It helps make\nyour code clearer, by describing your intent without getting bogged in\nimplementation details (indeed abstracting those details away). It helps make\nyour code more concise and more readable, by eliminating both redundancy and\nirrelevant details. But it comes at a cost to the reader, which is learning a\nnew syntactic concept for each macro. And so it should not be abused.\n\nThe general conclusion is that there shouldn't be any recognizable design\npattern in a good Common Lisp program. The one and only pattern is: use the\nlanguage, which includes defining and using syntactic abstractions.\n\nExisting macros must be used whenever they make code clearer by conveying\nintent in a more concise way, which is often. When a macro is available in\nyour project that expresses the concept you're using, you must not write the\nexpansion rather than use the macro.\n\nNew macros should be defined as appropriate, which should be seldom, for\ncommon macros have already been provided by the language and its various\nlibraries, and your program typically only needs few new ones relative to its\nsize.\n\nYou should follow the OAOOM rule of thumb for deciding when to create a new\nabstraction, whether syntactic or not: if a particular pattern is used more\nthan twice, it should probably be abstracted away. A more refined rule to\ndecide when to use abstraction should take into account the benefit in term of\nnumber of uses and gain at each use, to the costs in term of having to get\nused to reading the code. For syntactic abstractions, costs and benefits to\nthe reader is usually more important than costs and benefits to the writer,\nbecause good code is usually written once and read many times by many people\n(including the same programmer who has to maintain the program after having\nforgotten it). Yet the cost to the writer of the macro should also be taken\ninto account; however, in doing so it should rather be compared to the cost of\nthe programmer writing other code instead that may have higher benefits.\n\nUsing Lisp macros properly requires taste. Avoid writing complicated macros\nunless the benefit clearly outweighs the cost. It takes more effort for your\nfellow developers to learn your macro, so you should only use a macro if the\ngain in expressiveness is big enough to justify that cost. As usual, feel free\nto consult your colleagues if you're not sure, since without a lot of Lisp\nexperience, it can be hard to make this judgment.\n\nYou must never use a macro where a function will do. That is, if the semantics\nof what you are writing conforms to the semantics of a function, then you must\nwrite it as a function rather than a macro.\n\nYou must not transform a function into a macro for performance reasons. If\nprofiling shows that you have a performance problem with a specific function\nFOO, document the need and profiling-results appropriately, and (declaim\n(inline foo)).\n\nYou can also use a compiler-macro as a way to speed up function execution by\nspecifying a source-to-source transformation. Beware that it interferes with\ntracing the optimized function.\n\nWhen you write a macro-defining macro (a macro that generates macros),\ndocument and comment it particularly clearly, since these are harder to\nunderstand.\n\nYou must not install new reader macros without a consensus among the\ndevelopers of your system. Reader macros must not leak out of the system that\nuses them to clients of that system or other systems used in the same project.\nYou must use software such as cl-syntax or named-readtables to control how\nreader macros are used. This clients who desire it may use the same reader\nmacros as you do. In any case, your system must be usable even to clients who\ndo not use these reader macros.\n\nIf your macro has a parameter that is a Lisp form that will be evaluated when\nthe expanded code is run, you should name the parameter with the suffix -form.\nThis convention helps make it clearer to the macro's user which parameters are\nLisp forms to be evaluated, and which are not. The common names body and end\nare exceptions to this rule.\n\nYou should follow the so-called CALL-WITH style when it applies. This style is\nexplained at length in http://random-state.net/log/3390120648.html. The\ngeneral principle is that the macro is strictly limited to processing the\nsyntax, and as much of the semantics as possible is kept in normal functions.\nTherefore, a macro WITH-FOO is often limited to generating a call to an\nauxiliary function CALL-WITH-FOO with arguments deduced from the macro\narguments. Macro &body arguments are typically wrapped into a lambda\nexpression of which they become the body, which is passed as one of the\narguments of the auxiliary function.\n\nThe separation of syntactic and semantic concerns is a general principle of\nstyle that applies beyond the case of WITH- macros. Its advantages are many.\nBy keeping semantics outside the macro, the macro is made simpler, easier to\nget right, and less subject to change, which makes it easier to develop and\nmaintain. The semantics is written in a simpler language \u2014 one without staging\n\u2014 which also makes it easier to develop and maintain. It becomes possible to\ndebug and update the semantic function without having to recompile all clients\nof the macro. The semantic function appears in the stack trace which also\nhelps debug client functions. The macro expansion is made shorter and each\nexpansion shares more code with other expansions, which reduces memory\npressure which in turn usually makes things faster. It also makes sense to\nwrite the semantic functions first, and write the macros last as syntactic\nsugar on top. You should use this style unless the macro is used in tight\nloops where performance matters; and even then, see our rules regarding\noptimization.\n\nAny functions (closures) created by the macro should be named, which can be\ndone using FLET. This also allows you to declare the function to be of dynamic\nextent (if it is \u2014 and often it is; yet see below regarding DYNAMIC-EXTENT).\n\nIf a macro call contains a form, and the macro expansion includes more than\none copy of that form, the form can be evaluated more than once, and code it\ncontains macro-expanded and compiled more than once. If someone uses the macro\nand calls it with a form that has side effects or that takes a long time to\ncompute, the behavior will be undesirable (unless you're intentionally writing\na control structure such as a loop). A convenient way to avoid this problem is\nto evaluate the form only once, and bind a (generated) variable to the result.\nThere is a very useful macro called ALEXANDRIA:ONCE-ONLY that generates code\nto do this. See also ALEXANDRIA:WITH-GENSYMS, to make some temporary variables\nin the generated code. Note that if you follow our CALL-WITH style, you\ntypically expand the code only once, as either an argument to the auxiliary\nfunction, or the body of a lambda passed as argument to it; you therefore\navoid the above complexity.\n\nWhen you write a macro with a body, such as a WITH-xxx macro, even if there\naren't any parameters, you should leave space for them anyway. For example, if\nyou invent WITH-LIGHTS-ON, do not make the call to it look like (defmacro\nwith-lights-on (&body b) ...). Instead, do (defmacro with-lights-on (() &body\nb) ...). That way, if parameters are needed in the future, you can add them\nwithout necessarily having to change all the uses of the macro.\n\n### EVAL-WHEN\n\nlink \u25b6\n\nWhen using EVAL-WHEN, you should almost always use all of (:compile-toplevel\n:load-toplevel :execute).\n\nLisp evaluation happens at several times, some of them interleaved. Be aware\nof them when writing macros. EVAL-WHEN considered harmful to your mental\nhealth.\n\nIn summary of the article linked above, unless you're doing truly advanced\nmacrology, the only valid combination in an EVAL-WHEN is to include all of\n(eval-when (:compile-toplevel :load-toplevel :execute) ...)\n\nYou must use (eval-when (:compile-toplevel :load-toplevel :execute) ...)\nwhenever you define functions, types, classes, constants, variables, etc.,\nthat are going to be used in macros.\n\nIt is usually an error to omit the :execute, because it prevents LOADing the\nsource rather than the fasl. It is usually an error to omit the :load-toplevel\n(except to modify e.g. readtables and compile-time settings), because it\nprevents LOADing future files or interactively compiling code that depends on\nthe effects that happen at compile-time, unless the current file was COMPILE-\nFILEd within the same Lisp session.\n\nRegarding variables, note that because macros may or may not be expanded in\nthe same process that runs the expanded code, you must not depend on compile-\ntime and runtime effects being either visible or invisible at the other time.\nThere are still valid uses of variables in macros:\n\n  * Some variables may hold dictionaries for some new kind of definition and other meta-data. If such meta-data is to be visible at runtime and/or in other files, you must make sure that the macro expands into code that will register the definitions to those meta-data structures at load-time, in addition to effecting the registration at compile-time. Typically, your top-level definitions expand to code that does the registration. if your code doesn't expand at the top-level, you can sometimes use LOAD-TIME-VALUE for good effect. In extreme cases, you may have to use ASDF-FINALIZERS:EVAL-AT-TOPLEVEL.\n  * Some variables may hold temporary data that is only used at compile-time in the same file, and can be cleaned up at the end of the file's compilation. Predefined such variables would include *readtable* or compiler-internal variables holding the current optimization settings. You can often manage existing and new such variables using the :AROUND-COMPILE hooks of ASDF.\n\n### Read-time evaluation\n\nlink \u25b6\n\nYou should use #. sparingly, and you must avoid read-time side-effects.\n\nThe #. standard read-macro will read one object, evaluate the object, and have\nthe reader return the resulting value.\n\nYou must not use it where other idioms will do, such as using EVAL-WHEN to\nevaluate side-effects at compile-time, using a regular macro to return an\nexpression computed at compile-time, using LOAD-TIME-VALUE to compute it at\nload-time.\n\nRead-time evaluation is often used as a quick way to get something evaluated\nat compile time (actually \"read time\" but it amounts to the same thing). If\nyou use this, the evaluation MUST NOT have any side effects and MUST NOT\ndepend on any variable global state. The #. should be treated as a way to\nforce \"constant-folding\" that a sufficiently-clever compiler could have figure\nout all by itself, when the compiler isn't sufficiently-clever and the\ndifference matters.\n\nAnother use of #. is to expand the equivalent of macros in places that are\nneither expressions nor (quasi)quotations, such as lambda-lists. However, if\nyou find yourself using it a lot, it might be time to instead define macros to\nreplace your consumers of lambda-lists with something that recognizes an\nextension.\n\nWhenever you are going to use #., you should consider using DEFCONSTANT and\nits variants, possibly in an EVAL-WHEN, to give the value a name explaining\nwhat it means.\n\n### EVAL\n\nlink \u25b6\n\nYou must not use EVAL at runtime.\n\nPlaces where it is actually appropriate to use EVAL are so few and far between\nthat you must consult with your reviewers; it's easily misused.\n\nIf your code manipulates symbols at runtime and needs to get the value of a\nsymbol, use SYMBOL-VALUE, not EVAL.\n\nOften, what you really need is to write a macro, not to use EVAL.\n\nYou may be tempted to use EVAL as a shortcut to evaluating expressions in a\nsafe subset of the language. But it often requires more scrutiny to properly\ncheck and sanitize all possible inputs to such use of EVAL than to build a\nspecial-purpose evaluator. You must not use EVAL in this way at runtime.\n\nPlaces where it is OK to use EVAL are:\n\n  * The implementation of an interactive development tool.\n  * The build infrastructure.\n  * Backdoors that are part of testing frameworks. (You MUST NOT have such backdoors in production code.)\n  * Macros that fold constants at compile-time.\n  * Macros that register definitions to meta-data structures; the registration form is sometimes evaluated at compile-time as well as included in the macro-expansion, so it is immediately available to other macros.\n\nNote that in the latter case, if the macro isn't going to be used at the top-\nlevel, it might not be possible to make these definitions available as part of\nthe expansion. The same phenomenon may happen in a DEFTYPE expansion, or in\nhelper functions used by macros. In these cases, you may actually have to use\nASDF-FINALIZERS:EVAL-AT-TOPLEVEL in your macro. It will not only EVAL your\ndefinitions at macro-expansion time for immediate availability, it will also\nsave the form aside, for inclusion in a (ASDF-FINALIZERS:FINAL-FORMS) that you\nneed to include at the end of the file being compiled (or before the form is\nneeded). This way, the side-effects are present when loading the fasl without\nhaving compiled it as well as while compiling it; in either case, the form is\nmade available at load-time. ASDF-FINALIZERS ensures that the form is present,\nby throwing an error if you omit it.\n\n### INTERN and UNINTERN\n\nlink \u25b6\n\nYou must not use INTERN or UNINTERN at runtime.\n\nYou must not use INTERN at runtime. Not only does it cons, it either creates a\npermanent symbol that won't be collected or gives access to internal symbols.\nThis creates opportunities for memory leaks, denial of service attacks,\nunauthorized access to internals, clashes with other symbols.\n\nYou must not INTERN a string just to compare it to a keyword; use STRING= or\nSTRING-EQUAL.\n\n    \n    \n    (member (intern str :keyword) $keys) ; Bad\n    \n    \n    (member str $keys :test #'string-equal) ; Better\n\nYou must not use UNINTERN at runtime. It can break code that relies on dynamic\nbinding. It makes things harder to debug. You must not dynamically intern any\nnew symbol, and therefore you need not dynamically unintern anything.\n\nYou may of course use INTERN at compile-time, in the implementation of some\nmacros. Even so, it is usually more appropriate to use abstractions on top of\nit, such as ALEXANDRIA:SYMBOLICATE or ALEXANDRIA:FORMAT-SYMBOL to create the\nsymbols you need.\n\n## Data Representation\n\n### NIL: empty-list, false and I Don't Know\n\nlink \u25b6\n\nAppropriately use or avoid using NIL.\n\nNIL can have several different interpretations:\n\n  * \"False.\" In this case, use NIL. You should test for false NIL using the operator NOT or using the predicate function NULL.\n  * \"Empty-list.\" In this case, use '(). (Be careful about quoting the empty-list when calling macros.) You should use ENDP to test for the empty list when the argument is known to be a proper list, or with NULL otherwise.\n  * A statement about some value being unspecified. In this case, you may use NIL if there is no risk of ambiguity anywhere in your code; otherwise you should use an explicit, descriptive symbol.\n  * A statement about some value being known not to exist. In this case, you should use an explicit, descriptive symbol instead of NIL.\n\nYou must not introduce ambiguity in your data representations that will cause\nheadaches for whoever has to debug code. If there is any risk of ambiguity,\nyou should use an explicit, descriptive symbol or keyword for each case,\ninstead of using NIL for either. If you do use NIL, you must make sure that\nthe distinction is well documented.\n\nIn many contexts, instead of representing \"I don't know\" as a particular\nvalue, you should instead use multiple values, one for the value that is known\nif any, and one to denote whether the value was known or found.\n\nWhen working with database classes, keep in mind that NIL need not always map\nto 'NULL' (and vice-versa)! The needs of the database may differ from the\nneeds of the Lisp.\n\n### Do not abuse lists\n\nlink \u25b6\n\nYou must select proper data representation. You must not abuse the LIST data\nstructure.\n\nEven though back in 1958, LISP was short for \"LISt Processing\", its successor\nCommon Lisp has been a modern programming language with modern data structures\nsince the 1980s. You must use the proper data structures in your programs.\n\nYou must not abuse the builtin (single-linked) LIST data structure where it is\nnot appropriate, even though Common Lisp makes it especially easy to use it.\n\nYou must only use lists when their performance characteristics is appropriate\nfor the algorithm at hand: sequential iteration over the entire contents of\nthe list.\n\nAn exception where it is appropriate to use lists is when it is known in\nadvance that the size of the list will remain very short (say, less than 16\nelements).\n\nList data structures are often (but not always) appropriate for macros and\nfunctions used by macros at compile-time: indeed, not only is source code\npassed as lists in Common Lisp, but the macro-expansion and compilation\nprocesses will typically walk over the entire source code, sequentially, once.\n(Note that advanced macro systems don't directly use lists, but instead use\nabstract syntax objects that track source code location and scope; however\nthere is no such advanced macro system in Common Lisp at this time.)\n\nAnother exception where it is appropriate to use lists is for introducing\nliteral constants that will be transformed into more appropriate data\nstructures at compile-time or load-time. It is a good to have a function with\na relatively short name to build your program's data structures from such\nliterals.\n\nIn the many cases when lists are not the appropriate data structure, various\nlibraries such as cl-containers or lisp-interface-library provide plenty of\ndifferent data structures that should fulfill all the basic needs of your\nprograms. If the existing libraries are not satisfactory, see above about\nUsing Libraries and Open-Sourcing Code.\n\n### Lists vs. structures vs. multiple values\n\nlink \u25b6\n\nYou should use the appropriate representation for product types.\n\nYou should avoid using a list as anything besides a container of elements of\nlike type. You must not use a list as method of passing multiple separate\nvalues of different types in and out of function calls. Sometimes it is\nconvenient to use a list as a little ad hoc structure, i.e. \"the first element\nof the list is a FOO, and the second is a BAR\", but this should be used\nminimally since it gets harder to remember the little convention. You must\nonly use a list that way when destructuring the list of arguments from a\nfunction, or creating a list of arguments to which to APPLY a function.\n\nThe proper way to pass around an object comprising several values of\nheterogeneous types is to use a structure as defined by DEFSTRUCT or DEFCLASS.\n\nYou should use multiple values only when function returns a small number of\nvalues that are meant to be destructured immediately by the caller, rather\nthan passed together as arguments to further functions.\n\nYou should not return a condition object as one of a set of multiple values.\nInstead, you should signal the condition to denote an unusual outcome.\n\nYou should signal a condition to denote an unusual outcome, rather than\nrelying on a special return type.\n\n### Lists vs. Pairs\n\nlink \u25b6\n\nUse the appropriate functions when manipulating lists.\n\nUse FIRST to access the first element of a list, SECOND to access the second\nelement, etc. Use REST to access the tail of a list. Use ENDP to test for the\nend of the list.\n\nUse CAR and CDR when the cons cell is not being used to implement a proper\nlist and is instead being treated as a pair of more general objects. Use NULL\nto test for NIL in this context.\n\nThe latter case should be rare outside of alists, since you should be using\nstructures and classes where they apply, and data structure libraries when you\nwant trees.\n\nExceptionally, you may use CDADR and other variants on lists when manually\ndestructuring them, instead of using a combination of several list accessor\nfunctions. In this context, using CAR and CDR instead of FIRST and REST also\nmakes sense. However, keep in mind that it might be more appropriate in such\ncases to use higher-level constructs such as DESTRUCTURING-BIND or\nOPTIMA:MATCH.\n\n### Lists vs. Arrays\n\nlink \u25b6\n\nYou should use arrays rather than lists where random access matters.\n\nELT has O(n) behavior when used on lists. If you are to use random element\naccess on an object, use arrays and AREF instead.\n\nThe exception is for code outside the critical path where the list is known to\nbe small anyway.\n\n### Lists vs. Sets\n\nlink \u25b6\n\nYou should only use lists as sets for very small lists.\n\nUsing lists as representations of sets is a bad idea unless you know the lists\nwill be small, for accessors are O(n) instead of O(log n). For arbitrary big\nsets, use balanced binary trees, for instance using lisp-interface-library.\n\nIf you still use lists as sets, you should not UNION lists just to search\nthem.\n\n    \n    \n    (member foo (union list-1 list-2)) ; Bad\n    \n    \n    (or (member foo list-1) (member foo list-2)) ; Better\n\nIndeed, UNION not only conses unnecessarily, but it can be O(n^2) on some\nimplementations, and is rather slow even when it's O(n).\n\n## Proper Forms\n\nYou must follow the proper usage regarding well-known functions, macros and\nspecial forms.\n\n### Defining Constants\n\nlink \u25b6\n\nYou must use proper defining forms for constant values.\n\nThe Lisp system we primarily use, SBCL, is very picky and signals a condition\nwhenever a constant is redefined to a value not EQL to its previous setting.\nYou must not use DEFCONSTANT when defining variables that are not numbers,\ncharacters, or symbols (including booleans and keywords). Instead,\nconsistently use whichever alternative is recommended for your project.\n\n    \n    \n    ;; Bad (defconstant +google-url+ \"https://www.google.com/\") (defconstant +valid-colors+ '(red green blue))\n\nOpen-Source libraries may use ALEXANDRIA:DEFINE-CONSTANT for constants other\nthan numbers, characters and symbols (including booleans and keywords). You\nmay use the :TEST keyword argument to specify an equality predicate.\n\n    \n    \n    ;; Better, for Open-Source code: (define-constant +google-url+ \"https://www.google.com/\" :test #'string=) (define-constant +valid-colors+ '(red green blue))\n\nNote that with optimizing implementations, such as SBCL or CMUCL, defining\nconstants this way precludes any later redefinition short of UNINTERNing the\nsymbol and recompiling all its clients. This may make it \"interesting\" to\ndebug things at the REPL or to deploy live code upgrades. If there is a chance\nthat your \"constants\" are not going to be constant over the lifetime of your\nserver processes after taking into consideration scheduled and unscheduled\ncode patches, you should consider using DEFPARAMETER or DEFVAR instead, or\npossibly a variant of DEFINE-CONSTANT that builds upon some future library\nimplementing global lexicals rather than DEFCONSTANT. You may keep the +plus+\nconvention in these cases to document the intent of the parameter as a\nconstant.\n\nAlso note that LOAD-TIME-VALUE may help you avoid the need for defined\nconstants.\n\n### Defining Functions\n\nlink \u25b6\n\nYou should make proper use of &OPTIONAL and &KEY arguments. You should not use\n&AUX arguments.\n\nYou should avoid using &ALLOW-OTHER-KEYS, since it blurs the contract of a\nfunction. Almost any real function (generic or not) allows a certain fixed set\nof keywords, as far as its caller is concerned, and those are part of its\ncontract. If you are implementing a method of a generic function, and it does\nnot need to know the values of some of the keyword arguments, you should\nexplicitly (DECLARE (IGNORE ...)) all the arguments that you are not using.\nYou must not use &ALLOW-OTHER-KEYS unless you explicitly want to disable\nchecking of allowed keys for all methods when invoking the generic function on\narguments that match this particular method. Note that the contract of a\ngeneric function belongs in the DEFGENERIC, not in the DEFMETHOD which is\nbasically an \"implementation detail\" of the generic function as far as the\ncaller of the generic is concerned.\n\nA case where &ALLOW-OTHER-KEYS is appropriate is when you write a wrapper\nfunction to other some other functions that may vary (within the computation\nor during development), and pass around a plist as a &REST argument.\n\nYou should avoid using &AUX arguments.\n\nYou should avoid having both &OPTIONAL and &KEY arguments, unless it never\nmakes sense to specify keyword arguments when the optional arguments are not\nall specified. You must not have non-NIL defaults to your &OPTIONAL arguments\nwhen your function has both &OPTIONAL and &KEY arguments.\n\nFor maximum portability of a library, it is good form that DEFMETHOD\ndefinitions should (DECLARE (IGNORABLE ...)) all the required arguments that\nthey are not using. Indeed, some implementations will issue a warning if you\n(DECLARE (IGNORE ...)) those arguments, whereas other implementations will\nissue a warning if you fail to (DECLARE (IGNORE ...)) them. (DECLARE\n(IGNORABLE ...)) works on all implementations.\n\nYou should avoid excessive nesting of binding forms inside a function. If your\nfunction ends up with massive nesting, you should probably break it up into\nseveral functions or macros. If it is really a single conceptual unit,\nconsider using a macro such as FARE-UTILS:NEST to at least reduce the amount\nof indentation required. It is bad form to use NEST in typical short functions\nwith 4 or fewer levels of nesting, but also bad form not to use it in the\nexceptional long functions with 10 or more levels of nesting. Use your\njudgment and consult your reviewers.\n\n### Conditional Expressions\n\nlink \u25b6\n\nUse the appropriate conditional form.\n\nUse WHEN and UNLESS when there is only one alternative. Use IF when there are\ntwo alternatives and COND when there are several.\n\nHowever, don't use PROGN for an IF clause \u2014 use COND, WHEN, or UNLESS.\n\nNote that in Common Lisp, WHEN and UNLESS return NIL when the condition is not\nmet. You may take advantage of it. Nevertheless, you may use an IF to\nexplicitly return NIL if you have a specific reason to insist on the return\nvalue. You may similarly include a fall-through clause (t nil) as the last in\nyour COND, or (otherwise nil) as the last in your CASE, to insist on the fact\nthat the value returned by the conditional matters and that such a case is\ngoing to be used. You should omit the fall-through clause when the conditional\nis used for side-effects.\n\nYou should prefer AND and OR when it leads to more concise code than using IF,\nCOND, WHEN or UNLESS, and there are no side-effects involved. You may also use\nan ERROR as a side-effect in the final clause of an OR.\n\nYou should only use CASE and ECASE to compare numbers, characters or symbols\n(including booleans and keywords). Indeed, CASE uses EQL for comparisons, so\nstrings, pathnames and structures may not compare the way you expect, and 1\nwill differ from 1.0.\n\nYou should use ECASE and ETYPECASE in preference to CASE and TYPECASE. It is\nbetter to catch erroneous values early.\n\nYou should not use CCASE or CTYPECASE at all. At least, you should not use\nthem in server processes, unless you have quite robust error handling\ninfrastructure and make sure not to leak sensitive data this way. These are\nmeant for interactive use, and can cause interesting damage if they cause data\nor control to leak to attackers.\n\nYou must not use gratuitous single quotes in CASE forms. This is a common\nerror:\n\n    \n    \n    (case x ; Bad: silently returns NIL on mismatch ('bar :bar) ; Bad: catches QUOTE ('baz :baz)) ; Bad: also would catch QUOTE\n    \n    \n    (ecase x ; Better: will error on mismatch ((bar) :bar) ; Better: won't match QUOTE ((baz) :baz)) ; Better: same reason\n\n'BAR there is (QUOTE BAR), meaning this leg of the case will be executed if X\nis QUOTE... and ditto for the second leg (though QUOTE will be caught by the\nfirst clause). This is unlikely to be what you really want.\n\nIn CASE forms, you must use otherwise instead of t when you mean \"execute this\nclause if the others fail\". You must use ((t) ...) when you mean \"match the\nsymbol T\" rather than \"match anything\". You must also use ((nil) ...) when you\nmean \"match the symbol NIL\" rather than \"match nothing\".\n\nTherefore, if you want to map booleans NIL and T to respective symbols :BAR\nand :QUUX, you should avoid the former way and do it the latter way:\n\n    \n    \n    (ecase x ; Bad: has no actual error case! (nil :bar)) ; Bad: matches nothing (t :quux)) ; Bad: matches anything\n    \n    \n    (ecase x ; Better: will actually catch non-booleans ((nil) :bar)) ; Better: matches NIL ((t) :quux)) ; Better: matches T\n\n### Identity, Equality and Comparisons\n\nlink \u25b6\n\nYou should use the appropriate predicates when comparing objects.\n\nLisp provides four general equality predicates: EQ, EQL, EQUAL, and EQUALP,\nwhich subtly vary in semantics. Additionally, Lisp provides the type-specific\npredicates =, CHAR=, CHAR-EQUAL, STRING=, and STRING-EQUAL. Know the\ndistinction!\n\nYou should use EQL to compare objects and symbols for identity.\n\nYou must not use EQ to compare numbers or characters. Two numbers or\ncharacters that are EQL are not required by Common Lisp to be EQ.\n\nWhen choosing between EQ and EQL, you should use EQL unless you are writing\nperformance-critical low-level code. EQL reduces the opportunity for a class\nof embarrassing errors (i.e. if numbers or characters are ever compared).\nThere may a tiny performance cost relative to EQ, although under SBCL, it\noften compiles away entirely. EQ is equivalent to EQL and type declarations,\nand use of it for optimization should be treated just like any such unsafe\noperations.\n\nYou should use CHAR= for case-dependent character comparisons, and CHAR-EQUAL\nfor case-ignoring character comparisons.\n\nYou should use STRING= for case-dependent string comparisons, and STRING-EQUAL\nfor case-ignoring string comparisons.\n\nA common mistake when using SEARCH on strings is to provide STRING= or STRING-\nEQUAL as the :TEST function. The :TEST function is given two sequence elements\nto compare. If the sequences are strings, the :TEST function is called on two\ncharacters, so the correct tests are CHAR= or CHAR-EQUAL. If you use STRING=\nor STRING-EQUAL, the result is what you expect, but in some Lisp\nimplementations it's much slower. CCL (at least as of 8/2008) creates a one-\ncharacter string upon each comparison, for example, which is very expensive.\n\nAlso, you should use :START and :END arguments to STRING= or STRING-EQUAL\ninstead of using SUBSEQ; e.g. (string-equal (subseq s1 2 6) s2) should instead\nbe (string-equal s1 s2 :start1 2 :end1 6) This is preferable because it does\nnot cons.\n\nYou should use ZEROP, PLUSP, or MINUSP, instead of comparing a value to 0 or\n0.0.\n\nYou must not use exact comparison on floating point numbers, since the vague\nnature of floating point arithmetic can produce little \"errors\" in numeric\nvalue. You should compare absolute values to a threshold.\n\nYou must use = to compare numbers, unless you really mean for 0, 0.0 and -0.0\nto compare unequal, in which case you should use EQL. Then again, you must not\nusually use exact comparison on floating point numbers.\n\nMonetary amounts should be using decimal (rational) numbers to avoid the\ncomplexities and rounding errors of floating-point arithmetic. Libraries such\nas wu-decimal may help you; once again, if this library is not satisfactory,\nsee above about Using Libraries and Open-Sourcing Code.\n\n### Iteration\n\nlink \u25b6\n\nUse the appropriate form for iteration.\n\nYou should use simpler forms such as DOLIST or DOTIMES instead of LOOP in\nsimple cases when you're not going to use any of the LOOP facilities such as\nbindings, collection or block return.\n\nUse the WITH clause of LOOP when it will avoid a level of nesting with LET.\nYou may use LET if it makes it clearer to return one of bound variables after\nthe LOOP, rather than use a clumsy FINALLY (RETURN ...) form.\n\nIn the body of a DOTIMES, do not set the iteration variable. (CCL will issue a\ncompiler warning if you do.)\n\nMost systems use unadorned symbols in the current package as LOOP keywords.\nOther systems use actual :keywords from the KEYWORD package as LOOP keywords.\nYou must be consistent with the convention used in your system.\n\n### I/O\n\nlink \u25b6\n\nUse the appropriate I/O functions.\n\nWhen writing a server, code must not send output to the standard streams such\nas *STANDARD-OUTPUT* or *ERROR-OUTPUT*. Instead, code must use the proper\nlogging framework to output messages for debugging. We are running as a\nserver, so there is no console!\n\nCode must not use PRINT-OBJECT to communicate with a user \u2014 PRINT-OBJECT is\nfor debugging purposes only. Modifying any PRINT-OBJECT method must not break\nany public interfaces.\n\nYou should not use a sequence of WRITE-XXX where a single FORMAT string could\nbe used. Using format allows you to parameterize the format control string in\nthe future if the need arises.\n\nYou should use WRITE-CHAR to emit a character rather than WRITE-STRING to emit\na single-character string.\n\nYou should not use (format nil \"~A\" value); you should use PRINC-TO-STRING\ninstead.\n\nYou should use ~<Newline> or ~@<Newline> in format strings to keep them from\nwrapping in 100-column editor windows, or to indent sections or clauses to\nmake them more readable.\n\nYou should not use STRING-UPCASE or STRING-DOWNCASE on format control\nparameters; instead, it should use \"~:@(~A~)\" or \"~(~A~)\".\n\nBe careful when using the FORMAT conditional directive. The parameters are\neasy to forget.\n\nNo parameters, e.g. \"~[Siamese~;Manx~;Persian~] Cat\"\n\n    Take one format argument, which should be an integer. Use it to choose a clause. Clause numbers are zero-based. If the number is out of range, just print nothing. You can provide a default value by putting a \":\" in front of the last \";\". E.g. in \"~[Siamese~;Manx~;Persian~:;Alley~] Cat\", an out-of-range arg prints \"Alley\".\n: parameter, e.g. \"~:[Siamese~;Manx~]\"\n\n    Take one format argument. If it's NIL, use the first clause, otherwise use the second clause.\n@ parameter, e.g. \"~@[Siamese ~a~]\"\n\n    If the next format argument is true, use the choice, but do NOT take the argument. If it's false, take one format argument and print nothing. (Normally the clause uses the format argument.)\n# parameter, e.g. \"~#[ none~; ~s~; ~s and ~s~]\"\n\n    Use the number of arguments to format as the number to choose a clause. The same as no parameters in all other ways. Here's the full hairy example: \"Items: ~#[ none~; ~S~; ~S and ~S~:;~@{~S~^~#[~; and ~:;, ~]~}~].\"\n\n## Optimization\n\n### Avoid Allocation\n\nlink \u25b6\n\nYou should avoid unnecessary allocation of memory.\n\nIn a language with automatic storage management (such as Lisp or Java), the\ncolloquial phrase \"memory leak\" refers to situation where storage that is not\nactually needed nevertheless does not get deallocated, because it is still\nreachable.\n\nYou should be careful that when you create objects, you don't leave them\nreachable after they are no longer needed!\n\nHere's a particular trap-for-the-unwary in Common Lisp. If you make an array\nwith a fill pointer, and put objects in it, and then set the fill pointer back\nto zero, those objects are still reachable as far as Lisp goes (the Common\nLisp spec says that it's still OK to refer to the array entries past the end\nof the fill pointer).\n\nDon't cons (i.e., allocate) unnecessarily. Garbage collection is not magic.\nExcessive allocation is usually a performance problem.\n\n### Unsafe Operations\n\nlink \u25b6\n\nYou must only use faster unsafe operations when there is a clear performance\nneed and you can document why it's correct.\n\nCommon Lisp implementations often provide backdoors to compute some operations\nfaster in an unsafe way. For instance, some libraries provide arithmetic\noperations that are designed to be used with fixnums only, and yield the\ncorrect result faster if provided proper arguments. The downside is that the\nresult of such operations is incorrect in case of overflow, and can have\nundefined behavior when called with anything but fixnums.\n\nMore generally, unsafe operations will yield the correct result faster than\nwould the equivalent safe operation if the arguments satisfy some invariant\nsuch as being of the correct type and small enough; however if the arguments\nfail to satisfy the required invariants, then the operation may have undefined\nbehavior, such as crashing the software, or, which is sometimes worse,\nsilently giving wrong answers. Depending on whether the software is piloting\nan aircraft or other life-critical device, or whether it is accounting for\nlarge amounts money, such undefined behavior can kill or bankrupt people. Yet\nproper speed can sometimes make the difference between software that's\nunusably slow and software that does its job, or between software that is a\nnet loss and software that can yield a profit.\n\nYou must not define or use unsafe operations without both profiling results\nindicating the need for this optimization, and careful documentation\nexplaining why it is safe to use them. Unsafe operations should be restricted\nto internal functions; you should carefully documented how unsafe it is to use\nthese functions with the wrong arguments. You should only use unsafe\noperations inside functions internal to a package and you should document the\nuse of the declarations, since calling the functions with arguments of the\nwrong type can lead to undefined behavior. Use check-type in functions\nexported from a package to sanitize input arguments, so that internal\nfunctions are never passed illegal values.\n\nOn some compilers, new unsafe operations can usually be defined by combining\ntype declarations with an OPTIMIZE declaration that has sufficiently high\nSPEED and low SAFETY. In addition to providing more speed for production code,\nsuch declarations may more helpful than check-type assertions for finding bugs\nat compile-time, on compilers that have type inference. These compilers may\ninterpret those declarations as assertions if you switch to safer and slower\noptimize settings; this is good to locate a dynamic error in your code during\ndevelopment, but is not to be used for production code since it defeats the\npurpose of declarations as a performance trick.\n\n### DYNAMIC-EXTENT\n\nlink \u25b6\n\nYou should only use DYNAMIC-EXTENT where it matters for performance, and you\ncan document why it is correct.\n\nDYNAMIC-EXTENT declarations are a particular case of unsafe operations.\n\nThe purpose of a DYNAMIC-EXTENT declaration is to improve performance by\nreducing garbage collection in cases where it appears to be obvious that an\nobject's lifetime is within the \"dynamic extent\" of a function. That means the\nobject is created at some point after the function is called, and the object\nis always inaccessible after the function exits by any means.\n\nBy declaring a variable or a local function DYNAMIC-EXTENT, the programmer\nasserts to Lisp that any object that is ever a value of that variable or the\nclosure that is the definition of the function has a lifetime within the\ndynamic extent of the (innermost) function that declares the variable.\n\nThe Lisp implementation is then free to use that information to make the\nprogram faster. Typically, Lisp implementations can take advantage of this\nknowledge to stack-allocate:\n\n  * The lists created to store &REST parameters.\n  * Lists, vectors and structures allocated within a function.\n  * Closures.\n\nIf the assertion is wrong, i.e. if the programmer's claim is not true, the\nresults can be catastrophic: Lisp can terminate any time after the function\nreturns, or it can hang forever, or \u2014 worst of all \u2014 it can produce incorrect\nresults without any runtime error!\n\nEven if the assertion is correct, future changes to the function might\nintroduce a violation of the assertion. This increases the danger.\n\nIn most cases, such objects are ephemeral. Modern Lisp implementations use\ngenerational garbage collectors, which are quite efficient under these\ncircumstances.\n\nTherefore, DYNAMIC-EXTENT declarations should be used sparingly. You must only\nuse them if:\n\n  1. There is some good reason to think that the overall effect on performance is noticeable, and\n  2. It is absolutely clear that the assertion is true.\n  3. It is quite unlikely that the code will be changed in ways that cause the declaration to become false.\n\nPoint (1) is a special case of the principle of avoiding premature\noptimization. An optimization like this only matters if such objects are\nallocated at a very high rate, e.g. \"inside an inner loop\".\n\nNote that is relatively easy to ascertain that a function will not escape the\ndynamic extent of the current call frame by analyzing where the function is\ncalled and what other functions it is passed to; therefore, you should\nsomewhat wary of declaring a function DYNAMIC-EXTENT, but this is not a high-\nstress declaration. On the other hand, it is much harder to ascertain that\nnone of the objects ever bound or assigned to that variable and none of their\nsub-objects will escape the dynamic extent of the current call frame, and that\nthey still won't in any future modification of a function. Therefore, you\nshould be extremely wary of declaring a variable DYNAMIC-EXTENT.\n\nIt's usually hard to predict the effect of such optimization on performance.\nWhen writing a function or macro that is part of a library of reusable code,\nthere's no a priori way to know how often the code will run. Ideally, tools\nwould be available to discover the availability and suitability of using such\nan optimization based on running simulations and test cases, but in practice\nthis isn't as easy as it ought to be. It's a tradeoff. If you're very, very\nsure that the assertion is true (that any object bound to the variable and any\nof its sub-objects are only used within the dynamic extent of the specified\nscope), and it's not obvious how much time will be saved and it's not easy to\nmeasure, then it may be better to put in the declaration than to leave it out.\n(Ideally it would be easier to make such measurements than it actually is.)\n\n### REDUCE vs APPLY\n\nlink \u25b6\n\nYou should use REDUCE instead of APPLY where appropriate.\n\nYou should use REDUCE instead of APPLY and a consed-up list, where the\nsemantics of the first operator argument otherwise guarantees the same\nsemantics. Of course, you must use APPLY if it does what you want and REDUCE\ndoesn't. For instance:\n\n    \n    \n    ;; Bad (apply #'+ (mapcar #'acc frobs))\n    \n    \n    ;; Better (reduce #'+ frobs :key #'acc :initial-value 0)\n\nThis is preferable because it does not do extra consing, and does not risk\ngoing beyond CALL-ARGUMENTS-LIMIT on implementations where that limit is\nsmall, which could blow away the stack on long lists (we want to avoid\ngratuitous non-portability in our code).\n\nHowever, you must be careful not to use REDUCE in ways that needlessly\nincrease the complexity class of the computation. For instance, (REDUCE\n'STRCAT ...) is O(n^2) when an appropriate implementation is only O(n).\nMoreover, (REDUCE 'APPEND ...) is also O(n^2) unless you specify :FROM-END T.\nIn such cases, you MUST NOT use REDUCE, and you MUST NOT use (APPLY 'STRCAT\n...) or (APPLY 'APPEND ...) either. Instead you MUST use proper abstractions\nfrom a suitable library (that you may have to contribute to) that properly\nhandles those cases without burdening users with implementation details. See\nfor instance UIOP:REDUCE/STRCAT.\n\n### Avoid NCONC\n\nlink \u25b6\n\nYou should not use NCONC; you should use APPEND instead, or better data\nstructures.\n\nYou should almost never use NCONC. You should use APPEND when you don't depend\non any side-effect. You should use ALEXANDRIA:APPENDF when you need to update\na variable. You should probably not depend on games being played with the CDR\nof the current CONS cell (which some might argue is suggested but not\nguaranteed by the specification); if you do, you must include a prominent\ncomment explaining the use of NCONC; and you should probably reconsider your\ndata representation strategy.\n\nBy extension, you should avoid MAPCAN or the NCONC feature of LOOP. You should\ninstead respectively use ALEXANDRIA:MAPPEND and the APPEND feature of LOOP.\n\nNCONC is very seldom a good idea, since its time complexity class is no better\nthan APPEND, its space complexity class also is no better than APPEND in the\ncommon case where no one else is sharing the side-effected list, and its bug\ncomplexity class is way higher than APPEND.\n\nIf the small performance hit due to APPEND vs. NCONC is a limiting factor in\nyour program, you have a big problem and are probably using the wrong data\nstructure: you should be using sequences with constant-time append (see\nOkasaki's book, and add them to lisp-interface-library), or more simply you\nshould be accumulating data in a tree that will get flattened once in linear\ntime after the accumulation phase is complete.\n\nYou may only use NCONC, MAPCAN or the NCONC feature of LOOP in low-level\nfunctions where performance matters, where the use of lists as a data\nstructure has been vetted because these lists are known to be short, and when\nthe function or expression the result of which are accumulated explicitly\npromises in its contract that it only returns fresh lists (in particular, it\ncan't be a constant quote or backquote expression). Even then, the use of such\nprimitives must be rare, and accompanied by justifying documentation.\n\n## Pitfalls\n\n### #'FUN vs. 'FUN\n\nlink \u25b6\n\nYou should usually refer to a function as #'FUN rather than 'FUN.\n\nThe former, which reads as (FUNCTION FUN), refers to the function object, and\nis lexically scoped. The latter, which reads as (QUOTE FUN), refers to the\nsymbol, which when called uses the global FDEFINITION of the symbol.\n\nWhen using functions that take a functional argument (e.g., MAPCAR, APPLY,\n:TEST and :KEY arguments), you should use the #' to refer to the function, not\njust single quote.\n\nAn exception is when you explicitly want dynamic linking, because you\nanticipate that the global function binding will be updated.\n\nAnother exception is when you explicitly want to access a global function\nbinding, and avoid a possible shadowing lexical binding. This shouldn't happen\noften, as it is usually a bad idea to shadow a function when you will want to\nuse the shadowed function; just use a different name for the lexical function.\n\nYou must consistently use either #'(lambda ...) or (lambda ...) without #'\neverywhere. Unlike the case of #'symbol vs 'symbol, it is only a syntactic\ndifference with no semantic impact, except that the former works on Genera and\nthe latter doesn't. You must use the former style if your code is intended as\na library with maximal compatibility to all Common Lisp implementations;\notherwise, it is optional which style you use. #' may be seen as a hint that\nyou're introducing a function in expression context; but the lambda itself is\nusually sufficient hint, and concision is good. Choose wisely, but above all,\nconsistently with yourself and other developers, within a same file, package,\nsystem, project, etc.\n\nNote that if you start writing a new system in a heavily functional style, you\nmay consider using lambda-reader, a system that lets you use the unicode\ncharacter \u03bb instead of LAMBDA. But you must not start using such a syntactic\nextension in an existing system without getting permission from other\ndevelopers.\n\n### Pathnames\n\nlink \u25b6\n\nCommon Lisp pathnames are tricky. Be aware of pitfalls. Use UIOP.\n\nIt is surprisingly hard to properly deal with pathnames in Common Lisp.\n\nASDF 3 comes with a portability library UIOP that makes it much easier to deal\nwith pathnames portably \u2014 and correctly \u2014 in Common Lisp. You should use it\nwhen appropriate.\n\nFirst, be aware of the discrepancies between the syntax of Common Lisp\npathnames, which depends on which implementation and operating system you are\nusing, and the native syntax of pathnames on your operating system. The Lisp\nsyntax may involves quoting of special characters such as #\\\\. and #\\\\*, etc.,\nin addition to the quoting of #\\\\\\ and #\\\" within strings. By contrast, your\noperating system's other system programming languages (shell, C, scripting\nlanguages) may only have one layer of quoting, into strings.\n\nSecond, when using MERGE-PATHNAMES, be wary of the treatment of the HOST\ncomponent, which matters a lot on non-Unix platforms (and even on some Unix\nimplementations). You probably should be using UIOP:MERGE-PATHNAMES* or\nUIOP:SUBPATHNAME instead of MERGE-PATHNAMES, especially if your expectations\nfor relative pathnames are informed by the way they work in Unix or Windows;\notherwise you might hit weird bugs whereby on some implementations, merging a\nrelative pathnames with an absolute pathname results in overriding the\nabsolute pathname's host and replace it with the host from the value of\n*DEFAULT-PATHNAME-DEFAULTS* at the time the relative pathname was created.\n\nThird, be aware that DIRECTORY is not portable across implementations in how\nit handles wildcards, sub-directories, symlinks, etc. There again, UIOP\nprovides several common abstractions to deal with pathnames, but only does so\ngood a job. For a complete portable solution, use IOLib \u2014 though its Windows\nsupport lags behind.\n\nLOGICAL-PATHNAMEs are not a portable abstraction, and should not be used in\nportable code. Many implementations have bugs in them, when they are supported\nat all. SBCL implements them very well, but strictly enforces the limitations\non characters allowed by the standard, which restricts their applicability.\nOther implementations allow arbitrary characters in such pathnames, but in\ndoing so are not being conformant, and are still incompatible with each other\nin many ways. You should use other pathname abstractions, such as ASDF:SYSTEM-\nRELATIVE-PATHNAME or the underlying UIOP:SUBPATHNAME and UIOP:PARSE-UNIX-\nNAMESTRING.\n\nFinally, be aware that paths may change between the time you build the Lisp\nimage for your application, and the time you run the application from its\nimage. You should be careful to reset your image to forget irrelevant build-\ntime paths and reinitialize any search path from current environment\nvariables. ASDF for instance requires you to reset its paths with UIOP:CLEAR-\nCONFIGURATION. UIOP provides hooks to call functions before an image is\ndumped, from which to reset or makunbound relevant variables.\n\n### SATISFIES\n\nlink \u25b6\n\nYou must be careful when using a SATISFIES clause in a type specifier.\n\nMost Common Lisp implementations can't optimize based on a SATISFIES type, but\nmany of them offer simple optimizations based on a type of the form (AND FOO\n(SATISFIES BAR-P)) where the first term of the AND clause describes the\nstructure of the object without any SATISFIES and the second term is the\nSATISFIES.\n\n    \n    \n    (deftype prime-number () (satisfies prime-number-p)) ; Bad\n    \n    \n    (deftype prime-number () (and integer (satisfies prime-number-p)) ; Better\n\nHowever, AND in the DEFTYPE language isn't a left-to-right short-circuit\noperator as in the expression language; it is a symmetrical connector that\nallows for reordering subterms and doesn't guarantee short-circuiting.\nTherefore, in the above example, you cannot rely on the test for INTEGERness\nto protect the function PRIME-NUMBER-P from being supplied non-integer\narguments to test for being of instances of the type. Implementations may, and\nsome will, invoke SATISFIES-specified function at compile-time to test various\nrelevant objects.\n\nThat is why any function specified in a SATISFIES clause MUST accept objects\nof any type as argument to the function, and MUST be defined within an EVAL-\nWHEN (as well as any variable it uses or function it calls):\n\n    \n    \n    (defun prime-number-p (n) ; Doubly bad! (let ((m (abs n))) (if (<= m *prime-number-cutoff*) (small-prime-number-p m) (big-prime-number-p m))))\n    \n    \n    (eval-when (:compile-toplevel :load-toplevel :execute) ; Better (defun prime-number-p (n) (when (integerp n) ; Better (let ((m (abs n))) (if (<= m *prime-number-cutoff*) (small-prime-number-p m) (big-prime-number-p m))))))\n\nIn particular, the above means that the example used in the Common Lisp\nStandard is erroneous: (and integer (satisfies evenp)) is not a safe,\nconformant type specifier to use, because EVENP will throw an error rather\nthan return NIL when passed a non-integer as an argument.\n\nFinally, there is a catch when your DEFTYPE code expands to a SATISFIES with a\ndynamically generated function:\n\n  * You cannot control when implementations will or will not expand a DEFTYPE.\n  * The expansion itself cannot contain a function definition or any code in the expression language.\n  * You cannot control when the expansion is used, it may happen in a different process that didn't expand the definition.\n\nTherefore, you cannot merely create the function as a side-effect of expansion\nusing EVAL at type-expansion time. The solution is to use ASDF-\nFINALIZERS:EVAL-AT-TOPLEVEL instead. See the very last point in the discussion\nabout EVAL.\n\nCommon Lisp is hard to satisfy.\n\nCredits: Adam Worrall, Dan Pierson, Matt Marjanovic, Matt Reklaitis, Paul\nWeiss, Scott McKay, Sundar Narasimhan, and several other people contributed.\nSpecial thanks to Steve Hain, and to the previous editors, in reverse\nchronological order Dan Weinreb and Jeremy Brown.\n\nRevision 1.28\n\nRobert Brown Fran\u00e7ois-Ren\u00e9 Rideau\n\n", "frontpage": true}
