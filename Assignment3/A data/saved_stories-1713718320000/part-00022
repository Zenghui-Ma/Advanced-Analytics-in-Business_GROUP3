{"aid": "40103673", "title": "Learning Assembly \u2013 1.0", "url": "https://hcrypt.net/2024/04/21/Learning-Assembly-1.0/", "domain": "hcrypt.net", "votes": 1, "user": "udev4096", "posted_at": "2024-04-21 06:51:42", "comments": 0, "source_title": "Learning assembly - 1.0", "source_text": "Learning assembly - 1.0 \u00b7 Hcrypt\n\n### Hcrypt\n\n# Learning assembly - 1.0\n\nI wanted to learn assembly a while back but for some reason I left it halfway,\nwithout fully understanding it. I am going to give it another shot and\ndocument my journey in a series of blog posts. Mostly, I will be following\nthis fine book by Ray Sefarth which is Introduction to 64 bit Intel Assembly\nLanguage Programming in Linux and some other experimentations of my own along\nthe way.\n\n### What\u2019s the point of even learning it?\n\n> A skilled assembly language coder can write code which uses less CPU time\n> and less memory than that produced by a compiler. However modern C and C++\n> compilers do excellent optimization and beginning assembly programmers are\n> no match for a good compiler.\n\nI think, and it\u2019s completely my own opinion, it\u2019s the best way to understand\nhow computers work at a deeper level. C comes very close to that but it\u2019s\nstill considered a higher level language.\n\nSome of the other things that I think you can benefit from are:\n\n  * optimize the program to run faster and more efficiently\n  * reduce the size of the binary\n  * can be helpful in reverse engineering\n\nAlright, now let\u2019s get started.\n\n## First program (does nothing, kinda)\n\n    \n    \n    segment .text global _start _start: mov eax, 1 ; 1 is the exit syscall number mov ebx, 5 ; the status value to return int 0x80 ; generates a software interrupt numbered Ox80 which is the way linux handles 32 bit system calls\n\nNote: This program just returns a non zero exit status code.\n\nSo, what\u2019s going on here? What the hell is even eax and ebx? Those are\nregisters. At a high level, they are used to store temporary data for the CPU.\n\nsegment indicates that the data or instructions following it are to be placed\nin the .text segment or section. In Linux this is where the instructions of a\nprogram are located.\n\nglobal _start acts like a main function of a C program. It specifies the entry\npoint of our assembly program.\n\nint 0x80 is basically used to perform syscall to the kernel. It will perform\nall the above operations and return back to the user.\n\n## Executing it\n\nHow do we compile and run it? We will use an assembler for that and what it\ndoes is produce an object file which generates instructions and data in a form\nready to link with other code from other object files or libraries.\n\nWe will use yasm assembler.\n\n    \n    \n    yasm -f elf64 -g dwarf2 -l first.lst first.asm\n\n  * elf64 will generate a linux compatible executable file.\n  * dwarf2 is a debugging format\n  * first.lst is a listing file which contains the code in hexadecimal_\n\nYou will get 2 files, an object file and a list file.\n\nNow, to make an executable file we will use ld.\n\n    \n    \n    ld -o first first.o\n\nYou should get the executable file. After running it, check the status code of\nthe execution.\n\n    \n    \n    echo $?\n\nIt should return 5, because that\u2019s what we have in the ebx register.\n\n## Exercise time\n\nI think these questions are interesting and will be easy to solve. (these are\ntaken from the book)\n\nQ-1. Enter the assembly language program from this chapter and assemble and\nlink it. Then execute the program and enter echo $?. A non-zero status\nindicates an error. Change the program to yield a 0 status.\n\nWe did most of it above. Now to change the return status, we can simply change\nthe constant value to 0. After assembling and linking it, you should get 0\nwhen you run echo $?.\n\nQ-2 Modify the assembly program to define main rather than _start. Assemble it\nand link it using gcc. What is the difference in size of the executables?\n\nLet\u2019s change it. First, we will look at the previous size of the binary that\nwe got.\n\nIt\u2019s 5.1K. Alright, now let\u2019s compile it with gcc by replacing _start with\nmain. Assemble it with yasm and then run:\n\n    \n    \n    gcc -o first first.o\n\nWhat\u2019s the size?\n\n16K! That\u2019s almost 3x more. Massive increase.\n\nThis would be the end of the first part. I will try to be consistent and keep\nposting several more of these. Thank you for sticking till the end.\n\nKeep experimenting!\n\n", "frontpage": false}
