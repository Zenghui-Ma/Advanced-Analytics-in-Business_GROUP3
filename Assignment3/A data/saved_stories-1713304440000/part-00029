{"aid": "40052684", "title": "Show HN: Device-Bound Session Tokens in JavaScript", "url": "https://session-lock.keyri.com/", "domain": "keyri.com", "votes": 4, "user": "thekeyper", "posted_at": "2024-04-16 14:48:38", "comments": 0, "source_title": "session-lock - Home", "source_text": "session-lock - Home\n\nsession-lock is a device-token binding scheme and JS library that reduces the\nrisk of session hijacking / token replay attacks by binding the validity of a\nuser's session token to their browser or device.\n\nThe library can be used with both JWTs and serialized cookies, though working\nwith JWTs is easier with this library thanks to JWTs' ability to store data\nwithin their payloads. The general concept and flow can be implemented in\nmobile apps using CryptoKit and KeyStore.\n\n# Background\n\nRegardless of how strong a service's authentication mechanisms may be, if an\nattacker steals a user's session token, they can access protected resources\nbelonging to the user much like they would if they had access to the user's\nauthentication credentials. With the use of OS-level malware, malicious\nbrowser extensions, or traffic sniffing, an attacker can steal users' session\ntokens directly from their browsers or from the network, then use those tokens\nto authorize their own sessions.\n\nBelow is a manual demonstration of how session hijacking works. We're taking\nthe the token from a logged-in session and using it on another browser. A bad\nactor would do this programmatically with a browser extension or malware, but\nthe principle is the same.\n\nExisting RFCs have attempted to address the token hijacking threat. A draft\nRFC for demonstrating proof-of-possession (DPoP) proposes a similar mechanism\nto session-lock, but it is primarily applicable to OAuth systems and may be\ncomplex to implement. Google Chrome's Device Bound Session Credentials (DBSC)\nproposal is promising, though cross-browser support and compatibility with\nnative mobile apps remains unclear at this time.\n\n# Try session-lock\n\nsession-lock can be demonstrated on this site here. Try to take the JWT from\nLocalStorage and re-use it in another browser or another tab. You will see\nthat the JWT is rejected. This is because the JWT is bound to the browser in\nwhich it was issued.\n\nThe demo showcases a Next.js app using the session-lock library to secure a\nprotected route, accessible only to users with a valid session-lock token.\n\n# Try session-lock in your own project\n\nsession-lock is available for web and Node.js applications as a proof-of-\nconcept library through npm. Source code and documentation for the library and\nthe demo site can be found on GitHub.\n\n# How session-lock works\n\nA regular JWT: {header}.{payload}.{server sig}\n\nA session-lock token: {header}.{payload w/ client pubKey}.{server\nsig}.{timestamp}.{client sig}\n\nNote: S-L in the diagram below stands for session-lock. This diagram is JWT-\nspecific in terms of where the client public key is stored and how it's\nretrieved, but the same principles apply to serial session tokens / cookies as\nwell. In summary, whereas regular JWTs include a signature generated by the\nissuing server, session-lock adds a signature generated by the client to which\nit was issued, with a timestamp added to the mix to make the signature\nresistant to replay. The client signature is made reliable with the use of\nunextractable private keys stored in the browser's IndexedDB. The same\ntimestamp+signature can be applied to serialized session tokens / cookies,\nwith the difference being that the client public key is stored in a cookie\nstore on the server rather than embedded within the token itself.\n\nThe system may be vulnerable to client-side javascript tampering as well as\nsomehow extracting \"unextractable\" SubtleCrypto private keys, but it should\nprovide a strong layer of protection against less sophisticated attacks.\n\nUpdated April 12, 2024\n\n", "frontpage": false}
