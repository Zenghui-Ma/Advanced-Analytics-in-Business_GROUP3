{"aid": "40052729", "title": "Launching Distributed Authorization", "url": "https://www.osohq.com/post/distributed-authorization", "domain": "osohq.com", "votes": 18, "user": "AnhTho_FR", "posted_at": "2024-04-16 14:51:48", "comments": 4, "source_title": "Distributed Authorization", "source_text": "Distributed Authorization\n\nTry Oso\n\nMeet an Eng\n\nProduct\n\nApril 16, 2024\n\n# Authorization is still a nightmare for engineers: Launching Distributed\nAuthorization\n\nGreg Sarjeant\n\n> \u201cThe ability to do authorization queries over data in our existing database\n> reduces architectural complexity and is a big technical win for us. We\u2019re\n> super excited to take advantage of it.\u201d \u2013 Anthony Cristiano, Staff Software\n> Engineer, Headway\n\nAuthorization as a Service. The reality falls short of the promise. That\u2019s\nbecause to use an authorization service, you have to send it a lot of\napplication data. Any solution that signs you up for a data synchronization\nprocess isn\u2019t providing a service. It\u2019s creating a burden.\n\nWhen we started work on Oso, we knew this. It\u2019s one of the key problems we set\nout to solve. Today we\u2019re taking a major step towards realizing that vision\nwith the release of Distributed Authorization.\n\nDistributed Authorization lets you apply your application data to\nauthorization decisions without synchronizing it to Oso Cloud. Instead, you\ndistribute authorization decisions between the Oso Cloud service and the Oso\nCloud client in your application.\n\nThis may sound counterintuitive \u2013 shouldn\u2019t an authorization service answer\nauthorization questions on its own? Surprisingly, no.\n\nIn this post, we\u2019ll show you how we reached that conclusion and why we\u2019re so\nexcited about Distributed Authorization.\n\n## DIY Authorization: Good until it Isn\u2019t\n\nAuthorization starts with a question. Consider gitcloud, our sample version\ncontrol app. You may be asked this question: May aliceview the amazing-app\nrepository? In order to answer this question you need two things: logic and\ndata. The logic might be:\n\nUsers can view repositories in their organization if they have the\n\u201cmaintainer\u201d or \u201cadmin\u201d role on that repository\n\nThe data might be be:\n\n  * alice is a member of the acme organization.\n  * the acme organization contains the amazing-app repository\n  * alice has the maintainer role on the amazing-app repository\n\nBy combining the logic and the data, we get our answer: alice can view the\namazing-app repository.\n\nIn the early stages of an application, this logic usually lives in the\napplication code, and the data in the application database. For the case of\nour simple question above, that might look like this:\n\n    \n    \n    // Get this user's roles on the repo const userRoles = db.getUserRoles({ userId: user.id, repoId: issue.repoId}); // Check whether the user has a role that confers view access if(!userRoles.some((r) => [\"maintainer\", \"admin\"].includes(r)) { throw new PermissionDeniedRoleRequired(\"maintainer\"); }\n    \n    \n    # SQL for getting the repository roles for a user. select \"role\" from repository_role rr join repository r on rr.repo_id = r.id join organization_member om on r.org_id = om.org_id where om.user_id = ? and r.id = ?\n\nIf your authorization logic isn\u2019t much more complicated than that, this works\njust fine. But over time, authorization questions and logic both tend to\nbecome more complex.\n\n  * It becomes cumbersome to manage roles at the repository level, so you allow users to inherit roles on repositories from their role in the organization.\n  * You start getting a lot of requests to add new roles to gitcloud, so you give users the ability to create custom roles with configurable permission\n  * You add an Issue feature to gitcloud, so repo users have a way to report bugs.\n\nGreat news \u2013 your Issue feature is taking off! In fact, it\u2019s so popular that\nyour users request a list of Issues that they have permission to triage,\nbecause it\u2019s getting hard to keep track of them. You decide that a user can\ntriage an issue if:\n\n  * They created the issue or\n  * They have the triagerole on the repository that contains the issue or\n  * They have the triagerole on the organization that contains the repositoryor\n  * They have a custom role that grants them the necessary permissions\n\nThis looks something like this:\n\nSample code left as an exercise for the reader.\n\nGood luck sifting through that code 6 months from now when you want to figure\nout the rules for granting triage access to a user.\n\n## Policy As Code: Decouple Authorization Logic From Application Logic\n\nYour application has an authorization policy, whether you build it explicitly\nor not. When you mix application logic and authorization logic in your\napplication code, you make that policy implicit. The problem with things that\nare implicit is that they\u2019re easy to misunderstand, or to miss entirely.\nSuppose you decide to add teams to gitcloud, so different teams in an\norganization can have different permissions. Will you be able to find all the\nfunctions and queries you need to modify in order to make teams work properly?\nDo you want to have to do that?\n\nThis is why we introduced Polar, our declarative DSL for authorization. Polar\nallows you to separate your authorization logic from your application logic\nand express it in a language that is purpose built for authorization. A simple\nPolar policy looks something like this:\n\n    \n    \n    allow(user: User, \"read\", org: Organization) if has_role(user, \"member\", org); has_role(User{\"alice\"}, \"member\", Organization{\"acme\"});\n\nWe\u2019ve specified the entities we\u2019re interested in: User and Organization. We\u2019ve\ndefined the conditions that allow a given User to view an Organization, in\nterms of the member role. Finally, we\u2019ve asserted that alice has the member\nrole on the acme organization.\n\nLike any new language, it takes a little getting used to if you haven\u2019t worked\nwith Polar before, but we can see from this example that it\u2019s both concise and\nexpressive. These are important characteristics if our aim is to make your\nauthorization logic explicit. If you had to wade through a bunch of confusing\nsyntax to divine that logic, we would have done a lot of work for nothing.\n\nExplicit policy is a big improvement for complex authorization logic. Now we\nneeded to let you take advantage of that policy in your code. This is why we\nbuilt the Oso library.\n\n## Oso Library: Authorization for Monoliths\n\nThe Oso library represented our initial implementation of a client to Polar.\nThere was a lot to like about it. It was open source. It operated directly\nover your data. It integrated tightly with your application. With your policy\ndefined in Polar and the open source library embedded in your application, you\ncould find out whether alice can view the awesome-app repository like this:\n\n    \n    \n    @app.route(\"/repo/<name>\") def repo_show(name): repo = Repository.get_by_name(name) try: oso.authorize(User.get_current_user(), \"read\", repo) return f\"<h1>A Repo</h1><p>Welcome to repo {repo.name}</p>\", 200 except NotFoundError: return f\"<h1>Whoops!</h1><p>Repo named {name} was not found</p>\", 404\n\nThe beauty of this was that as your authorization logic gets more complicated,\nthe application code stayed just this simple. You expressed the authorization\nlogic in a .polar file, where you could version and inspect it alongside your\napplication code. When you needed to ask if a given user was authorized to\nperform a given action, you always asked the same question, in exactly those\nterms:\n\n    \n    \n    oso.authorize(<User>, <action>, <resource>)\n\nAs powerful as this was, over time we learned that the library approach has\nsome significant downsides.\n\nThe library got access to application data via a foreign function interface\n(FFI). This was clever (and fun) engineering, but the mental model tripped up\na lot of developers, and made things hard to debug.\n\nThere was no standard data model. This was part of the point \u2013 we built the\nlibrary to operate over your data. As convenient as it was to have direct\naccess to that data, in practice we observed performance issues and\ninconsistent behavior caused by details of the underlying data model that we\ncould neither see nor change ourselves. This lack of standardization also made\nit hard for us to build new capabilities on top of the library.\n\nBut the main problem was this: the library was a great solution if you have a\nsingle service. A lot of people, however, have more than one service! For\nthese people, the library approach only solved a piece of the puzzle.\n\n## Oso Cloud: Authorization for Microservices\n\nWhen your application is a monolith, it\u2019s straightforward to implement your\nauthorization logic with something like the Oso library. You write your logic\nin a .polar file that lives in the same repository as all the rest of your\ncode. Then you load it when you initialize the client. Finally, you issue\nauthorization requests against the loaded policy. You don\u2019t have to worry\nabout data, because it\u2019s all in a single database that all your code can\naccess.\n\nBut when you break your application up into multiple services, you introduce\nnew questions. Which service should own the authorization model? There\u2019s no\ngood answer, because the model needs data to be effective, and that data is\nnow split across services. Can each service have its own model? No, because\nauthorization questions often span services. Let\u2019s go back to deciding whether\nalice can triage an Issue.\n\nThe Issue service knows whether alice created the issue. The Repository\nservice knows whether alice has the triage role on the repository, and the\nUser service knows whether alice has the triage role on the organization. So\nnow you\u2019re making multiple API calls to figure out whether alice can triage\nthe issue.\n\nThe design that ends up making the most sense is to have a dedicated service\nfor authorization, but now you have to build your own APIs, create your own\ndata model, figure out how to design change control. It\u2019s a lot of work.\n\nSo our next step was to take that work on. We designed Oso Cloud to solve\nauthorization in multi-service environments. This let us address two\npersistent issues in the library model:\n\n  * We built a hosted solution that could be shared by all services in an application.\n  * We defined a consistent data model for authorization data.\n\nThe Oso Cloud data model is called facts. Facts are a lightweight, flexible\nformat that can represent any authorization data in your application.\n\nOso Cloud brings the benefits of policy as code to multi-service applications.\nYou can make your authorization logic explicit, share it amongst all of your\nservices, and represent your authorization data in a standard format that\u2019s\noptimized for authorization operations. But now we\u2019ve recreated exactly the\nproblem we set out to solve: you have to sync your application data to our\nservice.\n\n## Authorization as a Service: Excessive Centralization\n\nLet\u2019s take a look back at why we started down this road. Our application got\nbrittle because the application logic and the authorization logic were\nintertwined. We wanted to make authorization logic explicit, and in order to\ndo that in a way that worked for microservices, we created a hosted service\nthat provides the benefits of Polar behind an API.\n\nTo answer authorization questions, we need more than logic. We also need data.\nAnd in that respect, Oso Cloud suffers from the same limitation that all\ncentralized authorization services do. It needs that data to exist in the\nservice.\n\nBut that\u2019s our problem, not yours. You already have that data where you need\nit: in your application. By requiring you to convert it to facts and\nsynchronize it to Oso Cloud, we\u2019re making our lives easier at the cost of\nmaking yours harder. Now you have to deal with potentially massive initial\ndata loads, distributed transactions, sync and replication processes,\ndetecting drift. None of this is easy.\n\nWe know it\u2019s not easy, because you\u2019ve told us it isn\u2019t. The good news is that\nthis was never the end state for us.\n\n## Distributed Authorization: Microservices done right\n\nWhat we really want to do is let you centralize your authorization logic\nwithout centralizing all of your authorization data. To do this, we have to\nlet go of a fundamental assumption of Authorization as a Service: that the\nservice has to answer the question independently. It\u2019s this requirement that\nmakes it necessary for the authorization service to have all of your\napplication data.\n\nWhat if, instead, you could centralize your logic and your common\nauthorization data (things like roles) in the authorization service, and then\ndistribute the evaluation of authorization questions between the server and\nthe client? That\u2019s Distributed Authorization. Instead of only answering yes or\nno, Oso Cloud can now respond to an authorization question with yes, if.\n\nThat yes, if is followed by a list of conditions that are evaluated at the\nclient using your local data. You give the Oso Cloud client a configuration\nfile that tells it how to test those conditions by converting your application\ndata to facts. At authorization time, the Oso Cloud service evaluates as much\nof the request as it knows, and then hands off the remainder to the Oso Cloud\nclient in your application.\n\n## A Practical Application: Filtering Lists\n\nOne area where this shines is filtering lists of authorized data. We\u2019ve\nalready talked about how painful it can be to get your application data into a\ncentralized authorization service. It can also be painful to get it back out.\nIf you want to generate a list of Issues that alice can triage and all of your\ndata is centralized in your authorization service, then the operation looks\nlike this:\n\n  * Ask the service for a list of Issue IDs that alice can triage\n  * Get the full list of IDs back from the service\n  * Use the list of IDs to query your local database for Issue data\n\nThis is how the oso.list command works, and it works great in a lot of cases.\n\nFor users who belong to multiple organizations, or who belong to organizations\nwith very active repositories, that list of Issues can get very long! It's not\nhard to envision situations where a user has access to hundreds or thousands\nof issues. That\u2019s a lot of data going across the internet before you\u2019re able\nto use it in your application.\n\nOso Cloud now supports List Filtering using Distributed Data. When you use\nlocal data to generate lists of authorized resources, rather than returning\nthe full list of resources, Oso Cloud instead returns a (much shorter) query\nfilter to the client. The client then uses this filter to construct the full\nlist from your locally stored data. You get your response back from Oso\nfaster, and because you generate the list in your local database, you can sort\nand paginate the results using the tools you're already using to handle large\nsets of application data.\n\n## Bringing our Vision into Focus\n\n> \u201cOur team was looking for a new authorization system. We assessed a number\n> of technologies (plus building our own) and Oso's distributed architecture,\n> in-depth auth knowledge, and 99.99% uptime were key reasons why we chose\n> Oso.\u201d \u2013 Guhan Venguswamy, Head of Platform Engineering, Jasper.ai\n\nWith Distributed Authorization, you get the the benefits of explicit\nauthorization logic without the penalty of centralizing all your authorization\ndata. It\u2019s Authorization as a Service that works with your application, rather\nthan forcing you to rework your application to work with it.\n\nThis is a major milestone for us, but we know the job\u2019s not done. We\u2019re\ncontinuing to make it easier for you to centralize the data that you do want\nto keep in Oso Cloud. We\u2019re enhancing Polar to make it even more flexible and\nrobust. And we haven\u2019t forgotten about monoliths \u2013 although the Oso library is\nnow deprecated, we\u2019re working on bringing these capabilities to you too!\n\nIn the coming weeks, we\u2019ll be sharing more on how Distributed Authorization\nworks under the hood, and the different ways customers like Headway and\nJasper.ai are already using it.\n\nIf you\u2019d like to learn more about how to use it in your app, check our our\ndocs for Distributed Authorization and List Filtering.\n\nDo you have questions or want to share your thoughts? Reach out to us on Slack\nor Schedule a 1x1 with an Engineer! We\u2019d love to talk with you.\n\n##### Want us to remind you?\n\nGreat decision!\n\nOops! That's...not a valid email :-/\n\nWe'll email you before the event with a friendly reminder.\n\n##### Implement authorization with Oso\n\nLearn about Oso\n\n### Write your first policy\n\nTry Oso Cloud\n\nRead the docs\n\n###### Product\n\nDocumentationUse casesPricingSecurityChangelogStatusPrivacy Policy\n\n###### Learn\n\nAuthorization AcademyWhat is Google Zanzibar?What is Open Policy Agent\n(OPA)?Authorization as a ServiceAuthorization FAQWhat is Attribute Based\nAccess Control (ABAC)?\n\n###### How-to\n\nRole-Based Access Control in PythonRole-Based Access Control in Node.jsRole-\nBased Access Control in GoDebugTestPolar Syntax\n\n\u00a9 2024 Oso Security, Inc.\n\n", "frontpage": true}
