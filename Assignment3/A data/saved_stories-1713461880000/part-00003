{"aid": "40074869", "title": "Open Sourcing a Python Project the Right Way in 2024", "url": "https://jonathanadly.com/open-sourcing-a-python-project-the-right-way-in-2024", "domain": "jonathanadly.com", "votes": 1, "user": "jonathan-adly", "posted_at": "2024-04-18 10:54:25", "comments": 0, "source_title": "Open Sourcing a Python Project the Right Way in 2024", "source_text": "Open Sourcing a Python Project the Right Way in 2024\n\n#\n\nJonathan's blog\n\n# Jonathan's blog\n\n# Open Sourcing a Python Project the Right Way in 2024\n\nJonathan Adly\n\n\u00b7Apr 18, 2024\u00b7\n\n11 min read\n\nEvery Python developer I've talked to has written some code that others would\nfind useful. At the same time, they've all spent days, if not longer,\nwrestling with the tooling and packaging that comes with the language. My aim\nwith this article is to simplify the process of open-sourcing your Python code\nas much as possible. By the time you finish reading, you'll know how to take\nyour existing code base and turn it into an open source project that's easy to\nuse and contribute to.\n\nThis was inspired by:\n\n  * Trying to open-source my package AgentRun and struggling for a few days with Python tooling\n\n  * Jeff Knupp excellent article on how to open source a Python project hitting the 10+ year mark and needing an update\n\n  * Simon Willison updated cookiecutter tool python-lib that did most of the heavy lifting with the pain of automating the publishing process to PyPI.\n\n# Tools and Concepts\n\nWhen you're gearing up to open source a Python project, there are a handful of\ntools and concepts that really come in handy. I'm going to walk you through\nsome of the essentials that I've found invaluable. Keep in mind, my\nrecommendations are based on personal experience, so they might be a bit\nsubjective.\n\nLet's break it down:\n\n  * Project Layout: How to structure your files.\n\n  * The pyproject.toml File: This is crucial for project settings.\n\n  * Pytest: For all your testing needs.\n\n  * GitHub Actions: Automate workflows directly from your GitHub repository.\n\n  * MkDocs: For awesome documentation.\n\n  * PyPI Trusted Publishing: Get your package out there easily.\n\n  * Cookiecutter: A lifesaver for starting projects quickly.\n\n  * Recipe: Step-by-step guide to get you rolling.\n\nIf you're already familiar with these tools, feel free to jump straight to the\nRecipe section where you can follow the practical steps to get your project\nlive.\n\n# Project Layout\n\nWhen you're open sourcing a Python project, the way you organize your project\nlayout is crucial. It's often the first thing potential contributors or users\nnotice. A cluttered or confusing structure can be overwhelming for newcomers,\nso it's essential to get it right from the start.\n\nEvery project should include at least three key directories:\n\n  1. A docs directory for all your project documentation.\n\n  2. A directory named after your project where the actual Python package lives.\n\n  3. A tests directory to hold all your test files.\n\nOn top of these, you'll typically have several important top-level files like\nLICENSE, README.md, and possibly a few others. However, it's wise to keep the\nnumber of top-level files to a minimum. To give you a clearer picture, here's\na simplified snapshot of the layout for one of my projects, AgentRun.\n\n    \n    \n    \u251c\u2500\u2500 .github \u2502 \u2514\u2500\u2500 workflows \u2502 \u251c\u2500\u2500 publish.yml \u2502 \u2514\u2500\u2500 test.yml \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 agentrun \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 agentrun-api \u251c\u2500\u2500 docs \u251c\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 pyproject.toml \u2514\u2500\u2500 tests \u2514\u2500\u2500 test_agentrun.py\n\n# The pyproject.toml File\n\nThe pyproject.toml file is a configuration file for Python projects,\nstandardized by PEP 518. It specifies build system requirements and can be\nused to configure tools like black, isort, and pytest and many others. This\nfile is crucial for modern Python packaging and dependency management.\n\nIn the context of open-sourcing a Python package, pyproject.toml plays several\nroles:\n\n  1. Dependency Specification: It declares build dependencies required to compile your package from source. This ensures that anyone trying to build your package from the source will have the right tools installed automatically.\n\n  2. Package Metadata: It can include metadata about your package such as name, version, authors, and more. This information is essential for package distribution and maintenance.\n\n  3. Tool Configuration: It allows you to configure various tools used during development in a single, standardized file. For example, settings for formatters, linters, and test frameworks can be specified here, ensuring consistency across environments.\n\n  4. Build System Declaration: It declares which build backend (like setuptools, flit, or poetry) is used to build your package. This is crucial for reproducibility and compatibility in different environments.\n\nThe difficult thing about this part is that you have many options and\nconfigurations you can choose from. In the beginning I recommend to keep it\nsimple and gradually add more tools as you are get more comfortable.\n\nHere is a minimal pyproject.toml similar to the one generated by python-lib\nthat I recommend to start with.\n\n    \n    \n    [project] name = \"Your project name\" version = \"0.1\" description = \"Your project description\" readme = \"README.md\" requires-python = \">=3.8\" authors = [{name = \"your name\"}] license = {text = \"the license choosen from the project\"} classifiers = [ \"License :: OSI Approved :: {{ the license name }} \" ] dependencies = [] [build-system] requires = [\"setuptools\"] build-backend = \"setuptools.build_meta\" [project.urls] Homepage = \"your github repo page\" [project.optional-dependencies] test = [\"pytest\", \"mkdocs\"]\n\nThis pyproject.toml file doesn't have any dependencies and only pytest and\nmkdocs for the test version of the package. So, this is just a starting point\nand would need to be adjusted depending on your own project needs.\n\n# Pytest\n\nWhen publishing an open-source package, it's good to include some tests. This\nnot only invites contributors to your project but also reassures users about\nthe reliability of your package. Without tests, there's a risk that\ncontributors might unintentionally break existing features, and potential\nusers might hesitate to depend on your software.\n\nPytest is one of the most popular Python testing framework and I recommend\nstarting from the beginning with it.\n\nLet's imagine you have a package that simply increments a number by 1. Here is\nthe code in your package/__init__.py :\n\n    \n    \n    def inc(x): return x + 1\n\nThen under your tests/ directory. You should have a file test_inc.py that uses\nPytest to test your code.\n\n    \n    \n    from package import inc def test_inc(): assert inc(3) == 4\n\nTo run your tests, simply type pytest in the terminal. Pytest will execute all\nyour tests and report back whether they passed or failed. This immediate\nfeedback loop is invaluable for maintaining a robust codebase.\n\n# Github Actions\n\nWhen you're planning to share and collaborate on a project, having a solid\nCI/CD setup is important. Continuous integration (CI) refers to the practice\nof automatically integrating and testing code changes into a shared source\ncode repository without breaking anything. Continuous Delivery, automates the\nrelease of validated code to a repository following the tests that happen in\nCI.\n\nAt a minimum, you want your code tested automatically every time someone\npushes a new change. There are many vendors and tools that can do that, but I\nlike Github Actions. Github is by far the most popular platform to store and\nshare code and having native CI/CD in the same place as your code makes things\neasier.\n\nYou store all your Github actions in a directory called .github/workflows .\nHere is a simple github action that tests your code every time someone's open\na Pull Request or pushes code.\n\n    \n    \n    name: Test on: [push, pull_request] permissions: contents: read jobs: test: runs-on: ubuntu-latest strategy: matrix: python-version: [\"3.10\"] steps: - uses: actions/checkout@v4 - name: Set up Python ${{ matrix.python-version }} uses: actions/setup-python@v5 with: python-version: ${{ matrix.python-version }} cache: pip cache-dependency-path: pyproject.toml - name: Install dependencies run: | pip install '.[test]' - name: Run tests run: | pytest\n\n# Mkdocs\n\nMkDocs is a fast, and simple static site generator that's geared towards\nbuilding project documentation. Documentation source files are written in\nMarkdown, and configured with a single YAML configuration file - mkdocs.yml.\n\nThere are many plugins, themes, and automation recipes that helps with\ndocumenting your package. But to start, you really need only 2 things.\n\n  1. mkdocs.yml configuration file\n\n  2. index.md file under the docs/ directory\n\nThe mkdocs.yml only needs a site name and a site url to be valid. Here is a\nminimal example:\n\n    \n    \n    site_name: My Documentation site_url: https://example.com\n\n# PyPI Trusted Publishing\n\nYour code should now be ready for you to build and distribute to PyPI. The\nprocess is quite simple with PyPI Trusted publishing mechanism. You need to\nsign into PyPI and create a new \u201cpending publisher\u201d. Here is what that looks\nlike.\n\nTrusted publishing is essentially you allowing your GitHub repository your-\nname/your-package to publish packages with the name your-package via a github\naction.\n\nThe next step is to create a publish.yml in your .github/workflows that uses\nGithub Action to publish your code to PyPI automatically whenever you create a\nrelease.\n\n    \n    \n    name: Publish Python Package on: release: types: [created] permissions: contents: read jobs: test: runs-on: ubuntu-latest strategy: matrix: python-version: [\"3.10\"] steps: - uses: actions/checkout@v4 - name: Set up Python ${{ matrix.python-version }} uses: actions/setup-python@v5 with: python-version: ${{ matrix.python-version }} cache: pip cache-dependency-path: pyproject.toml - name: Install dependencies run: | pip install '.[test]' - name: Run tests run: | pytest deploy: runs-on: ubuntu-latest needs: [test] environment: release permissions: id-token: write steps: - uses: actions/checkout@v4 - name: Set up Python uses: actions/setup-python@v5 with: python-version: \"3.12\" cache: pip cache-dependency-path: pyproject.toml - name: Install dependencies run: | pip install setuptools wheel build - name: Build run: | python -m build - name: Publish uses: pypa/gh-action-pypi-publish@release/v1\n\nLet's simplify this file and see what's happening:\n\n  * Essentially, we have two main tasks here: testing and deploying.\n\n  * In the deployment section, we're tackling a couple of key activities. First off, we install the necessary tools for packaging\u2014these include setuptools, wheel, and build. Next, we use Python\u2019s build module to actually build the package. Finally, we publish the package to PyPI using the pypa/gh-action-pypi-publish@release/v1 action.\n\nSo, in a nutshell, we're testing the code, building it, and then pushing it up\nto PyPI.\n\n# Cookiecutter\n\nCookiecutter is a command line tool that automates the process of starting a\nproject. Instead of going through all these steps manually, you can just run\ncookiecutter and the tool will generate all the necessary files and directory\nstructure.\n\nFor tools discussed, I tried to follow python-lib structure and\nrecommendations (only adding mkdocs as an extra dependency). So, to achieve\nthe same results you can:\n\n  1. Install cookiecutter - pipx install cookiecutter\n\n  2. Run it - cookiecutter gh:simonw/python-lib\n\n  3. Optional: Add mkdocs as discussed above.\n\nThere are many cookiecutter templates around with all kind of different\noptions. The truth is, you really want a minimal well-maintained one.\n\nCookiecutter is great as a starting point, but relying completely on it\nwithout understanding all the tools inside can be painful when things go\nwrong. That's why I recommend python-lib which gives you the minimum tools you\nneed to publish your package and nothing else.\n\n# Recipe\n\n  1. Start by creating a PyPI account if you don't already have one. Check to ensure the package name you want isn\u2019t already taken.\n\n  2. Next, set up a new GitHub repository with your package name.\n\n  3. Install Cookiecutter if you haven't already\n\npipx install cookiecutter\n\n  4. Run Cookiecutter and answer the prompts to generate your project skeleton\n\ncookiecutter gh:simonw/python-lib\n\n  5. Create a virtual environment in your project directory and activate it.\n    \n        cd my-new-library # Create and activate a virtual environment: python3 -mvenv venv source venv/bin/activate # Install dependencies so you can edit the project: pip install -e '.[test]' # With zsh you have to run this again for some reason: source venv/bin/activate # test the example function pytest\n\n  6. Initialize a Git repository, commit the initial project structure, and push it to GitHub\n    \n        git init git add -A git commit -m \"Initial structure from template\" git remote add origin https://github.com/{{github_name}}/{{repo_name}}.git git push -u origin main\n\n  7. Check the GitHub Actions tab in your repository to confirm that the test workflow is running. This setup ensures your code is tested with every push.\n\n  8. On your local machine, create a 'develop' branch for ongoing development.\n    \n        git checkout -b \"develop\"\n\n  9. Add MkDocs to your development dependencies in the pyproject.toml file.\n    \n        # nothing else changed [project.optional-dependencies] test = [\"pytest\", \"mkdocs\"]\n\n  10. Create a docs directory and add index.md in there. You can copy the info in the README.md to index.md for now.\n\n  11. Create a mkdocs.yml file. Here is a minimal example.\n    \n        site_name: <your_package> documentation site_url: https://<your_username>.github.io/<repo_name>-docs/\n\n  12. Install mkdocs and deploy a documentation site.\n    \n        # update the dependencies pip install -e '.[test]' # test and adjust the documentations as needed mkdocs serve # deploy your documentations to github pages mkdocs gh-deploy # Add site/ to your .gitignore file echo \"site/\" >> .gitignore\n\n  13. When you are happy with the changes, commit your documentation changes to the 'develop' branch and push\n    \n        git add -A git commit -m \"documentation\" git push -u origin develop\n\n  14. For new features, create a feature branch, add your code, and then merge it back into 'develop' when ready\n    \n        git checkout -b \"new-feature\" # work on your code until done git add -A git commit -m \"feature complete\" git checkout develop # now we merge the completed feature git merge \"new-feature\"\n\n  15. When ready to release, merge 'develop' into 'main', pushing the changes to GitHub\n\n\ud83d\udca1\n\nDon't forget to upgrade your version in pyproject.toml every time you merge\ndevelop into main after the initial release.\n\n    \n        git checkout main git merge develop git push\n\n  16. On Github - create a new release for your package:\n\n  17. On release creation, the publish Github action would run and automatically publish your releases to PyPI\n\nAnd that's it. Congratulations, you have now published your first open-source\nPython package with all what you need for future contributors and users.\n\nFor a practical example, check out the AgentRun repository, which uses the\nsame tools and processes outlined here.\n\n## Subscribe to my newsletter\n\nRead articles from Jonathan's blog directly inside your inbox. Subscribe to\nthe newsletter, and don't miss out.\n\nPythonOpen Source\n\n### Written by\n\n# Jonathan Adly\n\nShare this\n\n### More articles\n\nJonathan Adly\n\n# Using GPT-4 Over Email\n\nI recently came across a tweet from a founder in my network, who had an\ninteresting question on Twit...\n\nJonathan Adly\n\n# How to start a Python project in 2024\n\nWhen I begin a new Python project, one of the first steps I take is to create\na virtual environment....\n\n\u00a92024 Jonathan's blog\n\nArchive\u00b7Privacy policy\u00b7Terms\n\nWrite on Hashnode\n\nPowered by Hashnode - Home for tech writers and readers\n\n", "frontpage": false}
