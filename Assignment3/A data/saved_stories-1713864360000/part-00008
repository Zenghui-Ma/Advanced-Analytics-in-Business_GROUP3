{"aid": "40127738", "title": "Origin of the Term \"Shell\"", "url": "https://www.multicians.org/shell.html", "domain": "multicians.org", "votes": 2, "user": "rookderby", "posted_at": "2024-04-23 02:09:56", "comments": 0, "source_title": "The Origin of the Shell", "source_text": "The Origin of the Shell\n\nMultics > People > Stories 27 Nov 2000\n\n# The Origin of the Shell\n\nMultics Close \u2297\n\nLoading\n\nLouis Pouzin\n\nLouis Pouzin, Andr\u00e9 Bensoussan\n\nCTSS was developed during 1963 and 64. I was at MIT on the computer center\nstaff at that time. After having written dozens of commands for CTSS, I\nreached the stage where I felt that commands should be usable as building\nblocks for writing more commands, just like subroutine libraries. Hence, I\nwrote \"RUNCOM\", a sort of shell driving the execution of command scripts, with\nargument substitution. The tool became instantly most popular, as it became\npossible to go home in the evening while leaving behind long runcoms executing\novernight. It was quite neat for boring and repetitive tasks such as renaming,\nmoving, updating, compiling, etc. whole directories of files for system and\napplication maintenance and monitoring.\n\nIn the same vein, I also felt that commands should be usable as library\nsubroutines, or vice versa. This stemmed from my practice (unique at the time)\nof writing CTSS commands in MAD (Michigan Algorithm Decoder), a simplified\nAlgol-like language. It was much faster and the code was more maintainable\nthan the IBM 7094 assembly code. Since I needed MAD friendly subroutine calls\nto access CTSS primitives, I wrote in assembly code a battery of interface\nsubroutines, which very often mimicked CTSS basic command functions. Or I\nwanted to make commands out of subroutines which handled common chores. I felt\nit was an awkward duplication of effort. However, I did not go further in the\ncontext of CTSS.\n\nThen in 64 came the Multics design time, in which I was not much involved,\nbecause I had made it clear I wanted to return to France in mid 65. However,\nthis idea of using commands somehow like a programming language was still in\nthe back of my mind. Christopher Strachey, a British scientist, had visited\nMIT about that time, and his macro-generator design appeared to me a very\nsolid base for a command language, in particular the techniques for quoting\nand passing arguments. Without being invited on the subject, I wrote a paper\nexplaining how the Multics command language could be designed with this\nobjective. And I coined the word \"shell\" to name it. It must have been at the\nend of 64 or beginning of 65. (See The SHELL: A Global Tool for Calling and\nChaining Procedures in the System and RUNCOM: A Macro-Procedure Processor for\nthe 636 System)\n\nThe small gang of Multics wizards found it a sleek idea, but they wanted\nsomething more refined in terms of language syntax. As time left to me was\nshort, and I was not an expert in language design, I let the issue for them to\ndebate, and instead I made a program flowchart of the shell. It was used after\nI left for writing the first Multics shell. Glenda Schroeder (MIT) and a GE\nman did it.\n\nTime-sharing was a misnomer. While it did allow the sharing of a central\ncomputer, its success derives from the ability to share other resources: data,\nprograms, concepts. It cracked a critical path bottleneck for writing and\ndebugging programs. In theory this could have been achieved as well with a\ndirect access approach. In practice it could not.\n\nDirect access hems users in a static framework. Evolution is unfrequent and\ncontrolled by central and distant agents. Creativity is out of the user's\nhand.\n\nTime sharing, as it became popular, is a living organism in which any user,\nwith various degrees of expertise, can create new objects, test them, and make\nthem available to others, without administrative control and hassle. With the\ninternet experience, this no longer need be substantiated.\n\nPosted to feb_wwide 25 Nov 2000\n\nNext story\n\n", "frontpage": false}
