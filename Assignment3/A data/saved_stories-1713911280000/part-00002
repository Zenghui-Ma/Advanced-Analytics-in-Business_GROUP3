{"aid": "40133792", "title": "How BeanHub works, contains the danger of processing Beancount data with sandbox", "url": "https://beanhub.io/blog/2024/04/23/how-beanhub-works-part1-sandboxing/", "domain": "beanhub.io", "votes": 1, "user": "fangpenlin", "posted_at": "2024-04-23 16:26:18", "comments": 0, "source_title": "How BeanHub works part1, contains the danger of processing Beancount data with sandbox", "source_text": "BeanHub - How BeanHub works part1, contains the danger of processing Beancount\ndata with sandbox\n\nFeatures Pricing Blog\n\nSign in Sign up\n\nFeatures Pricing Blog Sign in Sign up\n\nblog\n\n# How BeanHub works part1, contains the danger of processing Beancount data\nwith sandbox\n\nApril 23, 2024\n\nsecurity\n\nsandbox\n\ncontainer\n\nlinux\n\nkernel\n\nseccomp\n\nIt has been more than two years since we launched BeanHub. Recently, we have\nbeen tirelessly releasing new features. Some of you may ask\n\n> What were you busy with at the very beginning? Why wait until now to start\n> adding new features?\n\nWell, we spent most of our time at the very beginning building the\ninfrastructure to move faster later. We have adopted and developed many\ninteresting technologies in-house. Sandbox is one of the technologies we\nexplored and adopted.\n\n> Isn\u2019t BeanHub just a simple web app for Beancount accounting books? What is\n> the danger of it, and do you need sandboxing?\n\nActually, yes, there\u2019s some potential risk of processing Beancount files. Most\nof Beancount accounting books are simple text files that look harmless like\nthese:\n\n    \n    \n    2024-04-21 open Assets:Cash 2024-04-21 open Expenses:Food 2024-04-22 * \"Dinner\" Assets:Cash -20.00 USD Expenses:Food 20.00 USD\n\nBut when plugins are used, things get tricky. With a Beancount file plus a\nPython script in the same folder like this:\n\nmain.bean:\n\n    \n    \n    option \"insert_pythonpath\" \"true\" plugin \"my_plugins\" 2024-04-21 open Assets:Cash 2024-04-21 open Expenses:Food 2024-04-22 * \"Dinner\" Assets:Cash -20.00 USD Expenses:Food 20.00 USD\n\nmy_plugins.py:\n\n    \n    \n    __plugins__ = [\"evil\"] def evil(entries, options): print('!!ALL YOUR ACCOUNTING BOOKS ARE BELONG TO US!!') return entries, []\n\nThen you run seemly harmless Beancount commands such as printing the balance\nreport:\n\n    \n    \n    bean-report main.bean bal\n\nAnd boom!\n\n    \n    \n    !!ALL YOUR ACCOUNTING BOOKS ARE BELONG TO US!! Assets:Cash -20.00 USD Equity Expenses:Food 20.00 USD Income Liabilities\n\nThe attacker just runs their script on your computer. So keep in mind, next\ntime, instead of being cautious about random people emailing you sexy photos\nto lure you into opening them, you also need to be careful about random people\nsending their sexy Beancount accounting books and wanting you to review them.\n\nAs you can see, the user can upload a beancount file with a plugin pointing to\na local Python file and then run anything in the plugin file. Moreover,\nbecause BeanHub is based on Git, there are many Git operations. If there\u2019s a\nzero-day exploit found in Git, the user could also take advantage of that.\n\nIndeed, there\u2019s an actual security risk. While we made it easy for our users\nto use BeanHub, the technology behind it is not that simple. We put quite some\neffort into making it as secure as possible. Sandboxing is just one of the\ntechnologies we adopt. Today, we would like to share how we use sandbox to\nensure that it\u2019s safe to process user-uploaded Beancount files.\n\n## Container or sandbox?\n\nWhat is a sandbox? A sandbox is an isolated computing environment designed to\nrun untrusted software or process untrusted data. For BeanHub, we are building\nour sandbox on top of open-sourced container technologies. Some may argue that\na container is different from a sandbox, and that\u2019s true. Most of these\npopular container tools focus not solely on security. However, because there\u2019s\na huge overlap of the Linux kernel technologies used between a container and a\nsandbox, we can leverage the container tools and harden them to make them more\nrobust and meet the security requirements for sandbox usage without rebuilding\nthe wheels from the ground up.\n\nHere, we named just a few of the underlying Linux Kernel technologies shared\nbetween a sandbox and container:\n\n  * cgroup\n  * user namespaces\n  * chroot\n  * overlayfs\n\nIt takes a whole book just to discuss container technologies. Still, since\nthat\u2019s not the purpose of this article, you can read Container Security:\nFundamental Technology Concepts that Protect Containerized Applications by Liz\nRice if you want to learn more about them. Today, we will focus more on how\nour sandbox works.\n\n## Running Podman in rootless mode\n\nIf you ever run Docker on your Linux machine, you may know that Docker is\nrunning as a daemon as the root user. And your docker command line tool acts\nas just a client and talks to that daemon process. With the Docker\u2019s client-\nserver architecture, running a container requires talking to the daemon server\nrunning as root. While it\u2019s possible to tell the Docker daemon to run your\ncontainer as a non-root user, if there are any security vulnerabilities in the\nprotocol or if you simply misconfigure it, the container might still be\nrunning as a root user. Therefore, the fact that Docker requires a daemon with\nthe privilege to run a container makes it harder for us to secure it.\n\nWe looked at the container security vulnerabilities found in the past. Many of\nthem require the container or the parent process to run as a root to work. To\navoid potential risks like these, we think it\u2019s better to run the container in\na rootless mode without a daemon, be it from the host\u2019s perspective or inside\nthe container. Yet another reason we need this is that we are using\nKubernetes, and all BeanHub\u2019s services are also running inside a container. We\ndon\u2019t want our BeanHub\u2019s service container running with root privilege and\ndon\u2019t want to expose the Docker socket to the service\u2019s container either.\n\nWith these ideas in mind, we looked around and found Podman. Podman is an\nopen-source alternative to Docker built with a rootless and daemon-less\napproach to containers, developed and released thanks to Red Hat. To learn\nmore about Podman, you can watch this video Rootless Containers with Podman by\nSteven Ellis from Red Hat.\n\nIf you want to learn more details on running rootless containers inside a\ncontainer, you can also read How to use Podman inside of a container by Dan\nWalsh from Red Hat.\n\n## We built and open-sourced container-helpers\n\nRunning a Docker or a Podman command with many arguments would be tedious and\nerror-prone. To make it much easier to control the container environment and\navoid making mistakes, we built a simple library to help us configure the\ncontainer with the simple data structure written in Python. Here\u2019s an example\nof how you run a complex container with Podman by using our library:\n\n    \n    \n    import asyncio import asyncio.subprocess from containers import Container from containers import ImageMount from containers import BindMount from containers import ContainersService service = ContainersService() async def run(): container = Container( image=\"alpine\", command=(\"/path/to/my/exe\", \"arg0\", \"arg1\"), mounts=[ ImageMount( target=\"/data\", source=\"my-data\", read_write=True, ), BindMount( target=\"/artifacts\", source=\"/var/tmp/artifacts\", readonly=False, relabel=\"private\", bind_propagation=\"rslave\" ), ], ) async with service.run(container, stdout=asyncio.subprocess.PIPE) as proc: stdout = await proc.stdout.read() code = await proc.wait() if code != 0: raise RuntimeError(\"Failed\") # ... asyncio.run(run())\n\nWe realized others might also find this library handy, so we open-sourced it\nhere as container-helpers under the MIT license.\n\n## Seccomp and strace\n\nA container-based sandbox mostly relies on features provided by the Linux\nKernel to ensure that a particular process can only do certain things and live\nin an isolated environment. For example, one can use user namespaces to create\nan isolated networking environment for the sandbox process. However, given\nthat the process in the sandbox can make direct system calls to the Kernel,\nit\u2019s still possible that if there\u2019s a bug in the Linux Kernel code, the\nattacker might use the zero-day exploit to escape the isolation or escalate\nprivilege. For example, a security vulnerability in the Linux Kernel allowed\nwaitid syscall to overwrite memory in the Kernel that was found in the past.\n\nPut it simply, the more syscall the process in the sandbox can make, the more\nlikely they will find a bug or two that enables the attacker to escape the\ncontainer boundary. To reduce the attack surface, we apply the most\nrestrictive Seccomp profile on the container, allowing only the minimal\nessential syscalls required by running the service.\n\nWhat\u2019s Seccomp, you may ask? It\u2019s a Linux library that allows you to write a\nset of rules to allow or block certain types of system calls. The rules will\nbe compiled as BPF (Berkeley Packet Filter) and injected into specific Kernel\nentry points. By default, Docker or Podman comes with its default Seccomp\nprofile, like this one from Docker. You can think it\u2019s like a firewall between\nuserspace and Linux Kernel for filtering system calls based on rules. A\nSeccomp profile of a container usually comes as a JSON file that looks like\nthis:\n\n    \n    \n    { \"defaultAction\": \"SCMP_ACT_ERRNO\", \"defaultErrnoRet\": 1, \"syscalls\": [ { \"names\": [ \"accept\", \"accept4\", // Omit ... \"write\", \"writev\" ], \"action\": \"SCMP_ACT_ALLOW\" }, // Omit ... ] }\n\nAs you can see, it provides simple operation rules such as SCMP_ACT_ALLOW and\nSCMP_ACT_ERRNO with a list of syscall. You can copy and modify the default\nSeccomp profile, remove the unwanted syscall, and only keep the absolutely\nnecessary ones. Once your Seccomp profile is ready, you can pass them as\n--security-opt seccomp=/path/to/seccomp/profile.json as an argument to run\nyour container.\n\nTo learn which syscalls are required to run your program, you can use the\nstrace command line tool. For example, to learn the minimal syscall required\nfor running git version command, you can run this:\n\n    \n    \n    sudo strace -o trace-result.txt -f -c git version\n\nAnd here\u2019s the result in the trace-result.txt file\n\n    \n    \n    % time seconds usecs/call calls errors syscall ------ ----------- ----------- --------- --------- ---------------- 0.00 0.000000 0 7 read 0.00 0.000000 0 1 write 0.00 0.000000 0 9 close 0.00 0.000000 0 25 mmap 0.00 0.000000 0 7 mprotect 0.00 0.000000 0 3 brk 0.00 0.000000 0 1 rt_sigaction 0.00 0.000000 0 1 rt_sigprocmask 0.00 0.000000 0 2 pread64 0.00 0.000000 0 4 3 access 0.00 0.000000 0 1 execve 0.00 0.000000 0 1 getcwd 0.00 0.000000 0 2 1 arch_prctl 0.00 0.000000 0 1 set_tid_address 0.00 0.000000 0 28 20 openat 0.00 0.000000 0 24 12 newfstatat 0.00 0.000000 0 1 set_robust_list 0.00 0.000000 0 1 prlimit64 0.00 0.000000 0 1 getrandom 0.00 0.000000 0 1 rseq ------ ----------- ----------- --------- --------- ---------------- 100.00 0.000000 0 121 36 total\n\nHere you go. By running the strace command like this, you will now know which\nsyscalls your program uses. However, please remember that you may need to\ndesign a set of tests to cover all the possible paths in your program to\nensure that all the used syscalls will be covered. Otherwise, your program\nmight crash or encounter errors due to system calls blocked by the Seccomp\nprofile.\n\nAs we mentioned, allowing the container process to make direct syscalls to the\nKernel poses a risk. Other than Seccomp, you can check out projects such as\ngVisor if you want even stricter enforcement. It\u2019s a container runtime open-\nsourced by Google. They implemented most of the syscalls in Golang, and it\nonly sends out very few system calls to the Linux Kernel, thus further\nreducing the attack surface. But that\u2019s out-of-topic, and we will leave that\nto the reader to explore.\n\n## Disabling network\n\nAllowing a process in the sandbox to access the internet or local network\nincreases the security risk by a great deal of magnitude. Think about this: if\nyou have an internal server running in your cloud, if the attacker knows where\nthat address is, they can access it from your container. The AWS EC2 metadata\nURL is a great example. Any process inside an EC2 instance with network access\ncan easily visit the metadata URL at http://169.254.169.254/latest/meta-data/\nand retrieve critical information about the instance. That\u2019s why AWS now\ndisabled access to these URLs without authentication by default.\n\nOther than the potential risk of internal service exposure, another possible\nrisk is that the attacker can effortlessly phone home to notify the successful\nattack. Without access to the internet, the more likely way for the attacker\nto find out whether their attack works could only be changing the output from\nthe container and hoping it will get picked up by our service and stored\nsomewhere for them to inspect. However, since our service checks and validates\nthe output before we even continue processing them, we will see an error\nreport if there\u2019s anything wrong with the container output. So, to break the\nsandbox without a valid way to evaluate what works or not is like driving with\na blindfold on your head in a minefield without blowing up and getting\nnoticed.\n\nConsidering the risks, we ensured all BeanHub operations inside a sandbox\ndon\u2019t need access to the internet or a local network. Our service communicates\nwith the container via stdin, stdout, and file operations. Since there\u2019s no\nneed for a network, the containers are all running with the --network none\nargument.\n\n## Final thought, defense in depth\n\nWith all the user-uploaded data processed inside a sandbox, now it\u2019s way\nharder to compromise BeanHub\u2019s service. The worst case would be the attacker\ncompromising the sandbox container and modifying their own data unless they\ncan find a way to escape.\n\nWe believe in defense in depth. Just because we use a sandbox to run and\nprocess the user-uploaded data doesn\u2019t necessarily mean our system is 100%\nsecure. This article only covered a few security measurements and the\ninteresting tricks we\u2019ve developed for building BeanHub. We left out many\nother details, such as the --security-opt=no-new-privileges to keep the\narticle length in control. If you want to learn more about container security\nand best practices besides the Container Security book, you can also read\nDocker Security Cheat Sheet.\n\nWe\u2019ve learned a lot from building BeanHub, and I think sharing our experiences\nwould be great for the community. This is just part 1 of a series of articles\nwe will publish. I hope you enjoy it. Next, we will discuss our layer-based\ndistributed Git repository system and explain how we made all the Git changes\nauditable. Even if the user corrupted or overwritten the Git history, we can\nstill trace back to who did it, when it happened, and what the previous state\nwas. Stay tuned by subscribing to our mailing list at the bottom of this page.\nSee you next time!\n\n### Fang-Pen Lin\n\nSoftware Engineer and Founder of Launch Platform\n\nShare\n\n#### Got a question? Send us a message and we'll respond as soon as possible\n\nCONTACT US\n\nCopyright \u00a9 2023 Launch Platform LLC. All rights reserved.\n\nCopyright \u00a9 2023 Launch Platform LLC. All rights reserved.\n\n  * Beancount Formatter\n  * API Docs\n  * Open Source\n  * Privacy Policy\n  * Terms of Service\n\n", "frontpage": false}
