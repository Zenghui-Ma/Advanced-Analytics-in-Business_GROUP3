{"aid": "40159766", "title": "DDC OLED: how to drive a tiny display from an HDMI port. (2022)", "url": "https://mitxela.com/projects/ddc-oled", "domain": "mitxela.com", "votes": 38, "user": "fanf2", "posted_at": "2024-04-25 16:42:05", "comments": 6, "source_title": "DDC OLED - mitxela.com", "source_text": "DDC OLED - mitxela.com\n\n# DDC OLED\n\n31 Mar 2022 Progress: Complete\n\nI have a proclivity to stupid and/or pointless projects. This is one of them.\nConceived from a conversation that ended with \"Hey, it would technically be\npossible to...\" \u2013 sure, let's do it.\n\nDDC, display data channel, is a protocol for reading information about what\nresolutions and so on a monitor supports. It was later extended to DDC/CI,\nthat lets you set brightness and other parameters, but fundamentally, the\noriginal idea was to stick a cheap i2c eeprom on each device with some basic\ninfo on it. (Technically, the original idea was even simpler than that, but\nlet's not get into that.)\n\nIt began in the VGA days, but has become so entrenched that even modern\nhardware with HDMI or DisplayPort supports it. That's right, in an HDMI cable,\nnestled amongst the high-speed differential pairs, there's an exceedingly slow\ni2c bus.\n\nTiny OLED dot-matrix displays often have an i2c controller, so I had the idea\nto try and plug one directly into an HDMI port. Hilarious! Let's do it.\n\n### Wiring\n\nI chopped up a broken HDMI cable and found the pins we care about: SCL, SDA,\n5V, DDC-GND, and HPD (Hot Plug Detect). A quick google got us the pinout:\n\nThis diagram shows an HDMI socket, if you're poking pins into the cable then\nflip left to right.\n\nHDMI Pin Number| Signal  \n---|---  \n1| TMDS Date 2+  \n2| TMDS Data 2 shield  \n3| TMDS Data 2-  \n4| TMDS Data 1+  \n5| TMDS Data 1 shield  \n6| TMDS Data 1-  \n7| TMDS Data 0+  \n8| TMDS Data 0 shield  \n9| TMDS Data 0-  \n10| TMDS Clock+  \n11| TMDS Clock shield  \n12| TMDS Clock-  \n13| CEC  \n14| HEC Data-  \n15| SCL (Serial Clock for DDC  \n16| SDA (Serial Data Line for DDC  \n17| DDC / CEC / HEC Ground  \n18| +5 V Power (50 mA max)  \n19| Hot Plug Detect (1.3) / HEC Data+ (1.4)  \n  \nI've a tendency to choose low-risk options when it comes to hardware hacking,\nno one likes seeing blue smoke, especially if the dev board was expensive.\nToday though I feel like living on the edge, and I'm going to solder this\ndisplay directly onto the severed HDMI cable coming out of my reasonably new\nlaptop. What a thrill! If we mess up, this stupid experiment could be very\nexpensive.\n\nYou have to register to download the HDMI spec which is more effort than I\nhave for this, but the Hot Plug Detect pin has a pretty descriptive name. I\nguessed that this either has to be pulled up or pulled down to signal that a\ncable is connected. Sticking a 20K resistor to the 5V pin seemed to do the\ntrick. With the oscilloscope, we can now see activity on the SCL/SDA lines\nwhen it's plugged into the laptop.\n\nI then boldly soldered a header connector to the four lines we care about. I'd\nordered a couple of OLED screens for this experiment, they both use the\nSSD1306 controller, and come on breakout boards with the four pins on a\nheader.\n\n### i2c and SMBus\n\nOn linux we can access i2c devices by loading the i2c-dev module (modprobe\ni2c-dev) which makes a bunch of i2c devices appear at /dev/i2c-*. My laptop\nshows nine i2c devices.\n\nSome of these are in fact SMBus, which is a subset of i2c. As far as we're\nconcerned it's just i2c with a bunch of extra restrictions, such as limiting\ntransactions to 32 bytes.\n\nIt's also worth installing the i2c-tools package which comes with the\ni2cdetect utility and sets a udev rule for group permissions. To access i2c\ndevices without sudo, add yourself to the i2c group (sudo usermod -G i2c -a\nusername) and log in again for it to take effect. I also had to run udevadm\ntrigger for the udev rule to take effect. Might have been simpler to reboot\n(never!).\n\nBeware: the i2c device naming is not consistent. I figured out that /dev/i2c-3\nwas the HDMI DDC line I'd soldered to, but after unloading and re-loading the\nmodule, it became /dev/i2c-4. We need to be really careful about this, writing\n(or even reading) to the wrong i2c device could easily muck up some of the\nlaptop hardware.\n\nI installed another package, ddcutil, only to be able to do ddcutil detect.\nThis lists displays and their associated i2c bus. It's also possible to do\ni2cdetect -l which lists the i2c devices and their description. In my case,\nthree of the i2c lines had \"i915 gmbus\" in their description, i915 is the\nintel graphics driver. ddcutil is still probably the easiest way to figure it\nout.\n\n### Initial tests\n\nThe scope showed the SCL/SDA lines are already pulled up, so we should be able\nto connect the screen without any other hardware. The 5V line on an HDMI port\ncan apparently source up to 50mA, so we don't even need a power supply. Neat!\n\ni2cdetect can scan an i2c bus for devices. As expected, without the cable\nconnected, it detected nothing on the bus. But when I connected my severed\ncable, with the hot plug detect resistor in place, a whole load of responses\nappeared. I don't know quite what's going on here (does the video hardware\nexpose a bunch of stuff when the cable is connected?) but the important point\nis that when I connected the display, an extra device showed up at 0x3c.\n\nThe quickest way to talk to the display is with a python script. The bundled\nsmbus library lets us get going very quickly.\n\n    \n    \n    import smbus bus = smbus.SMBus(4) # for /dev/i2c-4 i2caddr = 0x3c bus.write_i2c_block_data(i2caddr, 0, [0xaf] ) # turn display on\n\nThere's a bunch of commands we need to send before we can actually display\nanything, including enabling the charge pump. Note that the SSD1306 datasheet,\nat least the copy I found, has an appnote appended onto the end of it that\nexplains the initialization process more clearly than the main document (some\nof the commands are not documented in the main command table). As always, the\nfastest way to get going is to look at the source code to existing libraries,\nso I found somebody else's library for the SSD1306 and copied their init\ncommands. The display sprang to life!\n\nI also found a script to draw text to an SSD1306, and quickly patched in my\nsmbus stuff. Success!\n\nNo microcontroller, no other hardware, just an SSD1306 OLED plugged straight\ninto the HDMI port. I find this very satisfying.\n\n### Dumping data to it\n\nSticking with the python script for now, I'd like to be able to take a 128x64\npixel image and dump it onto the display. The text-drawing routine I borrowed\nuses SSD1306 commands to control the column and page address that data is\nbeing written to, so a single character can be drawn without affecting the\nrest of the display (hence the uninitialized background pixels remaining in\nthat image above).\n\nThere's a whole load of different memory addressing modes for this thing,\nalong with confusing terminology. SEG or COL is the X coordinate, COM is the Y\ncoordinate, but these are grouped into pages. The datasheet has some diagrams.\n\nThe display is monochrome, each page is 8 rows (COMs) and when we pipe data to\nthe display, each byte is one page, one column of pixels. It may have made\nmore sense to configure the display for vertical addressing mode, so the bits\nwould all be in order, but I figured it would be quickest to just do the bit-\nshuffling at our end.\n\nWith python PIL (pillow) we can convert an image to monochrome with\n.convert(1) and serialize it with .tobytes(). This will have each byte\nrepresent 8 horizontal pixels, but we want each byte to represent 8 vertical\npixels. Instead of doing some tedious bitwise logic, the fastest way to fix\nthis is by rotating the image 90 degrees before we serialize it, then loading\nthose bytes into a numpy matrix and transposing it. It's the kind of thing\nthat either works perfectly first time, or outputs a complete mess, in which\ncase you just permute the order of operations until it works. So much easier\nthan thinking.\n\nAs I mentioned, SMBus won't let us send more than 32 bytes at a time, even\nthough this device is just plain i2c. We can get around this by accessing the\ni2c device directly from python. The trick is to use ioctl to configure the\nslave address. In the kernel header file i2c-dev.h there are definitions for\nthe constants needed, we only care about I2C_SLAVE.\n\n    \n    \n    import io, fcntl dev = \"/dev/i2c-4\" I2C_SLAVE=0x0703 # from i2c-dev.h i2caddr = 0x3c bus = io.open(dev, \"wb\", buffering=0) fcntl.ioctl(bus, I2C_SLAVE, i2caddr) bus.write(bytearray([0x00, 0xaf]))\n\nBy alternately sending 1024 bytes of zero or 0xFF, I could gauge how quickly\nthis updated the display. Seemed to work fastest by sending 256 bytes at a\ntime, not sure if that's a limitation of the i2c hardware (is there some extra\nlayer of buffering?).\n\nWith this I could get between 5 and 10 frames per second (compared to about\n2FPS with the SMBus limitation). I think the DDC is running at 100kHz, but\nregardless this is certainly pushing the limits of what it was intended for.\n\n### Make it a monitor\n\nWe could just write our application to draw directly to this screen, but\nthat's not good enough, I want it to be a monitor.\n\n(I'm not sure what our application here even is, but that's beside the point.\nI want it to be a monitor!)\n\nWe could write our own video driver. As educational as this sounds, it would\nbe a colossal amount of work and I was rather hoping to have this wrapped up\nwithin the evening.\n\nThere are a bunch of dummy video drivers in existence, these are intended for\nheadless machines in order to enable VNC and so on. xserver-xorg-video-dummy\nmay function for us, but I have a terrible feeling this won't play well at all\nwith us also having real display outputs. There's Xvfb, a virtual framebuffer,\nbut this won't do us much good if we want to have our desktop extend onto it.\n\nSince I'm using xorg, it seems the right way to fake a monitor, without\nspending days on it, is to go through xrandr.\n\nxrandr is both a library, and a userspace commandline utility.\n\nIt took me a while to get to grips with the xrandr terminology. It's not\nparticularly well explained.\n\n  * The \"framebuffer\" is the whole desktop, i.e. what gets saved if you take a screenshot.\n  * An \"output\" is a physical video output.\n  * A \"monitor\" is virtual concept, that normally is mapped to all or part of the framebuffer, and normally corresponds to one output. If you maximize a window, it fills the dimensions of the monitor.\n\n    * However, you can have one display output be more than one monitor (for instance, to split a widescreen display into effectively two monitors)\n    * Or, multiple outputs can be one monitor, i.e. multiple physical screens can be treated as if they were a single display, maximizing a window would cover all of them.\n  * a \"mode\" is a video format, consisting of at least width, height and framerate. Specifically, VESA CVT modelines are used, and can be generated with the cvt utility.\n\n    * xrandr's addmode and delmode refer to associating an existing mode with a display output\n    * xrandr's newmode and rmmode refer to adding a new mode to the server, that can then be associated with an output\n\nNote that this list is specific to xrandr, in other aspects of linux, the\nterms \"output\", \"display\", \"monitor\" and \"screen\" are often used differently.\n\nOn my laptop, calling xrandr shows five video outputs: eDP-1, which is the\nmain screen with a bazillion modes available, and four disconnected (HDMI-1,\nHDMI-2, DP-1, DP-2), presumably three of which are available via thunderbolt\nor something.\n\n### Faking a monitor, attempt 1\n\nLooking around, it seems the recommended way to do this is to convince xrandr\nthat one of the unused video outputs is connected. For things like VNC there's\na whole market for \"dummy plugs\" which make a video card think a monitor is\nconnected. We obviously don't want or need to do that, we should be able to\ncoax xrandr into behaving through software.\n\nIn order to output our abnormally low resolution of 128x64 on HDMI, in theory\nwe first generate a CVT modeline:\n\n    \n    \n    $ cvt 128 64 # 128x64 39.06 Hz (CVT) hsync: 3.12 kHz; pclk: 0.50 MHz Modeline \"128x64_60.00\" 0.50 128 136 144 160 64 67 77 80 -hsync +vsync\n\nthen we add this mode to the x server:\n\n    \n    \n    $ xrandr --newmode \"128x64_60.00\" 0.50 128 136 144 160 64 67 77 80 -hsync +vsync\n\nAt this point, xrandr shows the unused mode at the end of its output.\nConfusingly it looks like the mode is part of the last output listed, but it\nisn't (yet). We next add this mode to one of the outputs:\n\n    \n    \n    xrandr --addmode HDMI-1 128x64_60.00\n\nand finally try to use it:\n\n    \n    \n    xrandr --output HDMI-1 --mode 128x64_60.00 --right-of eDP-1\n\nI should point out, I've a hotkey on my laptop which cycles through sane\ndisplay modes, so I'm comfortable trying whatever here, but otherwise there's\na chance you end up unable to see anything. It should still be possible to\naccess the other virtual terminals with ctrl+alt+F2 etc, since these configure\nthe display using KMS (Kernel Mode Setting) that sits a layer below the X\nserver.\n\nI tried this with both HDMI-1 and HDMI-2. Both of them are listed as\ndisconnected. Our cable connected to HDMI-1 is pulling the Hot Plug Detect pin\nhigh, but not responding to regular DDC queries.\n\nI may not have exhausted all possibilities, but I couldn't get this to work. I\nsuspect the video driver simply can't cope with this ludicrously nonstandard\nresolution, and the modeline is just junk. The 39.06Hz certainly raised one of\nmy eyebrows. I tried again specifically setting the framerate to 39.06Hz also,\nto no avail.\n\nHonestly, abusing the video outputs like this feels like a poor solution\nanyway.\n\nTo clean up this mess, first use --delmode to free up the modes from any\noutputs, then --rmmode to remove them from the X server.\n\n### Faking a monitor, attempt 2\n\nWhen you change display settings xrandr generally sets all the relevant\nsettings automatically, but if we go deeper we can manually fiddle with them.\nFollowing another idea on the internet, we should be able to make a virtual\nmonitor by simply extending the framebuffer, and defining a monitor to be\nthere, without bothering to associate it with an output.\n\nInterestingly, if you make the framebuffer bigger than needed, by default it\nwill automatically pan when your mouse approaches the border. Useful to know,\nbut here we need to specifically stop that happening. The --panning option\ntakes up to twelve parameters, for panning area, tracking area, and border.\nTracking is the area our mouse cursor is limited to. Normally, panning,\ntracking and framebuffer are all set to the same size. I'm not sure what\n\"border\" represents in the context of panning, it didn't seem to have any\neffect when I played with it.\n\nSetting panning to 0x0 will disable it, but that also limits the tracking\narea, so our mouse won't be able to reach the new bit of framebuffer. Instead\nwe limit panning to the size of the main monitor, effectively disabling it,\nand extend the tracking area into our new chunk of framebuffer. The full\ncommand:\n\n    \n    \n    xrandr --fb 2048x1080 --output eDP-1 --panning 1920x1080/2048x1080\n\nThen we can define a new monitor to exist in this new chunk of framebuffer:\n\n    \n    \n    xrandr --setmonitor virtual 128/22x64/11+1920+0 none\n\nThe size is set in both pixels and mm, I guessed it's approximately 22m by\n11mm, it doesn't really matter though. \"virtual\" is the name of this monitor,\nwe could call it anything. \"none\" is the output. We can see monitors with\nxrandr --listmonitors and later undo this muck with xrandr --delmonitor\nvirtual.\n\nI can now point my script to dump that bit of framebuffer onto the OLED\nscreen. Hurrah! One slight issue with this method is that the tracking is not\nL-shaped, my mouse can access the strip of framebuffer that doesn't correspond\nto any monitor. I don't know if there's an easy fix for this, but if it really\nbothered us we could enforce valid cursor positions through Xlib in our\nscript.\n\n### Reading the framebuffer\n\nI assumed I'd need to throw away the python script at this point but there's\npython-xlib which gives us access to most of what we need. It's a little\nirritating that there isn't really any documentation, and the method names are\nnot identical, for instance XGetImage is now root.get_image.\n\nHere is some trivia: did you know that the mouse cursor is rendered by\nhardware? It makes sense, I suppose. It also explains why the mouse cursor\nisn't normally captured when you take a screenshot. But we want to capture the\nframebuffer and the mouse on top of it so there's a lot more work involved.\n\nGetting the cursor image would normally be achieved through XFixesCursorImage\nbut python-xlib hasn't yet implemented all of XFixes. I was prepared to start\nover in C until I spotted someone's done all the work for me with this repo\nwhich binds to X11/XFixes using ctypes specifically to get the cursor\ninformation.\n\nWe now have everything we need to capture the new virtual monitor image,\nsuperimpose the cursor in the right place (remembering to adjust for xhot and\nyhot, the pointer/cursor image offset), convert the result to a monochrome\nimage with the right amount of bit-shuffling and pipe it to the display\ncontinuously.\n\nThat's i3 workspace four, with a completely crushed i3status and\nincomprehensible dithered top corner of my background image. Beautiful!\n\n### Demo\n\n### Conclusion\n\nTo improve the framerate, we could enhance our script and only send the\nchanges instead of redrawing the display each frame. As fantastic as this\ncould be, given that I have absolutely no use for this tiny second screen\nanyway, I'm not particularly inclined to make it happen.\n\nIf for some mad reason you want to try this out yourself, the script can be\nfound on github.\n\nUpdate: How can we make the smallest and worst \"HDMI\" display even sillier?\nMake it steampunk.\n\n", "frontpage": true}
