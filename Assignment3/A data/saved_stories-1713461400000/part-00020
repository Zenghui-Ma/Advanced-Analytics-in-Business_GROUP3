{"aid": "40073657", "title": "CSS in React Server Components", "url": "https://www.joshwcomeau.com/react/css-in-rsc/", "domain": "joshwcomeau.com", "votes": 1, "user": "mariuz", "posted_at": "2024-04-18 06:57:30", "comments": 0, "source_title": "CSS in React Server Components", "source_text": "CSS in React Server Components\n\nSkip to content\n\nJoshWComeau\n\nHomeTutorialsReact\n\n# CSS in React Server Components\n\nUnderstanding the future of CSS-in-JS and React\n\n## Introduction\n\nAround this time last year, Vercel announced the stable release of Next 13.4,\nbecoming the first React framework to be built on top of React Server\nComponents.\n\nThis is a big deal! RSC (React Server Components) gives us an official way to\nwrite server-exclusive code in React. It opens a lot of interesting new doors.\n\nBut you can't make an omelette without cracking a few eggs. RSC is a\nfundamental change to how React works, and some of the libraries and tools\nwe've been using have gotten scrambled. \ud83d\ude05\n\nConcerningly, the most popular CSS-in-JS libraries like \ud83d\udc85 styled-components\nand Emotion aren't fully compatible with this new vision for React, and there\nhasn\u2019t really been a clear path forward.\n\nOver the past few months, I\u2019ve been digging into this, building an\nunderstanding of the compatibility issues, and learning about what the options\nare. At this point, I feel like I have a pretty solid grasp on the whole\nsituation. I\u2019ve also discovered some pretty exciting developments that have\nbeen flying under the radar. \u2728\n\nIf you use a CSS-in-JS library, my hope is that this blog post will help clear\naway a lot of confusion, and give you some practical options for what to do.\n\nAnd if you don\u2019t use a CSS-in-JS library, this blog post should still help\ndeepen your understanding of React Server Components. Many of the issues we\u2019ll\ncover here aren't specific to CSS-in-JS!\n\nJust use\n\nWhen this discussion comes up online, one of the most common suggestions is to\nswitch to a different CSS tool. After all, there are no shortage of options in\nthe React ecosystem!\n\nFor many of us, though, this isn't a practical suggestion. I have more than\n5,000 styled components across my blog and course platform. Migrating to an\nentirely different tool is much easier said than done.\n\nAnd honestly, even if I could snap my fingers and swap in a totally different\nlibrary, I wouldn't want to. I really like the styled API!\n\nLater in this blog post, we will discuss some alternative CSS libraries, but\nwe\u2019ll focus on options with similar APIs to styled-components.\n\n##\n\nLink to this heading\n\nBreaking down React Server Components\n\nIn order to understand the compatibility issues, we need to understand React\nServer Components. Before we can talk about that, though, we need to make sure\nthat we understand Server Side Rendering (SSR).\n\nSSR is an umbrella term that comprises several different strategies and\nimplementations, but the most typical version of it looks like this:\n\n  1. User visits our web app.\n\n  2. The request is received by Node.js, which runs React in a windowless server environment. It renders our application and produces a fully-formed HTML document containing all of the initial UI.\n\n  3. When this HTML document loads on the user\u2019s device, React will re-render all of the same components, repeating the work done on the server. Instead of generating new HTML elements, however, it \u201cadopts\u201d the HTML elements that were generated by the server. This is known as hydration.\n\nReact needs to run on the user\u2019s device to handle interactivity. The HTML\ngenerated by the server is totally static; it won't include any event handlers\nwe\u2019ve written (eg. onClick), or capture any refs we\u2019ve specified (with the ref\nattribute).\n\nOK, but why does it have to re-do all of the exact same work?? When React\nboots up on the user\u2019s device, it\u2019ll discover a bunch of pre-existing UI, but\nit won't have any context about it, such as which component owns each HTML\nelement. React needs to perform the exact same work in order to reconstruct\nthe component tree, so that it can wire up the existing HTML correctly,\nattaching event handlers and refs to the correct elements. React needs to draw\nitself a map so that it can pick up where the server left off.\n\nThere's one big limitation with this model. All of the code we write will be\nexecuted on the server and the client. There's no way to create components\nthat render exclusively on the server.\n\nLet\u2019s suppose we're building a full-stack web application, with data in a\ndatabase. If you were coming from a language like PHP, you might expect to be\nable to do something like this:\n\n    \n    \n    jsx\n    \n    \n    function Home() {\n    \n    const data = db.query('SELECT * FROM SNEAKERS');\n    \n    return (\n    \n    <main>\n    \n    {data.map(item => (\n    \n    <Sneaker key={item.id} item={item} />\n    \n    ))}\n    \n    </main>\n    \n    );\n    \n    }\n\nIn theory, this code could work just fine on the server, but that exact same\ncode will be re-executed on the user\u2019s device, which is a problem, since\nclient-side React won\u2019t have access to our database. There\u2019s no way to tell\nReact \u201cRun this code only on the server, and re-use the resulting data on the\nclient\u201d.\n\nMeta-frameworks built on top of React have come up with their own solutions.\nFor example, in Next.js, we can do this:\n\n    \n    \n    jsx\n    \n    \n    export async function getServerSideProps() {\n    \n    const data = await db.query('SELECT * FROM SNEAKERS');\n    \n    return {\n    \n    props: {\n    \n    data,\n    \n    },\n    \n    };\n    \n    }\n    \n    function Home({ data }) {\n    \n    return (\n    \n    <main>\n    \n    {data.map(item => (\n    \n    <Sneaker key={item.id} item={item} />\n    \n    ))}\n    \n    </main>\n    \n    );\n    \n    }\n\nThe Next.js team said \u201cAlright, so the exact same React code has to run on the\nserver and client... but we can add some extra code, outside of React, that\nonly runs on the server!\u201d.\n\nWhen the Next.js server receives a request, it'll first invoke the\ngetServerSideProps function, and whatever it returns will be fed in as props\nto the React code. The exact same React code runs on the server and client, so\nthere\u2019s no problem. Pretty clever, right?\n\nI'm honestly a pretty big fan of this approach, even today. But it does feel a\nbit like a workaround, an API created out of necessity because of a React\nlimitation. It also only works at the page level, at the very top of each\nroute; we can't pop a getServerSideProps function anywhere we want.\n\nReact Server Components provides a more intuitive solution to this problem.\nWith RSC, we can do database calls and other server-exclusive work right in\nour React components:\n\n    \n    \n    jsx\n    \n    \n    async function Home() {\n    \n    const data = await db.query('SELECT * FROM SNEAKERS');\n    \n    return (\n    \n    <main>\n    \n    {data.map(item => (\n    \n    <Sneaker key={item.id} item={item} />\n    \n    ))}\n    \n    </main>\n    \n    );\n    \n    }\n\nIn the \u201cReact Server Components\u201d paradigm, components are Server Components by\ndefault. A Server Component runs exclusively on the server. This code will not\nre-run on the user's device; the code won't even be included in the JavaScript\nbundle!\n\nThis new paradigm also includes Client Components. A Client Component is a\ncomponent that runs on both the server and client. Every React component\nyou've ever written in \u201ctraditional\u201d (pre-RSC) React is a Client Component.\nIt's a new name for an old thing.\n\nWe opt in to Client Components with a new \"use client\" directive at the top of\nthe file:\n\n    \n    \n    jsx\n    \n    \n    'use client';\n    \n    function Counter() {\n    \n    const [count, setCount] = React.useState(0);\n    \n    return (\n    \n    <button onClick={() => setCount(count + 1)}>\n    \n    Count: {count}\n    \n    </button>\n    \n    );\n    \n    }\n\nThis directive creates a \u201cclient boundary\u201d; all components in this file, as\nwell as any that are imported, will render as a Client Component, running\nfirst on the server and again on the client.\n\nUnlike other React features (eg. hooks), React Server Components requires deep\nintegration with the bundler. As I write this in April 2024, the only\npractical way to use React Server Components is with Next.js, though I expect\nthis to change in the future.\n\n###\n\nLink to this heading\n\nServer Components are limited\n\nThe key thing to understand about Server Components is that they don't provide\nthe \u201cfull\u201d React experience. Most React APIs don't work in Server Components.\n\nFor example, useState. When a state variable changes, the component re-\nrenders, but Server Components can't re-render; their code is never even sent\nto the browser, and so React would have no idea how to process a state change.\nFrom React\u2019s perspective, any markup generated by Server Components is set in\nstone and cannot be changed on the client.\n\nSimilarly, we can't use useEffect inside Server Components because effects\ndon\u2019t run on the server, they only run after renders on the client. And since\nServer Components are excluded from our JavaScript bundles, client-side React\nwould never know that we\u2019d written a useEffect hook.\n\nEven the useContext hook can't be used inside Server Components, because the\nReact team hasn't yet solved the problem of how React Context can be shared\nacross both Server Components and Client Components.\n\nHere\u2019s how I look at it: Server Components aren't really React components, at\nleast not as we've traditionally understood them. They're much more like PHP\ntemplates, rendered by a server to create the original HTML. The real\ninnovation is that Server Components and Client Components can co-exist in the\nsame application!\n\nGoing deeper\n\nIn this blog post, I want to focus on the most pertinent details of React\nServer Components, the stuff we need to know in order to understand the\ncompatibility issues with CSS-in-JS frameworks.\n\nIf you'd like to learn more about React Server Components, though, I have a\nseparate blog post that explores this new world in much more depth:\n\n  * \u201cMaking Sense of React Server Components\u201d\n\n##\n\nLink to this heading\n\nHow CSS-in-JS libraries work\n\nAlright, so we've covered the fundamentals of React Server Components. Now\nlet's talk about the fundamentals of CSS-in-JS libraries like \ud83d\udc85 styled-\ncomponents!\n\nHere's a quick example:\n\n    \n    \n    jsx\n    \n    \n    import styled from 'styled-components';\n    \n    export default function Homepage() {\n    \n    return (\n    \n    <BigRedButton>\n    \n    Click me!\n    \n    </BigRedButton>\n    \n    );\n    \n    }\n    \n    const BigRedButton = styled.button`\n    \n    font-size: 2rem;\n    \n    color: red;\n    \n    `;\n\nInstead of putting our CSS in a class like .red-btn, we instead attach that\nCSS to a freshly-generated React component. This is what makes styled-\ncomponents special; components are the reusable primitive, not classes.\n\nstyled.button is a function that dynamically generates a new React component\nfor us, and we\u2019re assigning that component to a variable called BigRedButton.\nWe can then use that React component the same way we\u2019d use any other React\ncomponent. It'll render a <button> tag that has big red text.\n\nBut how exactly does the library apply this CSS to this element? We have three\nmain options:\n\n  1. Styles could be applied inline, through the style attribute.\n\n  2. Styles could be put in a separate CSS file, and loaded via <link>.\n\n  3. Styles could be put in a <style> tag, typically in the <head> of the current HTML document.\n\nIf we run this code and inspect the DOM, the answer is revealed:\n\n    \n    \n    html\n    \n    \n    <html>\n    \n    <head>\n    \n    <style data-styled=\"active\">\n    \n    .abc123 {\n    \n    font-size: 2rem;\n    \n    color: red;\n    \n    }\n    \n    </style>\n    \n    </head>\n    \n    <body>\n    \n    <button className=\"abc123\">\n    \n    Click me!\n    \n    </button>\n    \n    </body>\n    \n    </html>\n\nstyled-components will write the provided styles to a <style> tag that the\nlibrary manages. In order to connect those styles to this particular <button>,\nit generates a unique class name, \"abc123\".\n\nAll of this work first happens during the initial React render:\n\n  * In a client-side-rendering context (eg. Parcel, create-react-app), the <style> tag is dynamically generated on the user's device, just like all of the DOM nodes that React creates.\n\n  * In a server-side rendering context (eg. Next, Remix), this work happens on the server. The generated HTML document will include this <style> tag.\n\nAs the user interacts with our application, certain styles might need to be\ncreated, modified, or destroyed. For example, suppose we have a conditionally-\nrendered styled-component:\n\n    \n    \n    jsx\n    \n    \n    function Header() {\n    \n    const user = useUser();\n    \n    return (\n    \n    <>\n    \n    {user && (\n    \n    <SignOutButton onClick={user.signOut}>\n    \n    Sign Out\n    \n    </SignOutButton>\n    \n    )}\n    \n    </>\n    \n    );\n    \n    }\n    \n    const SignOutButton = styled.button`\n    \n    color: white;\n    \n    background: red;\n    \n    `;\n\nInitially, if user is undefined, <SignOutButton> won\u2019t be rendered, and so\nnone of these styles will exist. Later, if the user signs in, our application\nwill re-render, and styled-component kicks into gear, injecting these styles\ninto the <style> tag.\n\nEssentially, every styled component is a regular React component, but with an\nextra lil\u2019 side effect: they also render their styles to a <style> tag.\n\nFor our purposes today, this is the most important takeaway, but if you'd like\nto drill deeper into the inner workings of the library, I wrote a blog post\nall about it called \u201cDemystifying styled-components\u201d.\n\n##\n\nLink to this heading\n\nThe Crux of the Problem\n\nTo summarize what we've learned so far:\n\n  * \u201cReact Server Components\u201d is a new paradigm for React that gives us a new type of component, the Server Component. Server Components render exclusively on the server. Their code isn\u2019t even included in our JS bundles.\n\n  * The styled-components library allows us to dynamically create React components with attached CSS. It works by managing a <style> tag that gets updated as components re-render.\n\nThe fundamental incompatibility is that styled-components are designed to run\nin-browser, whereas Server Components never touch the browser.\n\nInternally, styled-components makes heavy use of the useContext hook. It's\nmeant to be tied into the React lifecycle, but there is no React lifecycle for\nServer Components. And so, if we want to use styled-components in this new\n\u201cReact Server Components\u201d world, every React component that renders even a\nsingle styled-component needs to become a Client Component.\n\nI don\u2019t know about you, but it's pretty rare for me to have a React component\nthat doesn\u2019t include any styling. I'd estimate that 90%+ of my component files\nuse styled-components. Most of these components are otherwise totally static;\nthey don't use state or any other Client Component features.\n\nThis is a bummer, since it means we\u2019re not able to take full advantage of this\nnew paradigm... but it\u2019s not actually the end of the world.\n\nIf I could change one thing about React Server Components, it would be the\nname \u201cClient Component\u201d. This name implies that these components only render\non the client, but that\u2019s not true. Remember, \u201cClient Component\u201d is a new name\nfor an old thing. Every React component in every React application created\nbefore May 2023 is a Client Component.\n\nAnd so, even if only 10% of the components in a styled-components application\ncan become Server Components, that\u2019s still an improvement! Our applications\nwill still become a bit lighter and faster than they were in a pre-RSC world.\nWe still get all the benefits of SSR. That hasn\u2019t changed.\n\nCan\u2019t they just update it?\n\nYou might be wondering why the maintainers of styled-components / Emotion\nhaven't updated their libraries to become compatible with React Server\nComponents. We\u2019ve known this was coming for over a year, why haven't they\nfound a solution yet??\n\nThe styled-components maintainers are currently blocked by missing APIs in\nReact. Specifically, React hasn't provided a RSC-friendly alternative to\nContext, and styled-components needs some way to share data between components\nin order to correctly apply all of the styles during Server Side Rendering.\n\nA few weeks ago, I did some pretty deep exploration, and honestly, I have a\nhard time imagining how this could ever work without React Context. As far as\nI can tell, the only solution would be to completely rewrite the whole library\nto use an entirely different approach. Not only would this cause significant\nbreaking changes, it's also a completely unreasonable thing to expect a team\nof volunteer open-source maintainers to do.\n\nIf you're curious to learn more, there's a styled-components Github issue\nwhich explains what the blockers are. I\u2019ve seen similar discussions in the\nEmotion repo as well.\n\n##\n\nLink to this heading\n\nThe World of Zero-Runtime CSS-in-JS Libraries\n\nSo far, the story has been kinda grim. There is a fundamental incompatibility\nbetween React Server Components and styled-components, and the library\nmaintainers haven\u2019t been given the tools they\u2019d need to add support.\n\nFortunately, the React community hasn't been sleeping on this issue! Several\nlibraries are being developed which offer a styled-components-like API, but\nwith full compatibility with React Server Components! \u2728\n\nInstead of being tied into the React lifecycle, these tools have taken a\ndifferent approach; all of the processing is done at compile-time.\n\nModern React applications have a build step, where we turn TypeScript/JSX into\nJavaScript, and package thousands of individual files into a handful of\nbundles. This work is done when our application is deployed, before it starts\nrunning in production. Why not process our styled components during this step,\ninstead of at runtime?\n\nThis is the core idea behind all of the libraries we\u2019ll discuss in this\nsection. Let's dive in!\n\n###\n\nLink to this heading\n\nLinaria\n\nLinaria was created all the way back in 2017. It's almost as old as styled-\ncomponents!\n\nThe API looks identical to styled-components:\n\n    \n    \n    jsx\n    \n    \n    import styled from '@linaria/react';\n    \n    export default function Homepage() {\n    \n    return (\n    \n    <BigRedButton>\n    \n    Click me!\n    \n    </BigRedButton>\n    \n    );\n    \n    }\n    \n    const BigRedButton = styled.button`\n    \n    font-size: 2rem;\n    \n    color: red;\n    \n    `;\n\nHere\u2019s the really clever bit: during the compile step, Linaria transforms this\ncode, and moves all of the styles into CSS Modules.\n\nAfter running Linaria, the code would look something like this:\n\n    \n    \n    css\n    \n    \n    /* /components/Home.module.css */\n    \n    .BigRedButton {\n    \n    font-size: 2rem;\n    \n    color: red;\n    \n    }\n    \n    \n    jsx\n    \n    \n    /* /components/Home.js */\n    \n    import styles from './Home.module.css';\n    \n    export default function Homepage() {\n    \n    return (\n    \n    <button className={styles.BigRedButton}>\n    \n    Click me!\n    \n    </button>\n    \n    );\n    \n    }\n\nIf you\u2019re not already familiar with CSS Modules, it's a lightweight\nabstraction over CSS. You can pretty much treat it as plain CSS, but you don't\nhave to worry about globally-unique names. During the compile step, right\nafter Linaria works its magic, generic names like .BigRedButton are\ntransformed into unique ones like .abc123.\n\nThe important thing is that CSS Modules are already widely-supported. It's one\nof the most popular options out there. Meta-frameworks like Next.js already\nhave first-class support for CSS Modules.\n\nAnd so, rather than reinvent the wheel and spend years building a robust\nproduction-ready CSS solution, the Linaria team decided to take a shortcut. We\ncan write styled-components, and Linaria will pre-process them into CSS\nModules, which will then be processed into plain CSS. All of this happens at\ncompile-time.\n\nRun-time vs compile-time tradeoffs\n\nLong before RSC was a thing, the community has been building compile-time\nlibraries like Linaria. The performance advantages are compelling: styled-\ncomponents adds 11 kilobytes (gzip) to our JavaScript bundle, but Linaria adds\n0kb, since all the the work is done ahead of time. Additionally, server-side\nrendering gets a bit quicker, since we don't have to spend any time collecting\nand applying styles.\n\nThat said, the styled-components runtime isn\u2019t just dead weight. We can do\nthings in styled-components that just aren\u2019t possible at compile-time. For\nexample, styled-components can dynamically update the CSS when some React\nstate changes.\n\nFortunately, CSS has gotten a lot more powerful in the near-decade since\nstyled-components was first created. We can use CSS variables to handle most\ndynamic use cases. These days, having a runtime can offer a slightly-nicer\ndeveloper experience in some situations, but in my opinion, it isn\u2019t really\nnecessary anymore.\n\nThis does mean that Linaria and other compile-time CSS-in-JS libraries won't\ntruly be drop-in replacements for styled-components/Emotion. We\u2019ll have to\nspend some time reworking dynamic components. But this is a tiny fraction of\nthe work compared to switching to an entirely different CSS tool.\n\n####\n\nLink to this heading\n\nMigrating to Linaria\n\nSo, should we all migrate our styled-components applications to Linaria?\n\nUnfortunately, there\u2019s a problem. While Linaria itself is actively maintained,\nthere are no official bindings for Next.js, and getting Linaria to work with\nNext.js is non-trivial.\n\nThe most popular integration, next-linaria, hasn\u2019t been updated in 3 years,\nand isn\u2019t compatible with the App Router / React Server Components. There is a\nnewer option, next-with-linaria, but it has a big warning about not using it\nin production. \ud83d\ude05\n\nSo, while this might be an option for adventurous developers, it\u2019s not really\nsomething I feel comfortable recommending.\n\n###\n\nLink to this heading\n\nPanda CSS\n\nPanda CSS is a modern CSS-in-JS library developed by the folks who built\nChakra UI, a popular component library.\n\nPanda CSS comes with many different interfaces. You can use it like Tailwind,\nspecifying shorthand classes like mb-5. You can use it like Stitches, using\nvariants and cva. Or, you can use it like styled-components.\n\nHere\u2019s what it looks like with the styled API:\n\n    \n    \n    jsx\n    \n    \n    import { styled } from '../styled-system/jsx'\n    \n    export default function Homepage() {\n    \n    return (\n    \n    <BigRedButton>\n    \n    Click me!\n    \n    </BigRedButton>\n    \n    );\n    \n    }\n    \n    const BigRedButton = styled.button`\n    \n    font-size: 2rem;\n    \n    color: red;\n    \n    `;\n\nLike Linaria, Panda CSS compiles away, but it instead compiles to Tailwind-\nstyle utility classes. The end result would look something like this:\n\n    \n    \n    css\n    \n    \n    /* /styles.css */\n    \n    .font-size_2rem {\n    \n    font-size: 2rem;\n    \n    }\n    \n    .color_red {\n    \n    color: red;\n    \n    }\n    \n    \n    jsx\n    \n    \n    /* /components/Home.js */\n    \n    export default function Homepage() {\n    \n    return (\n    \n    <button className=\"font-size_2rem color_red\">\n    \n    Click me!\n    \n    </button>\n    \n    );\n    \n    }\n\nFor every unique CSS declaration like color: red, Panda CSS will create a new\nutility class in one central CSS file. This file would then be loaded on every\nroute in our React application.\n\nI really want to like Panda CSS. It's being developed by a solid team with\nlots of relevant experience, it offers a familiar API, and they even have a\ncute skateboarding panda mascot!\n\nAfter experimenting with it, though, I\u2019ve discovered that it\u2019s just not for\nme. Some of my issues are frivolous/superficial; for example, Panda CSS\ngenerates a bunch of stuff that clutters up the project files. This feels a\nbit messy to me, but ultimately it\u2019s not a significant problem.\n\nThe bigger issue for me is that Panda CSS is missing a critical feature. We\ncan\u2019t cross-reference components.\n\nThis\u2019ll be easier to explain with an example. On this blog, I have a TextLink\ncomponent, a styled wrapper around Next.js\u2019s Link component. By default, it\nlooks like this:\n\n  * This is an example link\n\nThis same component, however, has certain contextual styles. For example, when\nTextLink is within Aside, it looks like this:\n\nThis is an example link\n\nI use this Aside component for tangential / bonus bits of information. I found\nthat the default TextLink styles didn\u2019t quite work in this context, and so I\nwanted to apply some overrides.\n\nHere\u2019s how we can express this relationship in styled-components:\n\n    \n    \n    jsx\n    \n    \n    import Link from 'next/link';\n    \n    import { AsideWrapper } from '@/components/Aside';\n    \n    const TextLink = styled(Link)`\n    \n    color: var(--color-primary);\n    \n    text-decoration: none;\n    \n    ${AsideWrapper} & {\n    \n    color: inherit;\n    \n    text-decoration: underline;\n    \n    }\n    \n    `;\n\nThe ampersand character (&) was recently added to the CSS language as part of\nthe official nesting syntax, but it\u2019s been a convention in CSS preprocessors\nand tools for many years. In styled-components, it evaluates to the current\nselector.\n\nUpon rendering this code, the generated CSS would look something like this:\n\n    \n    \n    css\n    \n    \n    .textlink_abc123 {\n    \n    color: var(--color-primary);\n    \n    text-decoration: none;\n    \n    }\n    \n    .aside_def456 .textlink_abc123 {\n    \n    color: inherit;\n    \n    text-decoration: underline;\n    \n    }\n\nWhen I work with CSS, I try to follow a rule: all of the styles for a\nparticular component should be written in one place. I shouldn\u2019t have to go on\na scavenger hunt across the application to find all of the different CSS that\ncould apply to a given element!\n\nThis is one of the things that is so powerful about Tailwind; all of the\nstyles are colocated together, on the element itself. We don\u2019t have to worry\nabout some other component \u201creaching in\u201d and styling an element it doesn\u2019t\nown.\n\nThis pattern is like a supercharged version of that idea. Not only are we\nlisting out all of the styles that apply to TextLink by default, we\u2019re also\nlisting out the styles that apply contextually. And they\u2019re all grouped\ntogether in one spot, between the backticks.\n\nSadly, this pattern doesn't work in Panda CSS. In Panda CSS, we uniquely\nidentify the CSS declarations?, not the elements themselves, and so there\u2019s no\nway to express these sorts of relationships.\n\nIf you\u2019re not interested in this pattern, then Panda CSS might be a good\noption for your application! But for me, this is a dealbreaker.\n\nThe styled-components Happy Path\n\nIf you\u2019d like to learn more about this \u201ccontextual styles\u201d pattern, I cover it\nin depth in my blog post, \u201cThe styled-components Happy Path\u201d. It's a\ncollection of patterns and tips I\u2019ve learned after many years with styled-\ncomponents.\n\n###\n\nLink to this heading\n\nPigment CSS\n\nOne of the most popular React component libraries, Material UI, is built on\ntop of Emotion. Their dev team has been grappling with all the same issues\naround RSC compatibility, and they\u2019ve decided to do something about it.\n\nThey recently open-sourced a new library. It\u2019s called Pigment CSS. Its API\nshould look pretty familiar at this point:\n\n    \n    \n    jsx\n    \n    \n    import { styled } from '@pigment-css/react';\n    \n    export default function Homepage() {\n    \n    return (\n    \n    <BigRedButton>\n    \n    Click me!\n    \n    </BigRedButton>\n    \n    );\n    \n    }\n    \n    const BigRedButton = styled.button`\n    \n    font-size: 2rem;\n    \n    color: red;\n    \n    `;\n\nPigment CSS runs at compile-time, and it uses the same strategy as Linaria,\ncompiling to CSS Modules. There are plugins for both Next.js and Vite.\n\nIn fact, it uses a low-level tool called WyW-in-JS (\u201cWhat you Want in JS\u201d).\nThis tool evolved out of the Linaria codebase, isolating the \u201ccompile to CSS\nModules\u201d business logic and making it generic, so that libraries like Pigment\nCSS can build their own APIs on top of it.\n\nHonestly, this feels like the perfect solution to me. CSS Modules are already\nso battle-tested and heavily optimized. And from what I've seen so far,\nPigment CSS is awesome, with great performance and DX.\n\nThe next major version of Material UI will support Pigment CSS, with plans to\neventually drop support for Emotion/styled-components altogether. As a result,\nPigment CSS will likely become one of the most widely-used CSS-in-JS\nlibraries. Material UI is downloaded ~5 million times per week on NPM, ~1/5th\nas much as React itself!\n\nIt's still very early; Pigment CSS was only open-sourced a few weeks ago. But\nthe team is putting significant resources behind this project. I can\u2019t wait to\nsee how things develop!\n\n###\n\nLink to this heading\n\nThe list goes on\n\nIn addition to the libraries we\u2019ve covered so far, there are many more\nprojects in the ecosystem that are doing interesting things. Here are some\nmore projects I\u2019m keeping an eye on:\n\n  * next-yak \u2014 Created by developers for Switzerland\u2019s largest e-commerce retailer, next-yak is a compile-time CSS-in-JS library which aims to be as close to a drop-in replacement for styled-components as possible, re-implementing many of its secondary APIs.\n\n  * Kuma UI \u2014 This library is trying something pretty ambitious: a \u201chybrid\u201d design, where most styles are extracted at compile-time, but a run-time is available for Client Components.\n\n  * Parcel macros \u2014 Parcel is a bundler that recently implemented \u201cmacros\u201d, a tool which can be used to build all sorts of things, including compile-time CSS-in-JS libraries. Amazingly, this feature isn\u2019t Parcel-specific, and can be used with Next.js!\n\n##\n\nLink to this heading\n\nThe path forward\n\nAlright, so we\u2019ve explored a whole bunch of options, but the question remains:\nif you have a production application that uses a \u201clegacy\u201d CSS-in-JS library,\nwhat should you actually do?\n\nIt\u2019s a bit counter-intuitive, but in many cases, I don\u2019t actually think you\nneed to do anything. \ud83d\ude05\n\nA lot of the discussion online makes it sound like you can\u2019t use styled-\ncomponents in a modern React / Next.js application, or that there's a huge\nperformance penalty for doing so. But that\u2019s not really true.\n\nA lot of folks are getting RSC (React Server Components) and SSR (Server Side\nRendering) mixed up. Server Side Rendering still works exactly the same way as\nit always has, it isn\u2019t affected by any of this stuff. Your application\nshouldn\u2019t get slower if you migrate to Next\u2019s App Router or another RSC\nimplementation. In fact, it\u2019ll probably get a bit faster!\n\nFrom a performance perspective, the main benefit with RSC and zero-runtime CSS\nlibraries is TTI, \u201cTime To Interactive\u201d. This is the delay between the UI\nbeing shown to the user and the UI being fully interactive. If neglected, it\ncan produce bad user experiences; people will start clicking on things\nexpecting them to work, but nothing happens because the application is still\nin the process of hydrating.\n\nAnd so, if your application takes a long time to hydrate right now, migrating\nto a zero-runtime CSS library could have a positive effect on user experience.\nBut if your app already has a solid TTI, your users likely won\u2019t see any\nbenefit from this migration.\n\nI feel like the biggest issue, in many cases, is FOMO. As developers, we want\nto use the latest and greatest tools. It's no fun adding a bunch of \"use\nclient\" directives, knowing we\u2019re not benefitting as much from a new\noptimization. But is this really a compelling reason to undergo a big\nmigration?\n\n###\n\nLink to this heading\n\nWhat I'm doing\n\nI maintain two primary production applications: this blog, and a course\nplatform I use for my interactive courses (CSS for JavaScript Developers and\nThe Joy of React).\n\nMy course platform is still using the Next.js Pages Router with styled-\ncomponents, and I have no plans to migrate it any time soon. I'm happy with\nthe user experience it offers, and I don't believe there would be a\nsignificant performance benefit to migrating.\n\nMy blog also currently uses the Next.js Pages Router with styled-components,\nthough I am in the process of migrating it to use the Next.js App Router. I've\nchosen to use Linaria + next-with-linaria, at least for now. When Pigment CSS\nis a bit more mature, I plan on switching over.\n\nReact Server Components is super cool. The React/Vercel teams have done an\nincredible job rethinking how React works on the server. But honestly, having\nembarked on one of these migrations myself, I\u2019m not sure I would really\nrecommend it for most production applications. Even though App Router has been\nmarked as \"stable\", it's still nowhere near as mature as the Pages Router, and\nthere are still some rough edges.\n\nIf you\u2019re happy with your application\u2019s performance, I don't think you should\nfeel any urgency around updating/migrating \u2764\ufe0f. Your current stack will\ncontinue to work just fine, and in a couple of years, you can check back in\nand see what the story is.\n\nThe Joy of React\n\nI\u2019ve been using React for almost a decade now, and it's truly been my\nfavourite way to build dynamic web applications. I spent a couple of years\ncompiling everything I know about React into an interactive self-paced course\ncalled The Joy of React.\n\nIn this course, we build a mental model of how React works, and I share the\n\u201chappy practices\u201d that have helped me become so productive with React. It even\ncovers React Server Components and the Next.js App Router in depth, along with\nother modern features like Suspense and Streaming Server Side Rendering.\n\nYou can learn more here:\n\n  * The Joy of React\n\n### Last Updated\n\nApril 15th, 2024\n\n### Hits\n\n## A front-end web development newsletter that sparks joy\n\nMy goal with this blog is to create helpful content for front-end web devs,\nand my newsletter is no different! I'll let you know when I publish new\ncontent, and I'll even share exclusive newsletter-only content now and then.\n\nNo spam, unsubscribe at any time.\n\nJoshWComeau\n\nThanks for reading!\n\n\u00a9 2020-present Joshua Comeau. All Rights Reserved.\n\nTutorials\n\nReactAnimationCSSCareerJavaScriptNext.jsPerformance\n\nLinks\n\nTwitterContactTerms of UsePrivacy Policy\n\n\u00a9 2020-present Joshua Comeau. All Rights Reserved.\n\n", "frontpage": false}
