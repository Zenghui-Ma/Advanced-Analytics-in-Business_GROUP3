{"aid": "40047566", "title": "Predicting Solar Eclipses with Python", "url": "https://erikbern.com/2024/04/07/predicting-solar-eclipses-with-python.html", "domain": "erikbern.com", "votes": 2, "user": "dangoldin", "posted_at": "2024-04-16 01:40:26", "comments": 0, "source_title": "Predicting solar eclipses with Python", "source_text": "Predicting solar eclipses with Python \u00b7 Erik Bernhardsson\n\n## Erik Bernhardsson\n\n#### About Resume Top posts\n\n# Predicting solar eclipses with Python\n\n2024-04-07\n\nAs I am en route to see my first total solar eclipse, I was curious how hard\nit would be to compute eclipses in Python. It turns out, ignoring some minor\ncoordinate system head-banging, I was able to get something half-decent\nworking in a couple of hours.\n\nI didn't want to go deep on celestial mechanics, so I decided to leverage\nPython's fantastic ecosystem for everything. The package Astropy turns out to\nhave about 80% of the stuff I wanted, in particular making it quite\nstraightforward to compute the position of the sun and the moon in the sky.\nAfter just a few minutes of googling, I had something that computes the\noverlap between the sun and the moon given a particular point on the Earth:\n\n    \n    \n    from astropy.coordinates import EarthLocation, get_body from astropy.time import Time from astropy.units import deg, m def sun_moon_separation(lat: float, lon: float, t: float) -> float: loc = EarthLocation(lat=lat * deg, lon=lon * deg, height=0 * m) time = Time(t, format=\"unix\") moon = get_body(\"moon\", time, loc) sun = get_body(\"sun\", time, loc) sep = moon.separation(sun) return sep.deg\n\nThis takes a (latitude, longitude) pair as well as a unix timestamp and\ncomputes the angular separation between the sun and the moon. Basically this\nmeans just the distance between the centers of the objects, seen in the sky\nfrom the Earth. If the angular separation is very close to zero, we have a\nsolar eclipse.\n\nHowever! I didn't want to compute this for a given coordinate. I wanted to\ncompute the location of a total eclipse given a timestamp (if there is one).\n\nIdeally, we would grab 3D coordinates for the Earth, the sun, and the moon.\nThen project a line between the sun through the moon, see if that line hits\nthe Earth, and if it does, find the latitude and longitude of this\nintersection. This is probably the \u201cright\u201d way to do it, and if I had time, I\nwould brush the dust off my geometry skills and do this.\n\nHowever, I don't have time! It's the day before the eclipse, and I just want\nto compute coordinates in the least arduous way possible. We already have\nsomething that computes a related thing, but we need to flip things around a\nbit. We're going to do this using a bulldozer I love using for stuff like\nthis: black-box optimization.\n\n## Solving for the coordinates using black-box optimization\n\nWe have a function that takes (timestamp, latitude, longitude) and outputs the\ndistance between the sun and the moon in the sky. But let's instead try to\nsolve this related problem: Given a timestamp, find the latitude and the\nlongitude that minimizes the distance between the sun and the moon in the sky.\n\nIf the minimum distance is essentially zero, this means that we found a solar\neclipse. In that case, the coordinate that minimizes the function is the\ncenter of the sun's shadow on the Earth.\n\nIt's relatively straightforward to minimize an arbitrary function like this.\nMy go-to package for this is scipy.optimize which has a bunch of well-tested\nroutines that are probably implemented in Fortran 77 if you dig deep enough.\nWe don't even have the gradient for the function, but that's fine \u2014 Nelder-\nMead is your friend.\n\nThe nice part of it is we can treat this function as a completely black-box\nand optimize it from the outside. It does get somewhat computationally\nexpensive, but it's not something I would personally lose sleep over.\n\nThe code to use scipy.optimize.minimize to find the eclipse location ends up\nlike this:\n\n    \n    \n    def find_eclipse_location(dt: datetime) -> tuple[float, float] | None \"\"\"Return the coords of a total eclipse, or `None`.\"\"\" t = datetime.timestamp(dt) fun = lambda x: sun_moon_separation(x[0], x[1], t) ret = minimize(fun, bounds=[(-90, 90), (-180, 180)], x0=(0, 0)) return ret.x if ret.fun < 1e-3 else None\n\nBasically, we bind the time to sun_moon_separation, and construct a new\nfunction with 2 variables: latitude and longitude. And then we search over\nthis function (with bounds) to find the minimum.\n\nThis almost works! Well, part of the problem was that I wasted 2 hours because\nof a dumb sign error with latitudes and longitudes. But even after fixing\nthat, I ended up with weird spurious coordinates.\n\nI think this is because of bogus minima, since I think the the antipode of one\nsolution is another solution. We should obviously discard solutions when you\ncan't see the sun. Two simple modifications makes the solver work super\nreliably:\n\n  1. If the sun or moon is below the horizon, return some large number\n  2. Instead of using (0, 0) as the starting point, do a simple grid search over a few points on the Earth and pick the one with the smallest sun-moon distance. Then use that point as the starting point for the optimization.\n\nMy final code for sun_moon_separation and find_eclipse_location ends up just a\ntiny bit more complex than what I shared above. With these tricks, we now have\na function that reliably takes any timestamp and figures out the\nlatitude/longitude for a solar eclipse (if there is one).\n\n## Finding all the eclipses\n\nOk, so now let's find a bunch of eclipses! In particular, let's find the path\nof every eclipse in the 2020-2030 span. This will require us to search over a\nlot of timestamps.\n\nAlas, the find_eclipse_location function is pretty slow!\n\nSo what do we do? More tricks:\n\n  1. Do a coarse search over the full decade, only probing every hour. If we identify an eclipse, do a more granular search and map out the path minute by minute.\n  2. Parallelize!!!\n\nI'm the CEO of Modal, which makes it super easy to take Python code and run it\nin the cloud. Honestly I wasn't planning on using Modal for this, but scaling\nout computationally intensive functions is such an great use case for Modal\nthat I immediately just grasped for it.\n\nWe can find all eclipses in the 2020-2030 period my adding a simple decorator\nto find_eclipse_location and then mapping over it. The mapping code ends up\nlooking like this:\n\n    \n    \n    def run(): dt_a = datetime(2020, 1, 1, 0, 0, 0, tzinfo=timezone.utc) dt_b = datetime(2030, 1, 1, 0, 0, 0, tzinfo=timezone.utc) # Compute evenly spaced datetimes dt = dt_a dts = [] while dt < dt_b: dts.append(dt) dt = dt + timedelta(seconds=3600) # Map over it using Modal!!! for tup in find_eclipse_location.map(dts): if tup is not None: print(\"Found eclipse at\", tup)\n\n## Plotting it\n\nI'm glossing over a few details in the actual code, but bear with me. Once we\nhave all the paths, we can plot them. I used Basemap and got something half-\ndecent pretty quickly:\n\n    \n    \n    from matplotlib import pyplot from mpl_toolkits.basemap import Basemap def plot_path(dts: list[datetime], lats: list[float], lons: list[float]): # Set up a world map pyplot.figure(figsize=(6, 6)) lat_0, lon_0 = lats[len(lats) // 2], lons[len(lons) // 2] bm = Basemap(projection=\"ortho\", lat_0=lat_0, lon_0=lon_0) bm.drawmapboundary(fill_color=\"navy\") bm.fillcontinents(color=\"forestgreen\", lake_color=\"blue\") bm.drawcoastlines() # Plot eclipse path x, y = bm(lons, lats) bm.plot(x, y, color=\"red\")\n\nI added a few more things in my final script, including local times by using\ntimezonefinder to look up local timezones from (latitude, longitude) pairs.\n\nThis is what the eclipse tomorrow (on 2024-04-08) looks like if we plot it\nusing the script:\n\nGorgeous!\n\nActually this probably isn't award-winning in terms of design quality, but it\nfeels fairly decent for something as a starting point \u2014 the point here isn't\nnecessarily to win design awards, but to find eclipses in ~100 lines of\nPython.\n\nWhich the script does! In fact, it finds all the eclipses in the 2020-2030\nperiod:\n\n  * 2020-06-21 over Africa, Middle East, and Asia\n  * 2020-12-14 over a tiny bit of South America\n  * 2021-06-10 over northern Canada and Greenland\n  * 2021-12-04 over Antarctica\n  * 2023-04-20 over Australia and Papua New Guinea\n  * 2023-10-14 over USA, Central America, and South America\n  * 2024-04-08 over Mexico, USA and Canada (tomorrow!!)\n  * 2024-10-02 over a tiny bit of South America (again?)\n  * 2026-02-17 over a tiny bit of Antarctica (will anyone see it?)\n  * 2026-08-12 over Greenland and Spain\n  * 2027-02-06 over a tiny bit of South America (a third time??)\n  * 2027-08-02 over North Africa and Middle East\n  * 2028-01-26 over South America and Spain\n  * 2028-07-22 over Australia and New Zealand\n\nThis does indeed look identical to other lists I found online, which is quite\nreassuring.\n\nTotal runtime is a few minutes thanks to Modal.\n\nIt is admittedly a bit of a brute-force approach to do it this way, and I'm\nsure NASA has a version in C++ that runs 1000 times faster. However, the\nbrute-force approach is such a obvious winner in terms of developer\nproductivity, even ignoring the fact that we also plotted maps!\n\n## Notes\n\n  * Lucky bastards in the south of South America catching three eclipses in a decade.\n  * The code is here if you want to check it out!.\n  * I was somewhat inspired by this blog post doing something similar in Mathematica and I guess I have to say I'm impressed with the amount of eclipse-related functions in Mathematica?\n  * Credits to Stackoverflow code here for a starting point in my code\n  * I ignored the difference between annular and total eclipses in my code, although this probably isn't super hard to fix.\n  * I also didn't compute the width of the path of totality, i.e. the width of the sun's shadow on the Earth. Just the path of the center of that shadow.\n\nTagged with: programming\n\n### Related posts\n\n  * Storm in the stratosphere: how the cloud will be reshuffled 2021-11-30\n  * Software infrastructure 2.0: a wishlist 2021-04-19\n\n### Erik Bernhardsson\n\n... is the founder of Modal Labs which is working on some ideas in the\ndata/infrastructure space. I used to be the CTO at Better. A long time ago, I\nbuilt the music recommendation system at Spotify. You can follow me on Twitter\nor see some more facts about me.\n\n\u00a9 Erik Bernhardsson 2024\n\n", "frontpage": false}
