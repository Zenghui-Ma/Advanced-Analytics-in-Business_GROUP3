{"aid": "40126935", "title": "Modal is a matrioshka language based on pattern-matching to rewrite trees", "url": "https://wiki.xxiivv.com/site/modal", "domain": "xxiivv.com", "votes": 6, "user": "smlavine", "posted_at": "2024-04-22 23:52:32", "comments": 0, "source_title": "XXIIVV \u2014 modal", "source_text": "XXIIVV \u2014 modal\n\nModal In A Postcard\n\n## Modal is a matrioshka language based on pattern-matching to rewrite trees.\n\nModal programs are represented as a series of rules, formatted as tokens\ndelimited by brackets and parentheses, applied to a given tree which gets\ncontinually modified until no rules match any given part of the tree.\n\n\"modal(adj.): of, or relating to structure as opposed to substance.\"\n\nElements of modal are:\n\n  * Rules: <> left right\n  * Registers: ?x, ?y, ?z\n  * Trees: word, (a tuple), a (cons (list))\n\nThe documentation below displays the examples as a series of rules, followed\nby the rewriting steps in the following format:\n\n    \n    \n    <> A rule .. The input program 04 The result of applying rule #4 -1 The result of applying a lambda\n\n### Rules\n\nTo define a new rule, start with <>, followed by a left and a right statement,\nwhich is either a word, or a tree. The program evaluation starts at the first\ncharacter of the string and walks through to the end trying to match a\ntransformation rule from that location:\n\n    \n    \n    <> hello (good bye) This is a rule .. hello world This is program data 00 good bye world This is the result\n\n### Registers\n\nRegisters are single-character identifiers bound to an address in a pattern\nused in rewriting:\n\n    \n    \n    <> (copy ?a) (?a ?a) .. copy cat 00 cat cat\n\nWhen a register is used in a pattern, and when we try to match a given tree\nwith a pattern, each register is bound to a corresponding an address and\nreferenced in either side of a rule:\n\n    \n    \n    <> (swap ?x ?y) (?y ?x) .. (swap fox rat) 00 (rat fox)\n\nWhen a register appears more than once in a rule, each instance is bound to\nthe first address:\n\n    \n    \n    <> (?x ?x ?x) triplet .. (fox fox fox) 00 (triplet)\n\n### Trees\n\nTrees can be found in rules and program data, they include words, registers\nand nested trees. Rules can match specific trees and rewrite their content in\na new sequence.\n\n    \n    \n    <> (rotate ?x (?y) ?z) (?y (?z) ?x) .. rotate foo (bar) baz 00 bar (baz) foo\n\nAn efficient way to represent an array is to store information in nested\nlists, it allows for rules to target specific segments of the list, similarly\nto Lisp's car and cdr primitives. To print each element of such a structure,\nwe can use the following recursive rules:\n\n    \n    \n    <> (putrec (?: ?x)) (putrec ?:?x) <> ((putrec (?:))) (?:) .. (putrec (a (b (c (d (e)))))) 00 (putrec (b (c (d (e))))) 00 (putrec (c (d (e)))) 00 (putrec (d (e))) 00 (putrec (e)) 01 > abcde\n\n### Special Registers\n\nSpecial registers are registers that do more than simply store a reference,\nthey allow implementations to choose which special behavior is needed by the\nhost platform, without impacting the core of the language:\n\nSubstrings  \n---  \nExplode token| ?(?* ?*) abc| a (b (c ()))  \nExplode tuple| ?(?* ?*) (abc def ghi)| abc (def (ghi ()))  \nUnpack| ?(?. ?.) (abc def)| abc def  \nJoin| ?(?^ ?^) (abc def ghi)| abcdefghi  \nIO  \nRead| ?~| Read from devices  \nSend| ?:| Send to devices  \n  \nA lambda is created by using the ?(body) special register. Rules created that\nway exist only for the length of one rewrite and must match what is found\nimmediately after:\n\n    \n    \n    .. ?((?x ?y) (?y ?x)) foo bar -1 bar foo\n\nExplode a token or tuple, into a nested list with the ?* special register,\nnotice how the following program makes use the List type to ensure a specific\nevaluation order:\n\n    \n    \n    <> (reverse List () ?^) (?^) <> (reverse (?*)) (reverse List (?*) ()) <> (reverse List (?x ?y) ?z) (reverse List ?y (?x ?z)) .. (reverse (modal)) 01 (reverse List (m (o (d (a (l ()))))) ()) 02 (reverse List (o (d (a (l ())))) (m ())) 02 (reverse List (d (a (l ()))) (o (m ()))) 02 (reverse List (a (l ())) (d (o (m ())))) 02 (reverse List (l ()) (a (d (o (m ()))))) 02 (reverse List () (l (a (d (o (m ())))))) 00 (ladom)\n\nSending a message to a device is done with the ?: special register, it sends a\nword or a tree to be handled by a device:\n\n    \n    \n    <> (print ?:) (?:) .. print (hello world\\n) hello world\n\nSimilarly, reading an incoming message from a device is done with the ?~\nspecial register:\n\n    \n    \n    <> (?: print) (?:) <> (READ ?~) ((You said: ?~ \\n) print) .. (READ stdin) You said:\n\n### Type Systems\n\nUnderstanding how to use types to guard rules for specific evaluation order is\nimportant to become proficient with Modal. Creating a type system is merely a\nmatter of creating stricter rules expecting a specific grammar.\n\n    \n    \n    <> (join ?^) (?^) <> (join-strings (String ?x) (String ?y)) (join (?x ?y)) .. join-strings (String foo) (String bar) 01 join (foo bar) 00 foobar\n\nNotice in the example above, how join-strings expects to match two String\ntyped words. Without typed inputs, the rule is not matched.\n\n    \n    \n    .. join-string (bar baz)\n\n### Logic\n\nLet us build a logic system, starting by comparing two registers:\n\n    \n    \n    <> (eq ?x ?x) (#t) <> (eq ?x ?y) (#f) .. (eq fox bat) 01 (#f)\n\nWe can implement the truth tables by defining each case:\n\n    \n    \n    <> (and #t #t) #t <> (or #t #t) #t <> (and #t #f) #f <> (or #t #f) #t <> (and #f #t) #f <> (or #f #t) #t <> (and #f #f) #f <> (or #f #f) #f <> (not #t) #f <> (not #f) #t .. (or #f #t) 08 (#t)\n\nBuilding on the comparison rule above, we can write conditionals with a\nternary statement:\n\n    \n    \n    <> (ife #t ?t ?f) (?t) <> (ife #f ?t ?f) (?f) <> (print ?:) (?:) .. ife #f (print True!) (print False!) 13 (print False!) 14 ()\n\n### Arithmetic\n\nThe language does not accommodate for any specific numerical system, but\nallows for the notion of numbers to be implemented with Peano Numerals:\n\n    \n    \n    <> (add (s ?x) (s ?y)) (s (add ?x (s ?y))) <> (add (s ?x) (0)) (s ?x) <> (add (0) (s ?y)) (s ?y) <> (add (0) (0)) (0) <> (sub (s ?x) (s ?y)) (sub ?x ?y) <> (sub (s ?x) (0)) (s ?x) <> (sub (0) (s ?y)) (s ?y) <> (sub (0) (0)) (0) <> (mul (s ?x) (s ?y)) (add (s ?x) (mul (s ?x) (sub (s ?y) (s (0))))) <> (mul (s ?x) (s (0))) (s ?x) <> (mul (s (0)) (s ?y)) (s ?y) <> (mul (s ?x) (0)) (0) <> (mul (0) (s ?x)) (0)\n\nTo convert from prefix notation to infix:\n\n    \n    \n    <> (?x + ?y) (add ?x ?y) <> (?x - ?y) (sub ?x ?y) <> (?x * ?y) (mul ?x ?y)\n\nAltogether, we have enough parts to implement factorial:\n\n    \n    \n    <> (factorial (s (0))) ((s (0))) <> (factorial (s ?x)) (((s ?x) * factorial ((s ?x) - (s (0))))) factorial (s (s (s (s (s (0))))))\n\n### Binary\n\nPrefix rules to increment a binary number:\n\n    \n    \n    <> (inc (0 ?x)) ((1 ?x)) <> (inc (1 ?x)) ((0 inc ?x)) <> (inc ()) ((1 ())) ?(?-) (Count to 0x7f) <> (> increc (1 (1 (1 (1 ()))))) (done.) <> (> increc ?i) (> (inc ?i wait) increc) <> (> (?i wait) increc) (> increc ?i) > increc ()\n\n### Mimics\n\nWe can use rules to define entire languages, Modal enforces no specific\nnotation, for example, we could easily make a combinatory logic playground:\n\n    \n    \n    <> (M ?x) (?x ?x) <> (KI ?x ?y) (?y) <> (T ?x ?y) (?y ?y) <> (W ?x ?y) (?x ?y ?y) <> (K ?x ?y) (?x) <> (C ?x ?y ?z) (?x ?z ?y) <> (B ?x ?y ?z) (?x (?y ?z)) <> (I ?x) (?x) <> (S ?x ?y ?z) (?x ?z (?y ?z)) .. C KI x y z 05 KI y x z 01 x z\n\nAny choice made in regard to syntax is completely arbitrary. To demonstrate,\nthe following code defines a concatenative syntax:\n\n    \n    \n    <> (?x dup) (?x ?x) <> (?x ?y swap) (?y ?x) <> (?x pop) () .. (1 2 3) (4 5 6) swap pop dup 01 (4 5 6) (1 2 3) pop dup 02 (4 5 6) dup 00 (4 5 6) (4 5 6)\n\nHomoiconicity is a property of some programming languages that treats code as\ndata, when the internal and external representation of a program is the same.\nModal is homoiconic, as any string is a potential program and new rules can be\ncomposed directly during the evaluation. For instance, here is a rule to\ndefine new rules with an infix syntax:\n\n    \n    \n    <> ((?x -> ?y)) (<> ?x ?y) (a -> apple) (b -> banana) ((apple banana) -> (fruit-salad)) .. a b 01 apple b 02 apple banana 03 fruit-salad\n\n### Implementation\n\nThe Modal runtime can be implemented in about 200 lines of ANSI C.\n\n    \n    \n    cc modal.c -o modal view raw\n\n  * view sources, ANSI C.\n  * discord channel, in the concatenative server.\n  * Original creation of wryl, many of the code above is their own work and merely made available here as to give this fantastic system a home on the internet.\n\nDevine Lu Linvega \u00a9 2023 \u2014 BY-NC-SA 4.0\n\n", "frontpage": true}
