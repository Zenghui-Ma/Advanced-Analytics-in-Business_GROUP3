{"aid": "40145265", "title": "How quickly can you break a long string into lines?", "url": "https://lemire.me/blog/2024/04/19/how-quickly-can-you-break-a-long-string-into-lines/", "domain": "lemire.me", "votes": 1, "user": "greghn", "posted_at": "2024-04-24 15:08:15", "comments": 0, "source_title": "How quickly can you break a long string into lines?", "source_text": "How quickly can you break a long string into lines? \u2013 Daniel Lemire's blog\n\nSkip to content\n\nDaniel Lemire's blog\n\nDaniel Lemire is a computer science professor at the Data Science Laboratory\nof the Universit\u00e9 du Qu\u00e9bec (T\u00c9LUQ) in Montreal. His research is focused on\nsoftware performance.\n\n## Support my work!\n\nI do not accept any advertisement. However, you can you can sponsor my open-\nsource work on GitHub.\n\nJoin over 12,500 email subscribers:\n\nYou can follow this blog on telegram. You can find me on twitter as @lemire or\non Mastodon.\n\n## Recent Posts\n\n## Recent Comments\n\n## Pages\n\n## Archives\n\n## Boring stuff\n\n# How quickly can you break a long string into lines?\n\nSuppose that you receive a long string and you need to break it down into\nlines. Consider the simplified problems where you need to break the string\ninto segments of (say) 72 characters. It is a relevant problem if your string\nis a base64 string or a Fortran formatted statement.\n\nThe problem could be a bit complicated because you might need consider the\nsyntax. So the speed of breaking into a new line every 72 characters\nirrespective of the content provides an upper bound on the performance of\nbreaking content into lines.\n\nThe most obvious algorithm could be to copy the content, line by line:\n\n    \n    \n    void break_lines(char *out, const char *in, size_t length, size_t line_length) { size_t j = 0; size_t i = 0; for (; i + line_length <= length; i += line_length) { memcpy(out + j, in + i, line_length); out[j+line_length] = '\\n'; j += line_length + 1; } if (i < length) { memcpy(out + j, in + i, length - i); } }\n\nCopying data in blocks in usually quite fast unless you are unlucky and you\ntrigger aliasing. However, allocating a whole new buffer could be wasteful,\nespecially if you only need to extend the current buffer by a few bytes.\n\nA better option could thus be to do the work in-place. The difficulty is that\nif you load the data from the current array, and then write it a bit further\naway, you might be overwriting the data you need to load next. A solution is\nto proceed in reverse: start from the end... move what would be the last line\noff by a few bytes, then move the second last line and so forth. Your code\nmight look like the following C function:\n\n    \n    \n    void break_lines_inplace(char *in, size_t length, size_t line_length) { size_t left = length % line_length; size_t i = length - left; size_t j = length + length / line_length - left; memmove(in + j, in + i, left); while (i >= line_length) { i -= line_length; j -= line_length + 1; memmove(in + j, in + i, line_length); in[j+line_length] = '\\n'; } }\n\nI wrote a benchmark. I report the results only for a 64KB input. Importantly,\nmy numbers do not include memory allocation which is separate.\n\nA potentially important factor is whether we allow function inlining: without\ninlining, the compiler does not know the line length at compile-time and\ncannot optimize accordingly.\n\nYour results will vary, but here are my own results:\n\nmethod| Intel Ice Lake, GCC 12| Apple M2, LLVM 14  \n---|---|---  \nmemcpy| 43 GB/s| 70 GB/s  \ncopy| 25 GB/s| 40 GB/s  \ncopy (no inline)| 25 GB/s| 37 GB/s  \nin-place| 25 GB/s| 38 GB/s  \nin-place (no inline)| 25 GB/s| 38 GB/s  \n  \nIn my case, it does not matter whether we do the computation in-place or not.\nThe in-place approach generates more instructions but we are not limited by\nthe number of instructions.\n\nAt least in my results, I do not see a large effect from inlining. In fact,\nfor the in-place routine, there appears to be no effect whatsoever.\n\nRoughly speaking, I achieve a bit more than half the speed as that of a memory\ncopy. We might be limited by the number of loads and stores. There might be a\nclever way to close the gap.\n\nDaniel Lemire, \"How quickly can you break a long string into lines?,\" in\nDaniel Lemire's blog, April 19, 2024.\n\n## Published by\n\n### Daniel Lemire\n\nA computer science professor at the University of Quebec (TELUQ). View all\nposts by Daniel Lemire\n\nPosted on April 19, 2024April 22, 2024Author Daniel LemireCategories\n\n## 2 thoughts on \u201cHow quickly can you break a long string into lines?\u201d\n\n  1. -.- says:\n\nApril 20, 2024 at 12:34 am\n\nYou might be able to get a bit more throughput by limiting the size range of\ncopies, ignoring overshoot, instead of arbitrary sized memcpy/memmove.\nExample:\n\ntemplate __attribute__((target(\u201cavx2\u201d))) inline void break_lines_fixlen(char\n*out, const char *in, size_t length, size_t line_length) { if(line_length\nll_max) { break_lines(out, in, length, line_length); return; }\n\nsize_t j = 0; size_t i = 0; for (; i + ll_max <= length;) { std::memcpy(out +\nj, in + i, ll_max); out[j+line_length] = '\\n'; j += line_length + 1; i +=\nline_length; } if (i < length) { std::memcpy(out + j, in + i, length \u2013 i); } }\n\nI definitely do get better throughput for the inplace variant, on a i7 12700K:\n\nsize 65536 copy : 23.41 GB/s 0.4 Ma/s 2800.00 ns/d copy_fixlen : 24.27 GB/s\n0.4 Ma/s 2700.00 ns/d memcpy : 59.58 GB/s 0.9 Ma/s 1100.00 ns/d inplace :\n43.69 GB/s 0.7 Ma/s 1500.00 ns/d inplace_fixlen : 46.81 GB/s 0.7 Ma/s 1400.00\nns/d\n\n(`_fixlen` variants use as the range)\n\nReply\n\n    1. -.- says:\n\nApril 20, 2024 at 12:36 am\n\nUrgh, messed up formatting \u2013 try https://pastebin.com/fW3RAzdr\n\nThe range for _fixlen used is 64,80\n\nReply\n\n### Leave a Reply Cancel reply\n\nYou may subscribe to this blog by email.\n\nTerms of use Proudly powered by WordPress\n\n", "frontpage": false}
