{"aid": "40159306", "title": "RAG with Access Control", "url": "https://www.pinecone.io/learn/rag-access-control/", "domain": "pinecone.io", "votes": 2, "user": "ogazitt", "posted_at": "2024-04-25 16:09:36", "comments": 0, "source_title": "RAG with Access Control | Pinecone", "source_text": "RAG with Access Control | Pinecone\n\nOpens in a new window Opens an external website Opens an external website in a\nnew window\n\nThis website utilizes technologies such as cookies to enable essential site\nfunctionality, as well as for analytics, personalization, and targeted\nadvertising purposes. You may change your settings at any time or accept the\ndefault settings. You may close this banner to continue with only essential\ncookies. Cookie Policy\n\nAnnouncementNew serverless free plan with 3x capacityLearn more\n\nLearn\n\n# RAG with Access Control\n\nApr 24, 2024\n\nDeep Dives\n\nRoie Schwaber-Cohen\n\nDeveloper Advocate\n\nAccess Control plays a critical role in almost every user facing application,\nbut especially in scenarios where sensitive information is involved. It plays\nan instrumental role in guarding sensitive information, ensuring that it\nremains within the reach of only those individuals who have been granted the\nrequired permissions.\n\nIn the case of RAG applications, it's quite possible that not every user is\ngranted equal access to all indexed documents. Certain pieces of information\ncould be of a confidential nature, accessible only to specific roles or\ndesignated individuals - and it\u2019s critical that our RAG application doesn\u2019t\nleak any sensitive information. This highlights the necessity for strong and\neffective access control mechanisms. By preventing unauthorized access, these\nmechanisms help retain the confidentiality of data.\n\nIn Pinecone, you could use metadata to associate users and roles with specific\nvectors, but this doesn\u2019t satisfy the core architectural tenant of separation\nof concerns: systems shouldn\u2019t be overloaded with \u201cforeign\u201d consideration, if\nit could be avoided. As we\u2019ll explore in this post, RAG use cases are ideal\nfor a post-query filtering flow, and this flow lends itself to managing the\nauthorization mechanism outside of the database itself.\n\n### Authentication and Authorization\n\nBefore we jump into the specific implementation of access control for RAG\napplication, let\u2019s take a moment to talk about its components, namely\nauthentication and authorization.\n\n  * Authentication is the process of verifying a user's identity. This usually involves the user providing some form of credentials, like a username and password. If the credentials match what's stored in the system, the user is authenticated and granted access.\n  * Authorization is the process of determining which resources are available to a given identity. There are several popular paradigms used for authorization:\n\n    * Access control lists (ACL) - access to a resource is determined by the list of users that are granted permissions to it. This is a simple model that is easy to understand and implement, but it can become difficult to manage as the number of users and resources grows.\n    * Role based access control (RBAC) - access is granted based on the role of the user. For example, an 'admin' role might have access to everything, while a 'guest' role might have very limited access. This model is more flexible and scalable than ACL, but it can still be complex to manage.\n    * Attribute based access control (ABAC) - access is granted based on a combination of attributes. These attributes can be associated with the user (like role, department, location), the resource (like type, sensitivity, location), the action (like read, write, delete), and the context (like time, network, device). This model offers the most flexibility and scalability, but it can also be the most complex to manage.\n    * Relationship based access control (ReBAC) - a more recent model where access is granted based on the relationships between the user and the resources. For example, in a social networking application, a user might have access to resources that are 'connected' to them in some way (like friends, followers, etc). This model can handle complex access control scenarios, but it can also be complex to implement and manage.\n\n### Access control for RAG applications\n\nNow that we have a good idea of what authentication and authorization are,\nlet\u2019s see how we can apply them in the context of a RAG application. Roughly\nspeaking, we can break down any RAG system into two phases: ingestion and\nquerying.\n\n  * During the ingestion phase, we\u2019ll have to associate the identities known to our system with the resources they are allowed to access.\n  * During the querying phase, we\u2019ll have to resolve which of the documents an identity attempts to access are allowed and which can\u2019t be included in the final response.\n\nIn order to demonstrate a rudimentary authorization flow for RAG application,\nwe\u2019ll apply the ReBAC model, and here\u2019s why: RBAC and ABAC are mostly geared\ntowards managing application resources such as endpoints. For example, when we\nbuild an application and we want to determine which user or role can carry out\na particular action that maps to an endpoint. In the case of RAG, the\npredominant pattern for authorization is filtering the results after the query\nis executed. This requires us to create relations between users or roles and\nresources.\n\nPractically speaking, for a set of documents, we\u2019ll define a set of possible\ncategories. We\u2019ll assign users in our system to those categories, and allow\nthem to access only the documents which belong to their assigned categories.\n\nWe\u2019ll use the same RAG application we covered in our a previous post, and\nextend it with authentication and authorization capabilities (full code\nlisting).\n\nTo facilitate the authentication and authorization processes, we\u2019ll use two\nservices:\n\n  1. Clerk - a user authentication platform that developers can use to manage user access in their applications. It provides features such as sign-in services, two-factor authentication, session management, and user management, helping secure your application and protect user data.\n  2. Aserto - a permissions-as-a-service platform that developers can use to incorporate authorization into their applications. It provides features such as policy-based permissions, role-based and attribute access control, as well as relationship-based access control - making it easier to manage who has access to what in your application.\n\nFirst, we sign up for a Clerk account and create a set of users:\n\nWe want to flag the \u201cAdmin\u201d user as having some extra permissions here, so\nwe\u2019ll add some private metadata to the user entry:\n\nFor the purposes of this example, the admin will be the user with the ability\nto assign categories to specific users. In more realistic scenarios, we\u2019ll\nprobably want to associate a category with a role or a group as opposed to a\nuser - more on that later.\n\nWhen the admin user is logged in to the application, they\u2019ll see the following\ncontrol:\n\nThis will allow them to select which categories are assigned to each user.\n\nNext, we\u2019ll need to associate the identities of each user with the documents\nwe\u2019re going to index. We\u2019ll do this using Aserto\u2019s directory service.\n\n\ud83d\udca1 The Aserto Directory\n\nThe Aserto Directory stores information required to make authorization\ndecisions. It is flexible enough to easily support different access control\nstrategies including Role-Based Access Control (RBAC), Attribute-Based Access\nControl (ABAC), and Relationship-Based Access Control (ReBAC).\n\nAn authorization decision is an answer to the question \"Is subject S allowed\nto perform action A on resource R?\" In other words, authorization decisions\ndetermine whether a subject (user, group, service, etc.) has a given\npermission on a resource (document, folder, project, etc.).\n\nIt is convenient to think of the Aserto Directory as a graph in which objects\nare the nodes and relations the edges. Under this model, the authorization\nquestion in the previous section can be rephrased again as \"Is there a path\nfrom the node S to the node R in which one or more edges have permission P?\"\n\nFor example, a resource object type can define the can_read, can_write, and\ncan_delete permissions, and have these granted through the owner, editor, and\nviewer relations.\n\nAdditionally, we can define permissions: A permission represents a kind of\naction that a subject may perform on a resource. Similar to relations, each\npermission is defined in the manifest as part of an object type definition.\n\nUnlike relations, permissions cannot be assigned explicitly. They are granted\nindirectly by combining relations and/or other permissions using permission\noperators.\n\nAserto allows us to define our authorization model in a manifest file:\n\n    \n    \n    # yaml-language-server: $schema=https://www.topaz.sh/schema/manifest.json --- # model model: version: 3 # object type definitions types: # user represents a user that can be granted role(s) user: relations: manager: user # group represents a collection of users and/or (nested) groups group: relations: member: user | group#member # identity represents a collection of identities for users identity: relations: identifier: user # resource creator represents a user type that can create new resources resource-creator: relations: member: user | group#member permissions: can_create_resource: member # resource represents a protected resource resource: relations: owner: user writer: user | group#member reader: user | group#member permissions: can_read: reader | writer | owner can_write: writer | owner can_delete: owner\n\nHere\u2019s a visualization of this manifest file:\n\nWhen creating a new project with Aserto, we can start with this initial model\nthat can be useful in a variety of use cases. Naturally model can evolve as\nour application changes and grows over time.\n\n## Ingestion\n\nAs with other RAG ingestion processes, we iterate over each document, embed it\nand upsert it into Pinecone. But in our case, we will also associate the\ndocument with its category and we\u2019ll create a relationship between the\ndocuments and the users in the system, based on the mapping we get from the\napplication.\n\n    \n    \n    const index = pinecone.Index(indexName) const vectors = await Promise.all(documents.flat().map(embedDocument)); await Promise.all(Object.keys(usersDataAssignment).map(async (userId) => { const userVectors = filterRecordsByUserAssignments(userId, vectors, usersDataAssignment) const userObject = await clerkClient.users.getUser(userId); return assignRelation(userObject, userVectors, 'owner'); })); // Upsert vectors into the Pinecone index await chunkedUpsert(index, vectors, '', 10);\n\nIn this bit of code, we iterate over the userDataAssignment that associates\neach user in the system with the categories they are allowed to view. We\nfilter all the vectors we created and associate those vectors with their\ncorresponding user.\n\nLet\u2019s look at the function which creates the relationship between a user and a\ndocument:\n\n    \n    \n    export const assignRelation = async (user: User, documents: PineconeRecord<CategorizedRecordMetadata>[], relationName: string) => { // Map each document to a set of operations for setting up user-document relations const operations = documents.map((document) => { // Construct a display name for the user const userName = `${user.firstName}${user.lastName ? ' ' : ''}${user.lastName ?? ''}` // Create a user object for the directory service const userObject = { id: user.id, type: 'user', properties: objectPropertiesAsStruct({ email: user.emailAddresses[0].emailAddress, name: userName, picture: user.imageUrl, }), displayName: userName }; // Create a document object for the directory service const documentObject = { id: document.id, type: 'resource', properties: document.metadata ? objectPropertiesAsStruct({ url: document.metadata.url, category: document.metadata.category, }) : objectPropertiesAsStruct({}), displayName: document.metadata && document.metadata.title ? document.metadata.title as string : '', }; // Define the relation between the user and the document const userDocumentRelation = { subjectId: user.id, subjectType: 'user', objectId: document.id, objectType: 'resource', relation: relationName, }; // Operations to set the user and document objects in the directory const objectOperations: any[] = [ { opCode: ImportOpCode.SET, msg: { case: ImportMsgCase.OBJECT, value: userObject, }, }, { opCode: ImportOpCode.SET, msg: { case: ImportMsgCase.OBJECT, value: documentObject, }, } ]; // Operation to set the relation between the user and the document const relationOperation: any = { opCode: ImportOpCode.SET, msg: { case: ImportMsgCase.RELATION, value: userDocumentRelation, }, }; // Combine object and relation operations return [...objectOperations, relationOperation]; }).flat(); try { // Create an async iterable from the operations and import them to the directory service const importRequest = createAsyncIterable(operations); const resp = await directoryClient.import(importRequest); // Read and return the result of the import operation const result = await (readAsyncIterable(resp)) return result } catch (error) { // Log and rethrow any errors encountered during the import console.error('Error importing request: ', error); throw error; } }\n\n## Application\n\nTo enforce the relationship between user and the documents they have access\nto, we create a function which will perform a checkPermission call against the\ndirectory for a particular Permission:\n\n    \n    \n    export const getFilteredMatches = async (user: User | null, matches: ScoredPineconeRecord[], permission: Permission) => { // Check if a user object is provided if (!user) { console.error('No user provided. Returning empty array.') return []; } // Perform permission checks for each match concurrently const checks = await Promise.all(matches.map(async (match) => { // Construct permission request object const permissionRequest = { subjectId: user.id, // ID of the user requesting access subjectType: 'user', // Type of the subject requesting access objectId: match.id, // ID of the object access is requested for objectType: 'resource', // Type of the object access is requested for permission: 'can_read', // Specific permission being checked } // Check permission for the constructed request const response = await directoryClient.checkPermission(permissionRequest); // Return true if permission granted, false otherwise return response ? response.check : false })); // Filter matches where permission check passed const filteredMatches = matches.filter((match, index) => checks[index]); // Return matches that passed the permission check return filteredMatches }\n\nThe permission checks for each subject, object and permission triple takes a\nfraction of a millisecond, which ensures the performance of the application\noverall.\n\nThis function is called in the getContext function, which retrieved the\nrelevant documents and then filters the matches based on the permission we\nset.\n\n    \n    \n    export const getContext = async ({ message, namespace, maxTokens = 3000, minScore = 0.95, getOnlyText = true, user }: { message: string, namespace: string, maxTokens?: number, minScore?: number, getOnlyText?: boolean, user: User | null }): Promise<ContextResponse> => { // Get the embeddings of the input message const embedding = await getEmbeddings(message); // Retrieve the matches for the embeddings from the specified namespace const matches = await getMatchesFromEmbeddings(embedding, 10, namespace); // Filter out the matches that have a score lower than the minimum score const qualifyingDocs = matches.filter(m => m.score && m.score > minScore); let noMatches = qualifyingDocs.length === 0; const filteredMatches = await getFilteredMatches(user, qualifyingDocs, Permission.READ); let accessNotice = false if (filteredMatches.length < matches.length) { accessNotice = true } return { documents: qualifyingDocs, accessNotice, noMatches } }\n\nWe want to make sure that the user is aware in case some of the documents that\nexist in the system are not available to them. For that purpose, we compare\nthe number of overall found matches to the number of filtered matches. We also\ntake note if no matches were found at all.\n\nFinally, we just need to send the information back to the client. We\u2019ll\nattached the access information to the data sent back as part of the context:\n\n    \n    \n    const { documents, accessNotice, noMatches } = context; data.append({ context: [...documents as PineconeRecord[]], accessNotice, noMatches });\n\nWe\u2019re now ready to test the authorization mechanism. In our application, we\u2019ll\nlog in using the identity we associated with the finance category, and as it\nabout the finance department:\n\nWe\u2019ll ask the same question but with the user associated with the hr category,\nwho shouldn\u2019t have access to finance related topics:\n\nAs expected, we get an indication that some results couldn\u2019t be used to\ncompose the question, and the content we did get didn\u2019t actually have anything\nto do withe the topic of our question.\n\n## Summary\n\nThe significance of access control mechanisms within the realm of RAG\napplications can\u2019t be understated. The task of managing sensitive information\nis no small feat, and that's where services such as Aserto and Clerk can make\nthis process a lot easier. The prevailing authorization pattern for databases\nis to filter the results after the query is executed. In some cases, this\nmight not be feasible, but in the RAG use case this is actually a great fit:\nwe usually don\u2019t query for more the tens of results at a time, and filtering\nthrough those using services like Aserto is completely feasible in terms of\nlatency.\n\nShare via:\n\n#### Further Reading\n\nYour Guide to Vectorizing Structured Text\n\nAdvanced RAG Techniques\n\nManage Serverless Costs with Read Units\n\nRoie Schwaber-Cohen\n\nDeveloper Advocate\n\n  * Ingestion\n  * Application\n  * Summary\n\nShare via:\n\nProduct\n\nOverviewDocumentationIntegrationsTrust and Security\n\nSolutions\n\nCustomersRAGSemantic SearchMulti-Modal SearchCandidate\nGenerationClassification\n\nResources\n\nLearning CenterCommunityPinecone BlogSupport CenterSystem StatusWhat is a\nVector Database?What is Retrieval Augmented Generation (RAG)?\n\nCompany\n\nAboutPartnersCareersNewsroomContact\n\nLegal\n\nTermsPrivacyCookiesCookie Preferences\n\n\u00a9 Pinecone Systems, Inc. | San Francisco, CA\n\nPinecone is a registered trademark of Pinecone Systems, Inc.\n\n", "frontpage": false}
