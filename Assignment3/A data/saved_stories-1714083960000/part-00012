{"aid": "40159278", "title": "Show HN: I made a programmable computer from NAND gates", "url": "https://github.com/ArhanChaudhary/NAND", "domain": "github.com/arhanchaudhary", "votes": 12, "user": "ArchAndStarch", "posted_at": "2024-04-25 16:08:05", "comments": 0, "source_title": "GitHub - ArhanChaudhary/NAND: NAND is a logic simulator suite made entirely from NAND gates", "source_text": "GitHub - ArhanChaudhary/NAND: NAND is a logic simulator suite made entirely\nfrom NAND gates\n\nSkip to content\n\n## Navigation Menu\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nArhanChaudhary / NAND Public\n\n  * Notifications\n  * Fork 1\n  * Star 11\n\nNAND is a logic simulator suite made entirely from NAND gates\n\nnand.arhan.sh/\n\n### License\n\nMIT license\n\n11 stars 1 fork Branches Tags Activity\n\nStar\n\nNotifications\n\n# ArhanChaudhary/NAND\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n2 Branches\n\n0 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nArhanChaudharyreword some stuffApr 24, 2024e5d0550 \u00b7 Apr 24, 2024Apr 24, 2024\n\n## History\n\n1,032 Commits  \n  \n### .github\n\n|\n\n### .github\n\n| Accidentally removed wasm-pack installation in github pages config| Feb 18,\n2024  \n  \n### .vscode\n\n|\n\n### .vscode\n\n| readme: Undefined behavior and rewordings everywhere| Apr 22, 2024  \n  \n### media\n\n|\n\n### media\n\n| readme: GeneticAlgorithm and Beyond the Jack OS| Apr 20, 2024  \n  \n### projects\n\n|\n\n### projects\n\n| os: String.intValue should read until the first non-digit character| Apr 18,\n2024  \n  \n### src\n\n|\n\n### src\n\n| reword some stuff| Apr 24, 2024  \n  \n### .gitattributes\n\n|\n\n### .gitattributes\n\n| Revert \"mark jack as java for now\"| Nov 5, 2023  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| Update gitignore configs| Aug 22, 2023  \n  \n### .imgbotconfig\n\n|\n\n### .imgbotconfig\n\n| Fix imgbot config| Apr 20, 2024  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| Create LICENSE| Jan 2, 2024  \n  \n### README.md\n\n|\n\n### README.md\n\n| reword some stuff| Apr 24, 2024  \n  \n### TODO.md\n\n|\n\n### TODO.md\n\n| readme: First draft complete| Apr 22, 2024  \n  \n## Repository files navigation\n\nN ot A N and-powered D evice\n\nis a Turing equivalent 16-bit computer made entirely from a clock and NAND\ngates emulated on the web. NAND features its own CPU, machine code language,\nassembly language, assembler, virtual machine language, virtual machine\ntranslator, programming language, compiler, IDE, and user interface. NAND is\nbased on the Jack-VM-Hack platform specified in the Nand to Tetris course and\nits associated book.\n\n### Table of Contents\n\n  * Example programs\n\n    * Average\n    * Pong\n    * 2048\n    * Overflow\n    * SecretPassword\n    * GeneticAlgorithm\n  * Writing programs for NAND\n\n    * Jack Introduction\n    * Custom Data Types\n    * Weak Type Coercions\n    * Manual Memory Management\n    * Undefined Behavior\n\n      * Operator Priority\n      * Lesser and Greater than Operators\n      * -32768\n      * Calling a Function with Too Few Arguments\n      * Improper Type Casting\n      * Stack Overflows\n      * Modifying Stack Frames or Internal Registers\n    * Hardware Specification\n    * Beyond the Jack OS\n  * How does NAND work?\n  * Jack Reference\n\n    * Program Structure\n    * Syntax\n    * Variables\n    * Statements\n  * Jack OS Reference\n\n    * Array\n    * Keyboard\n    * Math\n    * Memory\n    * Output\n    * Screen\n    * String\n    * Sys\n    * Error Codes\n  * FAQ\n\n    * Whoa, is everything made from NAND gates?\n    * Did you design NAND by yourself?\n    * If there's only one type, what is the point of specifying types at all?\n    * Why does the IDE feel finnicky?\n\n# Example programs\n\n### Average\n\nA simple program that inputs some numbers and computes their average, showing\noff control flow, arithmetic operations, I/O, and dynamic memory allocation.\n\nProgram output:\n\n    \n    \n    How many numbers? 4 Enter a number: 100 Enter a number: 42 Enter a number: 400 Enter a number: 300 The average is 210\n\nThis program was supplied by the Nand to Tetris software suite.\n\n### Pong\n\nThe game of Pong, showing off the language's object-oriented model. Use the\narrow keys to move the paddle left and right to bounce a ball. Every bounce,\nthe paddle becomes smaller, and the game ends when the ball hits the bottom of\nthe screen.\n\nThis program was supplied by the Nand to Tetris software suite.\n\n### 2048\n\nThe game of 2048, showing off recursion and complex application logic. Use the\narrow keys to move the numbers around the 4x4 grid. The same numbers combine\ninto their sum when moved into each other. Once the 2048 tile is reached, you\nwin the game, though you can keep playing on until you lose. You lose the game\nwhen the board is full and you can't make any more moves.\n\n### Overflow\n\nA program that deliberately causes a stack overflow via infinite recursion to\nperform a virtual machine escape. It leverages the fact that there are no\nruntime checks to prevent a stack overflow. No other modern platform will let\nyou do this :-)\n\nUpon running, the program will constantly print the stack pointer to the\nscreen. Once this displayed value exceeds 2048, the stack will have reached\nthe end of its intended memory space and spill onto the heap memory space,\ncausing the print statement to malfunction in explosive fashion:\n\nTwo things of noteworthy interest are worth pointing out.\n\nIf you reload the page and run this program on an empty RAM (a RAM full of\nzeroes), you will notice that the program resets itself halfway through its\nexecution despite not pressing the \"Reset\" button. Why this happens is simple:\nthe jailbroken runtime executes an instruction that sets the program counter's\nvalue to 0, effectively telling the program to jump to the first instruction\nand start over.\n\nIf you run the GeneticAlgorithm example program and then run this immediately\nafterwards, the program in its rampage reads old RAM memory that was simply\nnever overwritten.\n\n### SecretPassword\n\nA program that exploits the fact that the runtime doesn't prevent stack\nsmashing to call a function that would otherwise be inaccessible. In order to\nunderstand how this works, let's examine this illustration of NAND's stack\nframe layout.\n\ntaken from the Nand to Tetris book.\n\nIf you're unfamiliar with stack layouts, here's the main idea behind the\nexploit. Whenever a function returns, it needs to know where (which machine\ncode instruction memory address) it should go to proceed with execution flow.\nSo, when the function is first called, this memory address, along with some\nother unimportant data, is temporarily stored on the stack in a memory region\nreferred to as the stack frame as a reference for where to return. The\nillustration describes the exact position of this return address relative to\nthe function call, a position that can be reverse engineered.\n\nThe program enables the user to overwrite a single memory address in the RAM\nto any value. Putting two and two together, if the user were to overwrite the\nreturn address of a stack frame with the address of another function, they\nessentially gain the ability to execute arbitrary code included in the\nprogram.\n\nIndeed, if you enter 267 as the memory location and 1715 as the value to\noverwrite, two numbers reverse engineered by manually inspecting the stack\nmemory space and the assembler, you'll see this idea in working action.\n\nThis isn't a vulnerability unique to NAND. It exists in C as well! How cool!\n\n### GeneticAlgorithm\n\nBelieve it or not, out of the many, many different components of NAND, this\nsingle-handedly took the longest to develop!\n\nThis program is a creature simulation that utilizes simple machine learning.\nIt follows the artificial intelligence coded series (parts one and two) from\nCode Bullet. Make sure to check out his channel, he makes some really cool\nstuff!\n\nSimply explained:\n\nEvery dot has its own \"brain\" of acceleration vectors, and they evolve to\nreach a goal through natural selection. Every generation, dots that \"die\"\ncloser to the goal are more likely to be selected as the parents for the next\ngeneration. Reproduction inherently causes some of the brain to mutate, wholly\neffectively simulating natural evolution.\n\nNevertheless, there is much to be desired. Due to performance, the only factor\ndots use to evolve is their closeness to the goal upon death, endowing the\nnatural selection algorithm with low entropy. Due to memory usage, there are\nsmaller than satisfactory limits on the number of dots and the sizes of their\nbrains. Lastly, due to technical complexity, re-placing obstacles during the\nsimulation does not guarantee that the dots will have large enough brains to\nreach the goal. Brain sizes are only determined at the beginning of the\nprogram.\n\nI've utilized a myriad of optimization techniques to snake around the\nfollowing hardware restrictions and make this possible:\n\n  * NAND has a limited ROM memory space, meaning the program won't compile if there's too much code. In fact, the final version of this program uses 99.2% of the instruction memory space.\n  * NAND has a limited RAM memory space, meaning the program has to be careful to optimize heap memory usage. In fact, the reason why the screen fills with static between generations is to use the screen memory space as temporary swap memory for the next generation \u2014 the RAM is already completely full!\n  * NAND has no floating point type (decimal numbers) and can only represent the integers between -32768 and 32767, making calculating fitness less precise and more challenging to implement. Integer overflows must also be accounted for.\n\nTo avoid beating around the bush, I've stuck to documenting these techniques\nand additional insights in this program's codebase for those interested.\n\n# Writing programs for NAND\n\nBefore we start, the most important detail to remember about writing programs\nin Jack is that there is no operator priority; this is probably why your\nprogram isn't working.\n\nFor example, you should change: 4 * 2 + 3 to (4 * 2) + 3 if (~x & y) to if\n((~x) & y)\n\nbut you can keep if (y & ~x) the same as there is no operator ambiguity.\n\nWithout parenthesis, the evaluation value of an ambiguous expression is\nundefined.\n\n### Jack Introduction\n\nNAND boasts its own complete tech stack. As a consequence, NAND can only be\nprogrammed in Jack, its weakly typed object-oriented programming language. In\nlayman's terms, Jack is C with Java's syntax.\n\nLet's take the approach of example-based learning and dive right in.\n\n    \n    \n    /** * This program prompts the user to enter a phrase * and an energy level. Program output: * * Whats on your mind? Superman * Whats your energy level? 3 * Superman! * Superman! * Superman! */ class Main { function void main() { var String s; var int energy, i; let s = Keyboard.readLine(\"Whats on your mind? \"); let energy = Keyboard.readInt(\"Whats your energy level? \"); let i = 0; let s = s.appendChar(33); // Appends the character '!' while (i < energy) { do Output.printString(s); do Output.println(); let i = i + 1; } } }\n\ntaken from the Nand to Tetris lecture slides.\n\nIf you've already had some experience with programming, this should look very\nfamiliar; it is clear that Jack was heavily inspired by Java. Main.main is the\nentry point to the program. The code segment demonstrates basic usage of\nvariables as well as the while loop for control flow.\n\nAdditionally, it uses Keyboard.readLine and Keyboard.readInt to read input\nfrom the user, and Output.printString and Output.println to print output to\nthe screen \u2014 all of which are defined in detail in the Jack OS Reference. By\ndefault, the Jack OS is bundled with your program during compilation to enable\ninterfacing with strings, memory, hardware, and more.\n\n### Custom Data Types\n\nEvery programming language has a fixed set of primitive data types. Jack\nsupports three: int, char, and boolean. You can extend this basic repertoire\nwith your own abstract data types as needed. Prior knowledge about object-\noriented programming directly carries over to this section.\n\n    \n    \n    /** Represents a point in 2D plane. */ class Point { // The coordinates of the current point instance: field int x, y; // The number of point objects constructed so far: static int pointCount; /** Constructs a point and initializes it with the given coordinates */ constructor Point new(int ax, int ay) { let x = ax; let y = ay; let pointCount = pointCount + 1; return this; } /** Returns the x coordinate of the current point instance */ method int getx() { return x; } /** Returns the y coordinate of the current point instance */ method int gety() { return y; } /** Returns the number of Points constructed so far */ function int getPointCount() { return pointCount; } /** Returns a point which is this point plus the other point */ method Point plus(Point other) { return Point.new(x + other.getx(), y + other.gety()); } /** Returns the Euclidean distance between the current point instance and the other point */ method int distance(Point other) { var int dx, dy; let dx = x - other.getx(); let dy = y - other.gety(); return Math.sqrt((dx * dx) + (dy * dy)); } /** Prints the current point instance, as \"(x, y)\" */ method void print() { var String tmp; let tmp = \"(\"; do Output.printString(tmp); do tmp.dispose(); do Output.printInt(x); let tmp = \", \"; do Output.printString(tmp); do tmp.dispose(); do Output.printInt(y); let tmp = \")\"; do Output.printString(tmp); do tmp.dispose(); } }\n    \n    \n    var Point p1, p2, p3; let p1 = Point.new(1, 2); let p2 = Point.new(3, 4); let p3 = p1.plus(p2); do p3.print(); // prints (4, 6) do Output.println(); do Output.printInt(p1.distance(p2)); // prints 5 do Output.println(); do Output.printInt(getPointCount()); // prints 3\n\ntaken from the Nand to Tetris lecture slides.\n\nWe define a Point class to represent an abstract point in space. It uses field\nvariables to declare per-instance attributes of the data type. It exposes\npublic method functions we can use to interface with the point, giving the\ncaller the functionality to add two points together and calculate the distance\nbetween two points.\n\nAll field variables are privately scoped. If you wish to get or set these\nvariables from outside the class declaration, these variables must have\ncorresponding method functions to provide this functionality.\n\nOmitted from the code sample to stay on-topic, it is customary for data\nclasses to define dispose methods for deallocation once objects are no longer\nneeded. See Manual Memory Management.\n\nIf needed, here's a reference for function and method calling syntax.\n\n    \n    \n    class Foo { ... method void f() { var Bar b; // Declares a local variable of class type Bar var int i; // Declares a local variable of primitive type int do g(); // Calls method g of the current class on the current object instance // Note: Cannot be called from within a function (static method) do Foo.p(3); // Calls function p of the current class; // Note: A function call must be preceded by the class name do Bar.h(); // Calls function h of class Bar let b = Bar.r(); // Calls function or constructor r of class Bar do b.q(); // Calls method q of class Bar on the b object } }\n\ntaken from the Nand to Tetris lecture slides.\n\n### Weak Type Coercions\n\nRemember how we said Jack was similar to Java? That was a facade, or at best\nmisleading. While Java is strongly-typed and as such supports complex type\nfeatures such as down casting, polymorphism, and inheritance, Jack supports\nnone of these and only has one type under the hood: the signed 16-bit integer.\nThis is the primary reason why Jack is so weakly-typed. In effect, the\ncompiler won't care if you mix and match different types in assignments and\noperations.\n\n    \n    \n    var char c; var String s; let c = 65; // 'A' // Equivalently let s = \"A\"; let c = s.charAt(0);\n    \n    \n    var Array a; let a = 5000; let a[100] = 77; // RAM[5100] = 77\n    \n    \n    var Array arr; var String helloWorld; let helloWorld = \"Hello World!\" let arr = Array.new(4); // Arrays are not strictly typed let arr[0] = 12; let arr[1] = false; let arr[2] = Point.new(5, 6); let arr[3] = helloWorld;\n    \n    \n    class Complex { field int real; field int imaginary; ... } ... var Complex c; var Array a; let a = Array.new(2); let a[0] = 7; let a[1] = 8; let c = a; // c == Complex(7, 8) // Works because it matches the memory layout // of the Complex type\n\nall code segments taken from the Nand to Tetris lecture slides.\n\nDon't take this the wrong way \u2014 Jack still provides a powerful and functional\nobject-oriented model. This insight intends to help you understand when and\nhow you should perform type conversions as needed.\n\n### Manual Memory Management\n\nLet's say you're a crazy cat lover, just like me! And you wanted to write this\nprogram to show off just how much you absolutely adore cats.\n\n    \n    \n    class Main { function void main() { while (true) { do Output.printString(\"Kittens are so adorable! \"); } } }\n\nYou may be startled to notice that after a few seconds, the program will crash\nwith \"ERR6\", or a heap overflow!\n\nJack is a manually memory managed programming language. This means you must be\nvigilant to properly deallocate memory that is no longer needed, or else the\nJack OS will think otherwise and facilitate a memory leak. The best practice\nadvice is to feature a dispose method for each class that represents an object\nthat properly encapsulates this deallocation. Thus, when objects are no longer\nneeded, you can call their dispose methods to ensure you won't eventually run\nout of heap memory.\n\nIf you've programmed in other manually memory managed languages, like C, this\nshould look very familiar. One key difference is the Jack OS stores arrays and\nstrings on the heap rather than on the stack, hinting to why the program\ncrashes with a heap overflow.\n\nLet's fix this program for our fellow feline fanatics.\n\n    \n    \n    class Main { function void main() { var String s; while (true) { let s = \"Kittens are so adorable! \"; do Output.printString(s); do s.dispose(); } } }\n\nAlternatively, you could allocate memory for the string only once.\n\n    \n    \n    class Main { function void main() { var String s; let s = \"Kittens are so adorable! \"; while (true) { do Output.printString(s); } } }\n\nYou'll notice that not only do these alternative versions print the string\nmuch faster, but this time they'll actually print forever! Hooray!\n\nLet's quickly peek into String.dispose so you can better understand how to\nwrite your own dispose methods.\n\n    \n    \n    method void dispose() { do stringArray.dispose(); do Memory.deAlloc(this); }\n\nArray.dispose called by stringArray\n\n    \n    \n    method void dispose() { do Memory.deAlloc(this); }\n\nProper dispose methods must first appropriately call dispose on their field\nvariables and then finish with do Memory.deAlloc(this); to deallocate the\nobject instance itself.\n\n### Undefined Behavior\n\nWith how primitive Jack and NAND are, footguns within the language are\ninevitable. I've compiled the following instances of undefined behavior you\nshould be aware of, ordered from (in my opinion) most important to least\nimportant.\n\n#### Operator Priority\n\nI found this caveat to be so important that I've moved it towards the\nbeginning of this section.\n\n#### Lesser and Greater than Operators\n\nThe Jack expressions\n\n    \n    \n    a > b a < b\n\nare deceptively simple. They aren't always mathematically correct, and are\nrespectively equivalent to the Java expressions\n\n    \n    \n    ((a - b) & (1 << 15)) == 0 && a != b ((a - b) & (1 << 15)) != 0\n\nWhat's up with the nuance? The virtual machine implementation converts a > b\nto a - b > 0\\. Here's the problem: a - b can overflow :(\n\nWhat does 20000 > -20000 evaluate to? The virtual machine transpiles this to\n20000 - (-20000) > 0 which evaluates to -25336 > 0\\. Unfortunately, the answer\nis false.\n\nHowever, 20000 > -10000 evaluates to 30000 > 0, or true.\n\nAs you may have figured, if the absolute distance between a and b is more than\n32767, a > b and a < b are wrong. Otherwise, you're fine.\n\nThis isn't an implementation bug, but rather an inconsistency with Nand to\nTetris itself. More about it here. For compatibility reasons, this behavior\nwon't be fixed.\n\n#### -32768\n\n-32768 is one of its kind. It is the only number that holds the property such that -(-32768) = -32768, a singleton without a positive counterpart^*. This can lead to unsoundness and logic errors.\n    \n    \n    /** * Program output: * --.)*( */ class Main { function void main() { // Note that -32768 must instead be written as ~32767 // because the CPU can't load a number that large do Output.printInt(~32767); } }\n\nOutput.printInt internally expects Math.abs to return a positive number. This\nisn't the case with -32768, so the Jack OS malfunctions.\n\nYour main concern should be handling logic errors with the negative operator.\nAs the programmer, if you want to guarantee the negative of a negative number\nis positive, it is your responsibility to check for the case of -32768 and\ntake appropriate action.\n\n* This holds true because NAND's ALU internally processes the Jack expression -x as ~(x - 1). Let's set x to -32768 and evaluate it step by step. Here are the corresponding 16-bit two's complement binary representations of the computation:\n\nx = 1000 0000 0000 0000 x - 1 = 0111 1111 1111 1111 ~(x - 1) = 1000 0000 0000\n0000 = x\n\nIt's the same thing! What happened here? Because NAND is a 16-bit machine,\n-32768 is the only number such that if you subtract one from it, you get its\nflipped bits. In other words, -32768 satisfies x - 1 = ~x, simplifying the\nexpression to ~(~x) or just x.\n\n#### Calling a Function with Too Few Arguments\n\nThis one is self-explanatory, so here's a brief demonstration.\n\n    \n    \n    /** * Program output: * I have 818 cookies. */ class Main { function void main() { do Main.cookies(); } function void cookies(int a) { do Output.printString(\"I have \"); do Output.printInt(a); do Output.printString(\" cookies.\"); } }\n\nOn the other hand, calling a function with too many arguments is perfectly\nvalid. You can use the arguments keyword to index extra function arguments.\nNote that there is no indicator for the argument count.\n\n#### Improper Type Casting\n\nYou can utilize Array to cast a variable into any other type. Calling instance\nmethods that don't exist on type casted variables is undefined behavior; the\ncompiler isn't smart enough to realize when you're doing this.\n\n    \n    \n    /** * Program output: * 4 */ class Main { constructor Main new() { return this; } function void main() { var Array a; var Main b; var String c; let a = Array.new(1); let b = Main.new(); let a[0] = b; let c = a[0]; // Invalidly calling `String.length` on an instance of `Main`. do Output.printInt(c.length()); } }\n\n#### Stack Overflows\n\nSee the Overflow program for an in-depth example.\n\n#### Modifying Stack Frames or Internal Registers\n\nModifying stack frames or the internal registers that respectively reside at\nmemory addresses 256 to 2047 and 1 to 15 may lead to undefined behavior. This\ntypically isn't possible without misusing Memory.poke or negative array\nindexing. See the SecretPassword program for an in-depth example.\n\n### Hardware Specification\n\nSince its rise in the 1970s, there's a good reason why 16-bit computing has\nfallen from grace in the modern era. Compared to 32-bit or 64-bit computing,\n16-bit computing offered limited processing power and memory capacity that\nsimply weren't meeting the demands of contemporary software and applications.\n\nNAND is no exception to this reality.\n\ntaken from the Nand to Tetris lecture slides.\n\nCompared to your 16 GiB MacBook, NAND enjoys a meager 4 KiB of RAM, a ratio of\n0.00002%! In spite of this, it was enough to take us to the moon, so who's to\nsay NAND can't either.\n\nThe Jack OS reserves 14,336 memory addresses of the 4 KiB for the heap, a\nnumber that is abnormally small. This is why it's so important to ensure\ncomplex Jack applications allocate and deallocate their memory efficiently. If\nyou're overly ambitious, you might run out of heap memory and be forced to\ncompletely rewrite your data types and logic.\n\nThe hardware reserves 8,192 memory addresses of the 4 KiB for the screen. Each\nbit of each address linearly maps to a corresponding pixel on the provided\n512x256 screen, in LSb 0 bit numbering.\n\nThe hardware reserves memory address 24,576 for the keyboard, at which the\ncurrently pressed key is reflected. Though, you shouldn't directly access this\nlocation to handle user input. You should use the provided Keyboard class from\nthe Jack OS and its associated functions.\n\nNAND's keyboard recognizes all ASCII characters, as well as the following\nkeys.\n\n  * new line = 128 = String.newline()\n  * backspace = 129 = String.backspace()\n  * left arrow = 130\n  * up arrow = 131\n  * right arrow = 132\n  * down arrow = 133\n  * home = 134\n  * end = 135\n  * page up = 136\n  * page down = 137\n  * insert = 138\n  * delete = 139\n  * ESC = 140\n  * F1 - F12 = 141 - 152\n\nLastly, the hardware reserves 240 memory addresses for static class variables\nand 1,792 memory addresses for the global stack. Unless you perform deep\nrecursion, you probably won't find these limitations troublesome.\n\n### Beyond the Jack OS\n\nBy default, the Jack OS is bundled with your program during compilation to\nenable interfacing with strings, memory, hardware, and more. To the\nextraordinarily dedicated, it is possible to provide your own OS\nimplementation with your own hardware interfaces. The IDE treats Jack OS files\nthe same as typical program files; they can likewise be deleted or\noverwritten. There are a few core functions you must implement for your\nprogram to compile if you choose to do so. You're free to copy my\nimplementations of these functions as needed.\n\nSys.init: rather than Main.main, this is the real entry point of the program,\nhardcoded in the virtual machine implementation. For context, the provided\nJack OS implementation looks like this:\n\n    \n    \n    function void init() { do Memory.init(); do Math.init(); do Screen.init(); do Screen.clearScreen(); do Output.init(); do Main.main(); do Sys.halt(); }\n\nMemory.alloc: A heap memory allocator internally used by class constructors to\ncreate objects. NAND inherently places emphasis on the heap for data storage,\nso this function is useful in many other contexts too.\n\nString.newWithStr: An internal constructor for string literals.\n\nMath.multiply: This function is internally called in lieu of the\nmultiplication operator *. In other words, the Jack expression x * y and\nMath.multiply(x, y) are equivalent.\n\nMath.divide: This function is internally called in lieu of the floored\ndivision operator /. In other words, the Jack expression x / y and\nMath.divide(x, y) are equivalent.\n\n# How does NAND work?\n\nI'm glad you asked! I've found the following illustrations quite illuminating:\n\ntaken from Wikipedia.\n\nThe NAND computer follows the Harvard architecture. That is, the instruction\nmemory (ROM) and the data memory (RAM) are separately stored, brought to\nfunction in unison by the CPU.\n\ntaken from Wikipedia.\n\nNAND's CPU is an accumulator machine, meaning that it is heavily dependent on\nits built-in registers for control flow (in this case the accumulator is the D\nregister). Don't worry if you don't fully understand what the CPU\nvisualization depicts. Instead, take the perspective of appreciation for how\nthis elegantly simple design powers the entirety of NAND \u2014 in your web\nbrowser!\n\nWe've reached the instruction set, the nitty-gritty. As indicated, NAND's CPU\nonly has two opcodes! This makes the instruction set relatively simple while\nproviding a rich functionality. NAND's ALU is additionally specified with the\nexpressions it can compute in a single instruction.\n\nPhew! That was a lot to take in, but I promise you NAND is far less\ncomplicated than I've made it out to be. From a relatively simple logical\nfoundation, Turing equivalence is achieved! If you want see my implementation\nof the NAND computer architecture, you're more than welcome to! If you find\nyourself still curious, check out the Nand to Tetris lecture slides for\nfurther elaboration on every aspect of the architecture.\n\nLet's briefly talk about the compiler and the virtual machine to make this\nsection feel complete. These concepts are nothing unique to NAND, hence their\nbrevity. Some of NAND's strange syntactical features are a direct consequence\nof making the compiler easier to implement. The compiler is a recursive\ndescent parser on an LL(1) grammar, generating virtual machine code to be\nutilized as a simple stack machine (a technique that also handles managing\ncall stacks). Each virtual machine instruction is then trivially mapped to\nassembly and machine code. Once again, you're more than welcome to see my\ncompiler implementation for yourself.\n\n# Jack Reference\n\nThis majority of this section was taken from the Nand to Tetris lecture slides\nand the National Taiwan University lecture slides.\n\n### Program Structure\n\n    \n    \n    class ClassName { field variable declarations; static variable declarations; constructor type ( parameterList ) { local variable declarations; statements } method type ( parameterList ) { local variable declarations; statements } function type ( parameterList ) { local variable declarations; statements } }\n\nAbout this layout:\n\n  * Every part in this layout can appear 0 or more times\n  * The order of the field / static declarations is arbitrary\n  * The order of the subroutine declarations is arbitrary\n  * Each type is either void, int, boolean, char, or a class name\n\nA Jack program:\n\n  * Defines classes in separate files\n  * Consists of a collection of one or more classes, one of which must be named Main\n  * Must define the main function in the Main class, the entry point of the program defined by the Jack OS\n\n### Syntax\n\nWhite space and comments| Space characters, newline characters, and comments\nare ignored.The following comment formats are supported: // Comment to end of\nline /* Comment until closing */ /** API documentation comment */  \n---|---  \nSymbols| | ( )| Used for grouping arithmetic expressions and for enclosing parameter-lists and argument-lists  \n---|---  \n[ ]| Used for array indexing  \n{ }| Used for grouping program units and statements  \n,| Variable list separator  \n;| Statement terminator  \n.| Class membership  \n=| Assignment and comparison operator  \n\\+ - * / & | - < >| Operators. Note that & and | are bitwise and do not short-circuit  \nReserved words| | class, constructor, method, function| Program components  \n---|---  \nint, boolean, char| Primitive types  \nvar, static, field| Variable declarations  \nlet, do, if, else, while, return| Statements  \ntrue, false, null| Constant values (-1. 0, and 0 respectively)  \nthis| Object reference  \narguments| Function arguments array reference  \nConstants| Integer constants must be positive and in standard decimal\nnotation, e.g., 1984. Negative integers like -13 are not constants but rather\nexpressions consisting of a unary negative operator applied to an integer\nconstant.String constants are enclosed within quotation marks and may contain\nany characters except new lines or quotation marks. Unlike typical programming\nlanguages, these characters cannot be escaped within a string, so these\ncharacters are instead supplied by the functions String.newLine() and\nString.doubleQuote() from the OS. _^If you manage to read this, say hi to\nNandyBoolean constants can be true or false.null signifies a null reference (a\nvalue of 0).  \nIdentifiers| Identifiers are composed from arbitrarily long sequences of\nletters, digits, and \"_\". The first character cannot be a digit.Case\nsensitivity matters. Thus x and X are treated as different identifiers.  \n  \n### Variables\n\nVariable kind| Description| Declared in| Scope  \n---|---|---|---  \nstatic variables| static type varName1, varName2, ...; Only one copy of each\nstatic variable exists, and this copy is shared by all the object instances of\nthe class (like private static variables in Java)| class declaration| The\nclass in which they are declared.  \nfield variables| field type varName1, varName2, ...; Every object (instance of\nthe class) has a private copy of the field variables (like member variables in\nJava)| class declaration| The class in which they are declared, except for\nfunctions, where they are undefined.  \nlocal variables| var type varName1, varName2, ...; Local variables are created\njust before the subroutine starts running and are deallocated when it returns\n(like local variables in Java)| subroutine declaration| The subroutine in\nwhich they are declared.  \nparameter variables| type varName1, varName2, ... Used to pass arguments to\nthe subroutine. Treated like local variables whose values are initialized\n\"from the outside\", just before the subroutine starts running.| subroutine\nsignature| The subroutine in which they are declared.  \n  \n### Statements\n\nStatement| Syntax| Description  \n---|---|---  \nlet| let varName = expression; or let varName[expression1] = expression2;| An\nassignment operation (where varName is either single-valued or an array). The\nvariable kind may be static, local, field, or parameter.  \nif| if (expression1) { statements1 } else if (expression2) { statements2 }\nelse { statements3 }| Typical if statement with an optional else or else if\nclause. The brackets are optional if there's only one statement.  \nwhile| while (expression) { statements }| Typical while statement. The\nbrackets are optional if there's only one statement.  \ndo| do function-or-method-call;| Used to call a function or a method for its\neffect, ignoring the returned value.  \nreturn| return expression; or return;| Used to return a value from a\nsubroutine. Constructors must return the expression this.  \n  \n# Jack OS Reference\n\nThis section was adapted from the supplied Nand to Tetris software suite.\n\n### Array\n\n    \n    \n    /** * Represents an array. * In the Jack language, arrays are instances of the Array class. * Once declared, the array entries can be accessed using the usual * syntax arr[i]. Each array entry can hold a primitive data type as * well as any object type. Different array entries can have different * data types. */ class Array { /** * Constructs a new array of the given size. */ function Array new(int size); /** * Deallocates an instance of Array and frees its memory space. */ method void dispose(); }\n\n### Keyboard\n\n    \n    \n    /** * The Keyboard class provides an interface for reading inputs from * a standard keyboard. */ class Keyboard { /** * Returns the character code of the currently pressed key, * or 0 if no key is currently pressed. */ function char keyPressed(); /** * Waits until a keyboard key is pressed and released, then displays the * corresponding character on the screen and returns the character. */ function char readChar(); /** * Prints the message on the screen, reads the next line (until a newLine * character) from the keyboard, and returns its value. */ function String readLine(String message); /** * Prints the message on the screen, reads the next line (until a newline * character) from the keyboard, and returns its integer value (until the * first non numeric character). */ function int readInt(String message); }\n\n### Math\n\n    \n    \n    /** * A library of commonly used mathematical functions. */ class Math { /** * Returns the absolute value of x. */ function int abs(int x); /** * Returns the product of x and y. * This function is internally called in lieu of the multiplication * operator '*'. In other words, the Jack expression x * y and * Math.multiply(x, y) are equivalent. */ function int multiply(int x, int y); /** * Returns the integer part of x / y. * This function is internally called in lieu of the division * operator '/'. In other words, the Jack expression x / y and * Math.divide(x, y) are equivalent. */ function int divide(int dividend, int divisor); /** * Returns the integer part of the square root of x. */ function int sqrt(int x); /** * Returns the greater of the two arguments. */ function int max(int a, int b); /** * Returns the smaller of the two arguments. */ function int min(int a, int b); }\n\n### Memory\n\n    \n    \n    /** * This library provides two services: direct access to the computer's main * memory (RAM), and allocation and recycling of memory blocks. The NAND RAM * consists of 32,768 words, each holding a 16-bit binary number. */ class Memory { /** * Returns the RAM value at the given address. */ function int peek(int address); /** * Sets the value of the given RAM address to the given value. */ function void poke(int address, int value); /** * Finds and allocates from the heap a memory block of the specified size and * returns a reference to its base address. */ function int alloc(int size); /** * Deallocates the given object (cast as an array) by making it available for * future allocations. */ function void deAlloc(Array o); }\n\n### Output\n\n    \n    \n    /** * A library of functions for writing text on the screen. * The NAND physical screen consists of 512 rows of 256 pixels each. * The library uses a fixed font, in which each character is displayed * within a frame which is 11 pixels high (including 1 pixel for inter-line * spacing) and 8 pixels wide (including 2 pixels for inter-character spacing). * The resulting grid accommodates 23 rows (indexed 0..22, top to bottom) * of 64 characters each (indexed 0..63, left to right). The top left * character position on the screen is indexed (0,0). A cursor, implemented * as a small filled square, indicates where the next character will be displayed. */ class Output { /** * Moves the cursor to the j'th column of the i'th row, erasing the character * that was there. */ function void moveCursor(int i, int j); /** * Displays the given character at the cursor location, * and advances the cursor one column forward. */ function void printChar(char c); /** * Displays the given string starting at the cursor location, and advances * the cursor appropriately. */ function void printString(String str); /** * Displays the given integer starting at the cursor location, and advances * the cursor appropriately. */ function void printInt(int i); /** * Advances the cursor to the beginning of the next line. */ function void println(); /** * Erases the character that was last written and moves the cursor one column * back. */ function void backSpace(); }\n\n### Screen\n\n    \n    \n    /** * A library of functions for displaying graphics on the screen. * The NAND physical screen consists of 256 rows (indexed 0..255, top to bottom) * of 512 pixels each (indexed 0..511, left to right). The top left pixel on * the screen is indexed (0,0). */ class Screen { /** * Erases the entire screen. */ function void clearScreen(); /** * Sets the current color to be used for all subsequent drawXXX commands. * Black is represented by true, white by false. */ function void setColor(boolean b); /** * Draws the (x, y) pixel using the current color. */ function void drawPixel(int x, int y); /** * Draws a line from pixel (x1, y1) to pixel (x2, y2) using the current color. */ function void drawLine(int x1, int y1, int x2, int y2); /** * Draws a filled rectangle whose top left corner is (x1, y1) and bottom * right corner is (x2, y2) using the current color. */ function void drawRectangle(int x1, int y1, int x2, int y2); /** * Draws a filled circle of radius r <= 181 around (x, y) using the current * color. */ function void drawCircle(int x, int y, int r); }\n\n### String\n\n    \n    \n    /** * Represents character strings. In addition for constructing and * deallocating strings, the class features methods for getting and setting * individual characters of the string, for erasing the string's last character, * for appending a character to the string's end, and more typical * string-oriented operations. */ class String { /** * Constructs a new empty string with a maximum length of maxLength and * initial length of 0. */ constructor String new(int maxLength); /** * Deallocates an instance of String and frees its memory space. */ method void dispose(); /** * Returns the current length of an instance of String. */ method int length(); /** * Returns the character at the j-th location of an instance of String. */ method char charAt(int j); /** * Sets the character at the j-th location of an instance of String to c. */ method void setCharAt(int j, char c); /** * Appends the given character to the end of an instance of String and * returns the same instance. */ method String appendChar(char c); /** * Erases the last character from an instance of String. */ method void eraseLastChar(); /** * Returns the integer value of an instance of String until the first * non-numeric character. */ method int intValue(); /** * Sets an instance of String to the representation of the given number. */ method void setInt(int number); /** * Returns the new line character. */ function char newLine(); /** * Returns the backspace character. */ function char backSpace(); /** * Returns the quotation mark character. */ function char doubleQuote(); }\n\n### Sys\n\n    \n    \n    /** * A library that supports various program execution services. */ class Sys { /** * Halts the program execution. */ function void halt(); /** * Displays the given error code in the format \"ERR[errorCode]\", and halts * the program's execution. */ function void error(int errorCode); /** * Waits approximately duration milliseconds and returns. Note that this is * runtime dependent and may not be accurate. */ function void wait(int duration); }\n\n### Error Codes\n\nIf you do something that forces the computer into an invalid state, like\ncomputing the result of 1 / 0, the Jack OS will display one of these error\ncodes in the format \"ERR[N]\" and immediately terminate the program.\n\nCode| Method/Function| Description  \n---|---|---  \n1| Sys.wait| Duration must be positive  \n2| Array.new| Array size must be positive  \n3| Math.divide| Division by zero  \n4| Math.sqrt| Cannot compute square root of a negative number  \n5| Memory.alloc| Allocated memory size must be positive  \n6| Memory.alloc| Heap overflow  \n7| Screen.drawPixel| Illegal pixel coordinates  \n8| Screen.drawLine| Illegal line coordinates  \n9| Screen.drawRectangle| Illegal rectangle coordinates  \n12| Screen.drawCircle| Illegal center coordinates  \n13| Screen.drawCircle| Illegal radius  \n14| String.new| Maximum length must be non-negative  \n15| String.charAt| String index out of bounds  \n16| String.setCharAt| String index out of bounds  \n17| String.appendChar| String is full  \n19| String.setInt| Insufficient string capacity  \n20| Output.moveCursor| Illegal cursor location  \n  \n# FAQ\n\n### Whoa, is everything made from NAND gates?\n\nWell..., I admit the description and title are a little misleading, but still\nin good faith. The compiler and virtual machine translator are written in\nTypescript, while the kernel and hardware are emulated in Rust. Just the logic\nsimulator runs computations and memory accesses from NAND gates. Bootstrapping\nthe full tech stack is a feat that isn't unheard of, but such a massive\nproject by itself probably deserves its own separate project.\n\n### Did you design NAND by yourself?\n\nNAND follows the Nand to Tetris course and its associated book (you should\ndefinitely check it out, it's an absolutely incredible read). I solely\nimplemented the specification for CPU, assembler, virtual machine translator,\nand compiler, while porting the platform to the web with its own IDE and user\ninterface.\n\n### If there's only one type, what is the point of specifying types at all?\n\nThis question references the fact that under the hood, the signed 16-bit\ninteger is Jack's only real type. We anyways need to be so explicit with types\nto help the compiler figure out which class certain instance methods belong\nto. If we declare the Jack variable s with the type String, s.appendChar(33)\nis transformed during compilation into String.appendChar(s, 33).\n\n### Why does the IDE feel finnicky?\n\nNAND's IDE unfortunately trades implementation simplicity for a worse user\nexperience. It uses the unorthodox contenteditable and hacky cursor\npositioning logic to get syntax highlighting to work. I myself was surprised\nthat I managed to even bring it to a functional state. As a result, it's slow\nand noticeably buggy, plus common keybinds don't work. I'm sorry, but for now\nyou'll just need to bear with me.\n\nYou now know how to program NAND in Jack! And wow! It's been grand voyage of\ndiscovery. This write-up only begins to do justice the pure genius behind the\ncomputer architecture of the modern world. Hopefully, you gain a newfound\nappreciation for the Herculean amount of technical complexity it takes to\nbridge the gap between your code and program output on the screen.\n\nPress \"Start\" to compile and run your code. The OS will typically take a\nlittle under a second to initialize memory and set up its services before\nyou're off to see your program running!\n\nIf you've read this far, my heartfelt thank you! Happy coding!\n\n## About\n\nNAND is a logic simulator suite made entirely from NAND gates\n\nnand.arhan.sh/\n\n### Topics\n\njavascript rust typescript scss svelte nand2tetris wasm-bindgen vite\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\nActivity\n\n### Stars\n\n11 stars\n\n### Watchers\n\n1 watching\n\n### Forks\n\n1 fork\n\nReport repository\n\n## Contributors 2\n\n  * ArhanChaudhary Arhan Chaudhary\n  * ImgBotApp Imgbot\n\n## Languages\n\n  * TypeScript 29.6%\n  * Svelte 26.5%\n  * JavaScript 16.5%\n  * Rust 14.4%\n  * VHDL 10.9%\n  * Assembly 0.6%\n  * Other 1.5%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": true}
