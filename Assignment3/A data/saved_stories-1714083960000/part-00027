{"aid": "40159388", "title": "Fenwick Tree", "url": "https://en.wikipedia.org/wiki/Fenwick_tree", "domain": "wikipedia.org", "votes": 1, "user": "TheGamerUncle", "posted_at": "2024-04-25 16:14:17", "comments": 0, "source_title": "Fenwick tree", "source_text": "Fenwick tree - Wikipedia\n\nJump to content\n\nSearch\n\n# Fenwick tree\n\n  * \u0627\u0644\u0639\u0631\u0628\u064a\u0629\n  * Espa\u00f1ol\n  * \u0641\u0627\u0631\u0633\u06cc\n  * \u65e5\u672c\u8a9e\n  * \u0420\u0443\u0441\u0441\u043a\u0438\u0439\n  * \u0421\u0440\u043f\u0441\u043a\u0438 / srpski\n  * \u0e44\u0e17\u0e22\n  * \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430\n  * \u4e2d\u6587\n\nEdit links\n\nFrom Wikipedia, the free encyclopedia\n\nData structure\n\nFenwick tree Binary indexed tree  \n---  \nType| Binomial tree  \nInvented| 1989  \nInvented by| Boris Ryabko  \n| Time complexity in big O notation  \n---  \nOperation| Average| Worst case  \nSearch| O(logn)| O(logn)  \nInsert| O(logn)| O(logn)  \nSpace complexity  \nSpace| O(n)| O(n)  \nThis article's lead section may be too short to adequately summarize the key\npoints. Please consider expanding the lead to provide an accessible overview\nof all important aspects of the article. (July 2023)  \n---  \n  \nA Fenwick tree or binary indexed tree (BIT) is a data structure that can\nefficiently update values and calculate prefix sums in an array of values.\n\nThis structure was proposed by Boris Ryabko in 1989^[1] with a further\nmodification published in 1992.^[2] It has subsequently become known under the\nname Fenwick tree after Peter Fenwick, who described this structure in his\n1994 article.^[3]\n\nWhen compared with a flat array of values, the Fenwick tree achieves a much\nbetter balance between two operations: value update and prefix sum\ncalculation. A flat array of values can either store the values or the prefix\nsums. In the first case, computing prefix sums requires linear time; in the\nsecond case, updating the array values requires linear time (in both cases,\nthe other operation can be performed in constant time). Fenwick trees allow\nboth operations to be performed in time. This is achieved by representing the\nvalues as a tree with nodes where the value of each node in the tree is the\nprefix sum of the array from the index of the parent (inclusive) up to the\nindex of the node (exclusive). The tree itself is implicit and can be stored\nas an array of values, with the implicit root node omitted from the array. The\ntree structure allows the operations of value retrieval, value update, prefix\nsum, and range sum to be performed using only node accesses.\n\n## Motivation[edit]\n\nMain article: Prefix sums \u00a7 Applications\n\nGiven an array of values, it is sometimes desirable to calculate the running\ntotal of values up to each index according to some associative binary\noperation (addition on integers being by far the most common). Fenwick trees\nprovide a method to query the running total at any index, or prefix sum, in\naddition to allowing changes to the underlying value array and having all\nfurther queries reflect those changes.\n\nFenwick trees are particularly designed to implement the arithmetic coding\nalgorithm, which maintains counts of each symbol produced and needs to convert\nthose to the cumulative probability of a symbol less than a given symbol.\nDevelopment of operations it supports were primarily motivated by use in that\ncase.^[citation needed]\n\n## Description[edit]\n\nA Fenwick tree is an implicit tree where nodes are consecutively numbered, and\nparent-child relationships are determined by arithmetic on the node indexes.\n\nAn important function in this index arithmetic is the least significant set\nbit, also called the find first set operation. This is the greatest power of\ntwo which divides an index . This is the power of two (1, 2, 4, 8, ...) and\nnot the exponent (0, 1, 2, 3, ...). It can be efficiently computed in two's\ncomplement arithmetic as (where & denotes bitwise AND).\n\nA Fenwick tree is most easily understood using a one-based array with values.\nUsing half-open interval syntax, let the range from (exclusive) to\n(inclusive). The corresponding Fenwick array stores the range sums . That is,\nthe sum of values ending with and including .\n\nA fictitious node 0 is used in some descriptions, but is never actually\naccessed and need not be explicitly stored. but the value is never actually\nneeded. may be considered to contain the sum of the empty range with value 0.\n\nA \"Fenwick tree\" is actually three implicit trees over the same array: the\ninterrogation tree used for translating indexes to prefix sums, the update\ntree used for updating elements, and the search tree for translating prefix\nsums to indexes (rank queries).^[4] The first two are normally walked upwards,\nwhile the third is usually walked downwards.\n\n### The interrogation tree[edit]\n\nThe interrogation tree is defined so that the parent of node is . For example,\nthe parent of 6 = 110_2 is 4 = 100_2. Implicit node 0 is the root.\n\nEach level of the tree contains nodes with indices corresponding to sums of\ndistinct powers of 2 (with representing an empty sum 0). For example, level\ncontains nodes and level contains nodes\n\nNode has children (), and total descendants. (These numbers include nodes\ngreater than , which are omitted and never accessed.)\n\nThe below diagram shows the structure of a 16-node Fenwick tree's\ninterrogation tree, including the root, so it corresponds to a 15-element\narray A:\n\nDepiction of a 16-node Fenwick interrogation tree containing range sums of a\n15-node array A\n\nTo find the prefix sum , sum the values in , its parent, its parent's parent,\nand so on up to (but not including) the root. To compute a range sum ,\nsubtract the prefix sums for and . This can be optimized by stopping at their\nfirst common ancestor.\n\n### The update tree[edit]\n\nThe update tree is the mirror image of the interrogation tree. The parent of node is (where | denotes bitwise OR). For example, the parent of 6 = 110_2 is 8 = 1000_2.\n\nThis conceptual tree is infinite, but only the part with indexes up to is\nstored or used. Excluding the fictitious nodes with indexes greater than it\nwill be a forest of disjoint trees, one for each bit set in the binary\nrepresentation of .\n\nHere, a node's ancestors are all nodes whose range sums include its own. For\nexample, holds the sum of , holds the sum of , and so on.\n\nTo modify one of the values , add the change to , then 's parent, then its\ngrandparent, and so on, until the index exceeds .\n\n### The search tree[edit]\n\nUnlike the other two trees, the search tree is a binary tree, arranged in an\norder Knuth calls a \"sideways heap\".^[5] Each node is assigned a height equal\nto the number of trailing zeros in the binary representation of its index,\nwith the parent and children being the numerically closest index(es) of the\nadjacent height. Nodes with odd indexes () are leaves. Nodes with even indexes\nhave the closest two nodes of the next-lowest index as children, . Node 's\nparent in the search tree is .\n\nFor example, the children of 6 = 110_2 is are 5 = 101_2 and 7 = 111_2, and its\nparent is 4 = 100_2.\n\nAlthough this tree is potentially infinite, we may define its root to be the\nhighest existing node, whose index is the greatest power of 2 less than or\nequal to .\n\nIt is possible for a node to have a fictitious parent with an index greater\nthan yet still have an existing grandparent. If the example above applied to a\n5-node tree, then node 5 would have a fictitious parent 6, but an existing\ngrandparent 4.\n\nThe search tree may be considered a combination of the previous two trees. A\nnode's left subtree contains all of its descendants in the update tree, while\nits right subtree contains all of its descendants in the interrogation tree. A\nnode's parent in the search tree is either its interrogation or update parent\n(depending on whether the node is a right or left child, respectively), and\nthe other type of parent may be found by multiple upward steps in the search\ntree.\n\nHowever, upward traversals in the search tree are uncommon; its primary use is\nto perform rank queries: given a prefix sum, at what index does it appear?\nThis is done by a downward traversal through the search tree. During the\ntraversal, three variables are maintained: The current node's index, the rank\nbeing sought in the subtree rooted at the current node, and a \"fallback index\"\nto be returned if the rank sought is greater than can be found in the subtree.\n\nInitially, the current node is the root, the rank sought is the original\nquery, and the fallback index is a special \"overflow\" value indicating that\nthe rank is not in the tree. (Depending on the application, or might be used\nfor this purpose.)\n\nEach step, either the current node is a fictitious node (index greater than ),\nor we must decide if the position sought is to the left or right of the end of\nthe current node. If the rank sought is less than the Fenwick array value for\nthe current node, we must search its left subtree. If it is greater, search\nits right subtree. If it is equal, the direction chosen depends on how you\nwish to handle searches for sums lying exactly between two nodes.\n\nThese three possibilities are then further divided based on whether the\ncurrent node is a leaf or not:\n\n  * If the current node is a leaf and:\n\n    * the target is in its (empty) left subtree, return the current index.\n    * it is fictitious or the target is in its right subtree, return the fallback index.\n  * If the current node is not a leaf and:\n\n    * it is fictitious, search for the same rank in its left subtree with an unchanged fallback index.\n    * the target is in its left subtree, search for the same rank in its left subtree with the current index as the fallback index.\n    * the target is in its right subtree, search for the target rank minus the current node's value in the right subtree, with an unchanged fallback index.\n\n## Pseudocode[edit]\n\nA simple pseudocode implementation of the two main operations on a Fenwick\ntree\u2014query and update\u2014is as following:\n\n    \n    \n    function query(tree, index) is sum := 0 while index > 0 do sum += tree[index] index -= lsb(index) return sum function update(tree, index, value) is while index < size(tree) do tree[index] += value index += lsb(index)\n\nThe function computes the least significant 1-bit or last set bit of the given\nor, equivalently, the largest power of two that is also a divisor of . For\nexample, , as shown in its binary representation: . This function can be\nsimply implemented in code through a bitwise AND operation: lsb(n) = n & (-n),\nassuming a signed integer data type.^[3]\n\n### Construction[edit]\n\nOne naive algorithm to construct a Fenwick tree consists of initializing the\ntree with null values and updating each index individually. This solution\nworks in time, but an construction is possible:^[6]\n\n    \n    \n    function construct(values) is tree := values for every index, value in tree do parentIndex := index + lsb(index) if parentIndex < size(tree) then tree[parentIndex] += value return tree\n\n## See also[edit]\n\n  * Order statistic tree\n  * Prefix sums\n  * Segment tree\n\n## References[edit]\n\n  1. ^ Boris Ryabko (1989). \"A fast on-line code\" (PDF). Soviet Math. Dokl. 39 (3): 533\u2013537. Archived (PDF) from the original on 2019-07-17. Retrieved 2019-07-17.\n  2. ^ Boris Ryabko (1992). \"A fast on-line adaptive code\" (PDF). IEEE Transactions on Information Theory. 28 (1): 1400\u20131404. Archived (PDF) from the original on 2019-07-14. Retrieved 2019-07-14.\n  3. ^ Jump up to: ^a ^b Peter M. Fenwick (1994). \"A new data structure for cumulative frequency tables\". Software: Practice and Experience. 24 (3): 327\u2013336. CiteSeerX 10.1.1.14.8917. doi:10.1002/spe.4380240306. S2CID 7519761.\n  4. ^ Marchini, Stefano; Vigna, Sebastiano (14 October 2019). \"Compact Fenwick trees for dynamic ranking and selection\". arXiv:1904.12370 [cs.DS]. Extensive discussion of practical implementation details.\n  5. ^ Knuth, Donald (2011). Combinatorial Algorithms, Part 1. The Art of Computer Programming. Vol. 4A. Upper Saddle River, NJ: Addison-Wesley Professional. pp. 164\u2013165.\n  6. ^ Halim, Steven; Halim, Felix; Effendy, Suhendry (3 December 2018). Competitive Programming. Vol. 1 (4th ed.). Lulu Press, Incorporated. ISBN 9781716745522.\n\n## External links[edit]\n\n  * A tutorial on Fenwick Trees on TopCoder\n  * An article on Fenwick Trees on Algorithmist\n  * An entry on Fenwick Trees on Polymath wiki\n  * stack exchange\n\n  * v\n  * t\n  * e\n\nTree data structures  \n---  \nSearch trees (dynamic sets/associative arrays)|\n\n  * 2\u20133\n  * 2\u20133\u20134\n  * AA\n  * (a,b)\n  * AVL\n  * B\n  * B+\n  * B*\n  * B^x\n  * (Optimal) Binary search\n  * Dancing\n  * HTree\n  * Interval\n  * Order statistic\n  * (Left-leaning) Red\u2013black\n  * Scapegoat\n  * Splay\n  * T\n  * Treap\n  * UB\n  * Weight-balanced\n\n  \nHeaps|\n\n  * Binary\n  * Binomial\n  * Brodal\n  * d-ary\n  * Fibonacci\n  * Leftist\n  * Pairing\n  * Skew binomial\n  * Skew\n  * van Emde Boas\n  * Weak\n\n  \nTries|\n\n  * Ctrie\n  * C-trie (compressed ADT)\n  * Hash\n  * Radix\n  * Suffix\n  * Ternary search\n  * X-fast\n  * Y-fast\n\n  \nSpatial data partitioning trees|\n\n  * Ball\n  * BK\n  * BSP\n  * Cartesian\n  * Hilbert R\n  * k-d (implicit k-d)\n  * M\n  * Metric\n  * MVP\n  * Octree\n  * PH\n  * Priority R\n  * Quad\n  * R\n  * R+\n  * R*\n  * Segment\n  * VP\n  * X\n\n  \nOther trees|\n\n  * Cover\n  * Exponential\n  * Fenwick\n  * Finger\n  * Fractal tree index\n  * Fusion\n  * Hash calendar\n  * iDistance\n  * K-ary\n  * Left-child right-sibling\n  * Link/cut\n  * Log-structured merge\n  * Merkle\n  * PQ\n  * Range\n  * SPQR\n  * Top\n\n  \n  \nRetrieved from\n\"https://en.wikipedia.org/w/index.php?title=Fenwick_tree&oldid=1209521549\"\n\nCategories:\n\n  * Trees (data structures)\n  * Soviet inventions\n  * Russian inventions\n\nHidden categories:\n\n  * Articles with short description\n  * Short description is different from Wikidata\n  * Wikipedia introduction cleanup from July 2023\n  * All pages needing cleanup\n  * Articles covered by WikiProject Wikify from July 2023\n  * All articles covered by WikiProject Wikify\n  * All articles with unsourced statements\n  * Articles with unsourced statements from October 2023\n\n  * This page was last edited on 22 February 2024, at 08:50 (UTC).\n  * Text is available under the Creative Commons Attribution-ShareAlike License 4.0; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.\n\n  * Privacy policy\n  * About Wikipedia\n  * Disclaimers\n  * Contact Wikipedia\n  * Code of Conduct\n  * Developers\n  * Statistics\n  * Cookie statement\n  * Mobile view\n  * Edit preview settings\n\n", "frontpage": false}
