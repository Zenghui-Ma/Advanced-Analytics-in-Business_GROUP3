{"aid": "40098483", "title": "Dates and Times and Types (2022)", "url": "https://blog.glyph.im/2022/06/dates-and-times-and-types.html", "domain": "glyph.im", "votes": 1, "user": "pkkm", "posted_at": "2024-04-20 16:23:20", "comments": 0, "source_title": "Deciphering Glyph :: Dates And Times And Types", "source_text": "Deciphering Glyph :: Dates And Times And Types\n\nDeciphering\n\nGlyph\n\n  * About\n  * Archives\n  * Mastodon\n  * GitHub\n  * Patrons\n\n# Dates And Times And Types\n\nGet a TypeError when using a datetime when you wanted a date.\n\npythonprogrammingdatetime Monday June 06, 2022\n\nPython\u2019s standard datetime module is very powerful. However, it has a couple\nof annoying flaws.\n\nFirstly, datetimes are considered a kind of date^1, which causes problems.\nAlthough datetime is a literal subclass of date so Mypy and isinstance believe\na datetime \u201cis\u201d a date, you cannot substitute a datetime for a date in a\nprogram without provoking errors at runtime.\n\nTo put it more precisely, here are two programs which define a function with\ntype annotations, that mypy finds no issues with. The first of which even\ntakes care to type-check its arguments at run-time. But both raise TypeErrors\nat runtime:\n\n### Comparing datetime to date:\n\n    \n    \n    1 2 3 4 5 6 7 8 9 10 11 12 13 14\n\n|\n\n    \n    \n    from datetime import date, datetime def is_after(before: date, after: date) -> bool | None: if not isinstance(before, date): raise TypeError(f\"{before} isn't a date\") if not isinstance(after, date): raise TypeError(f\"{after} isn't a date\") if before == after: return None if before > after: return False return True is_after(date.today(), datetime.now())  \n  \n---|---  \n      \n    \n    1 2 3 4 5 6\n\n|\n\n    \n    \n    Traceback (most recent call last): File \".../date_datetime_compare.py\", line 14, in <module> is_after(date.today(), datetime.now()) File \".../date_datetime_compare.py\", line 10, in is_after if before > after: TypeError: can't compare datetime.datetime to datetime.date  \n  \n---|---  \n  \n### Comparing \u201cnaive\u201d and \u201caware\u201d datetime:\n\n    \n    \n    1 2 3 4 5 6\n\n|\n\n    \n    \n    from datetime import datetime, timezone, timedelta def compare(a: datetime, b: datetime) -> timedelta: return a - b compare(datetime.now(), datetime.now(timezone.utc))  \n  \n---|---  \n      \n    \n    1 2 3 4 5 6\n\n|\n\n    \n    \n    Traceback (most recent call last): File \".../naive_aware_compare.py\", line 6, in <module> compare(datetime.now(), datetime.now(timezone.utc)) File \".../naive_aware_compare.py\", line 4, in compare return a - b TypeError: can't subtract offset-naive and offset-aware datetimes  \n  \n---|---  \n  \nIn some sense, the whole point of using Mypy - or, indeed, of runtime\nisinstance checks - is to avoid TypeError getting raised. You specify all the\ntypes, the type-checker yells at you, you fix it, and then you can know your\ncode is not going to blow up in unexpected ways.\n\nOf course, it\u2019s still possible to avoid these TypeErrors with runtime checks,\nbut it\u2019s tedious and annoying to need to put a check for .tzinfo is not None\nor not isinstance(..., datetime) before every use of - or >.\n\nThe problem here is that datetime is trying to represent too many things with\ntoo few types. datetime should not be inheriting from date, because it isn\u2019t a\ndate, which is why > raises an exception when you compare the two.\n\nNaive datetimes represent an abstract representation of a hypothetical civil\ntime which are not necessarily tethered to specific moments in physical time.\nYou can\u2019t know exactly what time \u201ctoday at 2:30 AM\u201d is, unless you know where\non earth you are and what the rules are for daylight savings time in that\nplace. However, you can still talk about \u201c2:30 AM\u201d without reference to a time\nzone, and you can even say that \u201c3:30 AM\u201d is \u201c60 minutes after\u201d that time,\neven if, given potential changes to wall clock time, that may not be strictly\ntrue in one specific place during a DST transition. Indeed, one of those times\nmay refer to multiple points in civil time at a particular location, when\nattached to different sides of a DST boundary.\n\nBy contrast, Aware datetimes represent actual moments in time, as they combine\ncivil time with a timezone that has a defined UTC offset to interpret them in.\n\nThese are very similar types of objects, but they are not in fact the same,\ngiven that all of their operators have slightly different (albeit closely\nrelated) semantics.\n\n## Using datetype\n\nI created a small library, datetype, which is (almost) entirely type-time\nbehavior. At runtime, despite appearances, there are no instances of new\ntypes, not even wrappers. Concretely, everything is a date, time, or datetime\nfrom the standard library. However, when type-checking with Mypy, you will now\nget errors reported from the above scenarios if you use the types from\ndatetype.\n\nConsider this example, quite similar to our first problematic example:\n\n### Comparing AwareDateTime or NaiveDateTime to date:\n\n    \n    \n    1 2 3 4 5 6 7 8 9 10\n\n|\n\n    \n    \n    from datetype import Date, NaiveDateTime def is_after(before: Date, after: Date) -> bool | None: if before == after: return None if before > after: return False return True is_after(Date.today(), NaiveDateTime.now())  \n  \n---|---  \n  \nNow, instead of type-checking cleanly, it produces this error, letting you\nknow that this call to is_after will give you a TypeError.\n\n    \n    \n    1 2\n\n|\n\n    \n    \n    date_datetime_datetype.py:10: error: Argument 2 to \"is_after\" has incompatible type \"NaiveDateTime\"; expected \"Date\" Found 1 error in 1 file (checked 1 source file)  \n  \n---|---  \n  \nSimilarly, attempting to compare naive and aware objects results in errors\nnow. We can even use the included AnyDateTime type variable to include a bound\nsimilar to AnyStr from the standard library to make functions that can take\neither aware or naive datetimes, as long as you don\u2019t mix them up:\n\n### Comparing AwareDateTime to NaiveDateTime:\n\n    \n    \n    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\n\n|\n\n    \n    \n    from datetime import datetime, timezone, timedelta from datetype import AwareDateTime, NaiveDateTime, AnyDateTime def compare_same(a: AnyDateTime, b: AnyDateTime) -> timedelta: return a - b def compare_either( a: AwareDateTime | NaiveDateTime, b: AwareDateTime | NaiveDateTime, ) -> timedelta: return a - b compare_same(NaiveDateTime.now(), AwareDateTime.now(timezone.utc)) compare_same(AwareDateTime.now(timezone.utc), AwareDateTime.now(timezone.utc)) compare_same(NaiveDateTime.now(), NaiveDateTime.now())  \n  \n---|---  \n      \n    \n    1 2 3 4 5 6\n\n|\n\n    \n    \n    naive_aware_datetype.py:13: error: No overload variant of \"__sub__\" of \"_GenericDateTime\" matches argument type \"NaiveDateTime\" ... naive_aware_datetype.py:13: error: No overload variant of \"__sub__\" of \"_GenericDateTime\" matches argument type \"AwareDateTime\" ... naive_aware_datetype.py:16: error: Value of type variable \"AnyDateTime\" of \"compare_same\" cannot be \"_GenericDateTime[Optional[tzinfo]]\" Found 3 errors in 1 file (checked 1 source file)  \n  \n---|---  \n  \n### Telling the Difference\n\nAlthough the types in datetype are Protocols, there\u2019s a bit of included magic\nso that you can use them as type guards with isinstance like regular types.\nFor example:\n\n    \n    \n    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\n|\n\n    \n    \n    from datetype import NaiveDateTime, AwareDateTime from datetime import datetime, timezone nnow = NaiveDateTime.now() anow = AwareDateTime.now(timezone.utc) def check(d: AwareDateTime | NaiveDateTime) -> None: if isinstance(d, NaiveDateTime): print(\"Naive!\", d - nnow) elif isinstance(d, AwareDateTime): print(\"Aware!\", d - anow) check(NaiveDateTime.now()) check(AwareDateTime.now(timezone.utc))  \n  \n---|---  \n  \n### Try it out, carefully\n\nThis library is very much alpha-quality; in the process of writing this blog\npost, I made a half a dozen backwards-incompatible changes, and there are\nstill probably a few more left as I get feedback. But if this is a problem\nyou\u2019ve had within your own codebases - ensuring that dates and datetimes don\u2019t\nget mixed up, or requiring that all datetimes crossing some API boundary are\ndefinitely aware and not naive, give it a try with pip install datetype and\nlet me know if it catches any bugs!\n\n  1. But, in typical fashion, not a kind of time... \u21a9\n\n\u00a9 Glyph 2024; All Rights Reserved Excepting Those Which Are Not. See my\ndisclosure statements for information on my interests, financial and\notherwise.\n\nMastodon\n\n", "frontpage": false}
