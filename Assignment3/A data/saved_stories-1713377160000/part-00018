{"aid": "40061483", "title": "Why CVE-2022-3602 was not detected by fuzz testing", "url": "http://allsoftwaresucks.blogspot.com/2022/11/why-cve-2022-3602-was-not-detected-by.html", "domain": "allsoftwaresucks.blogspot.com", "votes": 1, "user": "lemper", "posted_at": "2024-04-17 07:14:28", "comments": 0, "source_title": "Why CVE-2022-3602 was not detected by fuzz testing", "source_text": "I hate software: Why CVE-2022-3602 was not detected by fuzz testing\n\n# I hate software\n\n## Thursday, November 3, 2022\n\n### Why CVE-2022-3602 was not detected by fuzz testing\n\nSo recently a very hyped memory corruption security vulnerability was\ndiscovered in the OpenSSL punycode parser.\n\nSome folks including Hanno\n(https://twitter.com/hanno/status/1587775675397726209) asked why this is still\nhappenning, why no one wrote a fuzzer for the punycode parser and if we as the\nsecurity community have learned nothing from Heartbleed.\n\nI think we should give the developers the benefit of doubt and assume they\nwere acting in good faith and try to see what could be improved.\n\nIn fact, there already exists a fuzz testing harness for the X.509 in the\nOpenSSL source code.\n\nAll of the fuzzers from the OpenSSL source tree are also supposedly\nautomatically deployed to ClusterFuzz via OSS-Fuzz:\nhttps://github.com/google/oss-fuzz/blob/master/projects/openssl/build.sh\n\n### Examining call chains\n\nLet\u2019s start by examining the call chain for the vulnerable function.\n\n  * ossl_punycode_decode: called by ossl_a2ulabel\n  * ossl_a2ulabel: ossl_a2ucompare is not really referenced anywhere in C code, only mentioned in documentation.\n\nLet's examine who calls \"ossl_a2ulabel\" then.\n\n> openssl/crypto$ grep -rI ossl_a2ulabel .\n>\n> ./x509/v3_ncons.c: if (ossl_a2ulabel(baseptr, ulabel + 1, &size) <= 0) {\n\nLet's remember the name of this file and examine the coverage produced by the\ncorpus shipped with the OpenSSL source for the X.509 fuzzing harness.\n\n  * nc_email_eai <\\- nc_match_single <\\- nc_match <\\- NAME_CONSTRAINTS_check, NAME_CONSTRAINTS_check_CN\n  * NAME_CONSTRAINTS_check, NAME_CONSTRAINTS_check_CN <\\- check_name_constraints in crypto/x509/x509_vfy.c\n  * check_name_constraints <\\- verify_chain <\\- X509_verify_cert\n  * X509_verify_cert: this one has A LOT of callers in the OpenSSL code, but was not reached by the fuzzing harness.\n  * X509_verify_cert: (other ways to reach it are circular - looks like we have to call it directly): check_crl_path <\\- check_crl <\\- check_cert <\\- check_revocation <\\- verify_chain\n\n### Examining coverage\n\nHere is what I did:\n\n  * Compiled the fuzzing harness with coverage (added -fprofile-instr-generate -fcoverage-mapping) before -DPEDANTIC when building fuzzers.\n  * Minimized the x.509 fuzzing corpus to speed up the next step:\n    * ./fuzz/x509 -merge=1 fuzz/corpora/x509_min fuzz/corpora/x509\n  * Ran the executable on all input vectors. This is very slow because while parsing is fast, executable takes time to start up. One solution here could be to use the toolchain from OSS-Fuzz which replaces libFuzzer with a library which triages inputs somewhat like AFL persistent mode.\n    * for i in corpora/x509_min/*; do ./x509 $i; mv default.profraw $(basename $i).profraw; done\n    * llvm-profdata-10 merge -sparse *.profraw -o default.profdata\n    * llvm-cov-10 show --output-dir=cov_html --format=html -instr-profile=default.profdata x509\n  * Update (regarding the persistent mode/perf comment above): once you build the harness with coverage flags, there is no need to execute each input file separately, one can just use the \"runs=N\" option of libFuzzer:\n    * ./x509 -runs=3000 ./corpora/x509_min\n\n### So, why did this all happen?\n\nMy first (un)educated guess was: fuzzing will waste time in ASN.1\ndeserialization with little time spent on parsing decoded fields. Turns out,\nit's slightly worse.\n\nShort answer: the code is not reachable by the current corpus and harness. As\nthere exists an X.509 fuzzer, perhaps developers and other folks assumed it\ncould theoretically reach all parsers, but this is not the case.\n\nThe file through which it\u2019s reachable (v3_ncons.c) has little coverage.\n\nThe specific call chain which we traced to \"check_name_constraints\" ends up in\n\"crypto/x509/x509_vfy.c\" which has ZERO coverage.\n\n### (Update): \"verify_chain\" is reachable in other fuzzers, but it's still not\nenough.\n\nJonathan Metzman from Google's Open Source Security Team pointed me to an OSS-\nFuzz dashboard where \"verify_chain\" is reachable.\n\n  * https://twitter.com/metzmanj/status/1588174176229199873\n  * https://storage.googleapis.com/oss-fuzz-coverage/openssl/reports/20221031/linux/src/openssl/crypto/x509/x509_vfy.c.html#L221\n\nUnfortunately, this is still NOT enough:\n\n  * \"verify_chain\" is covered 4.6K times whereas the inner loop of the X.509 fuzzer is invoked 12.4 times so it's reachable but NOT by the X.509 fuzzer.\n  * Whichever harness reaches \"verify_chain\" (most likely the \"server\" ssl test but not the X.509 one) needs to be modified to either set up a valid certificate chain for verification or mark the certificate as self-signed so that \"build_chain\" does not return error\n  * https://twitter.com/astarasikov/status/1588175841615261702\n\n#### (Update 2): making \"verify_chain\" and \"build_chain\" pass (still not\nthere).\n\nI modified the X.509 test by adding some code from the \"test_self_signed\"\nfunction I took from \"tests\". With that, we can pass the \"build_chain\" and\nexercise most of \"verify_chain\". Unfortunately, name verification still\nrequires a well-formed proxy certificate.\n\nI think the way to go could be to take the code from \"test/sslapitest.c\",\nfunction \"test_client_cert_verify_cb\", use the provided certificates as input\nvectors and fuzz them.\n\nUltimately, one needs to add a custom certificate to the untrusted chain and\nsign the certificate to be verified with it. As one can see, it's a lot of\nwork which requires getting familiar with using OpenSSL.\n\n  * https://gist.github.com/astarasikov/4a60bb17499d4351bb27189e5e8ba8f4\n\n### What could we try improving?\n\n  * Write separate parsers for each function (like Hanno did) - for that, it'd be necessary to examine coverage to see 1. where coverage is low and 2. where the code processes decoded ASN.1 elements\n  * Write a harness to cover X509_verify_cert. Looks like this is currently only called from \"test\" but not \"fuzz\" tests. While it may be slow to fuzz the verification, it will definitely cover a larger attack surface.\n    * Update: while this function is reachable via \"client\" and \"server\" tests, it returns early. To really cover it and the \"punycode\" parsing, it's necessary to set up certificate chains in these tests, as well as generate valid \"proxy\" certificates and add them to the corpus.\n  * Periodically examine coverage reports. This is a bit tedious to do manually, but if there was a public access to the OSS-Fuzz coverage report from Google, this would be much easier. Additionally, the OSS-Fuzz Introspector tool could be helpful in identifying roadblocks/unreachable code.\n\nGenerally, the Introspector does not always work perfectly and is easy to\nbreak - it's a static analysis tool so it gets confused by function pointers\nand cannot infer anything that happens at runtime, like when your code is\nheavily using C++ classes or a hashtable for lookups. In case of X.509 code,\nhowever, it may work fine - function pointers are mostly used by the ASN.1\ncode for its internals (which we actualy do NOT want to fuzz or review in most\ncases) whereas the core top-level logic is reachable by direct function calls\nfrom the entrypoint - a good candidate for static analysis.\n\n  * https://github.com/ossf/fuzz-introspector\n  * https://openssf.org/blog/2022/06/09/introducing-fuzz-introspector-an-openssf-tool-to-improve-fuzzing-coverage/\n\n#### If we had the harness which could theoretically reach X509_verify_cert\n\n  * Add well-formed (encoded) ASN.1 elements to the dictionary file (-dict= option for libFuzzer). This one is currently not used by the OpenSSL fuzz/helper.py, but at least oids.txt is used by OSS-Fuzz as the dictionary.\n  * Add well-formed X.509 certificates which make use of the \"name constraints\" field. And strictly speaking, all other fields too - instead of just storing the libFuzzer-generated corpus in the tree, it would be better to manually provide various inputs exercising difficult functionality. However, as libFuzzer is spending far too much time on ASN.1 and is overloaded with \"features\", this will likely only uncover new issues during long (days) runs on ClusterFuzz. Whereas parsers for individual leaf functions, as demonstrated by Hanno, can find (some) bugs in mere seconds.\n\n## Thanks to:\n\nHanno for his twitter thread for motivating me to look into this.\n\nMy colleagues for introducing me to the Introspector tool.\n\nP.S. Linking to my evergreen tweet\nhttps://twitter.com/astarasikov/status/1122364899362054144\n\nPosted by\n\nI hate software at\n\n7:50 AM\n\nEmail ThisBlogThis!Share to TwitterShare to FacebookShare to Pinterest\n\n#### No comments:\n\n#### Post a Comment\n\nOlder Post Home\n\nSubscribe to: Post Comments (Atom)\n\n## Blog Archive\n\n  * \u25bc 2022 (1)\n\n    * \u25bc November (1)\n\n      * Why CVE-2022-3602 was not detected by fuzz testing\n\n  * \u25ba 2021 (1)\n\n    * \u25ba August (1)\n\n  * \u25ba 2020 (2)\n\n    * \u25ba August (1)\n    * \u25ba May (1)\n\n  * \u25ba 2019 (1)\n\n    * \u25ba May (1)\n\n  * \u25ba 2016 (6)\n\n    * \u25ba October (1)\n    * \u25ba September (1)\n    * \u25ba March (1)\n    * \u25ba February (1)\n    * \u25ba January (2)\n\n  * \u25ba 2015 (3)\n\n    * \u25ba November (1)\n    * \u25ba May (2)\n\n  * \u25ba 2014 (6)\n\n    * \u25ba October (1)\n    * \u25ba September (1)\n    * \u25ba June (2)\n    * \u25ba March (1)\n    * \u25ba January (1)\n\n  * \u25ba 2013 (15)\n\n    * \u25ba December (1)\n    * \u25ba November (4)\n    * \u25ba October (2)\n    * \u25ba May (2)\n    * \u25ba April (2)\n    * \u25ba February (2)\n    * \u25ba January (2)\n\n  * \u25ba 2012 (5)\n\n    * \u25ba October (1)\n    * \u25ba September (3)\n    * \u25ba June (1)\n\n## About Me\n\nI hate software\n\n    http://astarasikov.github.io/ https://twitter.com/astarasikov\n\nView my complete profile\n\n## My Blog List\n\n  * srchvrs's blog | searchivarius.org\n\nUnderstanding Performance of Long-Document Ranking Models through\nComprehensive Evaluation and Leaderboarding\n\n2 weeks ago\n\n  * HiR Information Report\n\nNovember 2023 SecKC Presentation: Mobile SDR\n\n5 months ago\n\n  * Nuit Blanche\n\nLarge Language Models and Transformers (Videos, Simons Institute for the\nTheory of Computing)\n\n7 months ago\n\n  * \u0411\u043b\u043e\u0433 \u041c\u0430\u043c\u0430\u0438\u0447\u0430\n\n\u041f\u0435\u0440\u0435\u0435\u0437\u0434 \u043d\u0430 \u0414\u0437\u0435\u043d\n\n1 year ago\n\n  * Mamaich blog\n\nMoving to Dzen\n\n1 year ago\n\n  * OM A XIM\n\n\u0428\u043e \u043f\u043e \u0440\u0443\u0441\u043d\u0456?\n\n2 years ago\n\n  * rfLinux\n\n\u041e\u043f\u0442\u0438\u043c\u0438\u0437\u0430\u0446\u0438\u044f: frame pointer omission\n\n3 years ago\n\n  * Vivek Haldar\n\nHardware Acquisition Hacks\n\n3 years ago\n\n  * If We Assume\n\n10 Years of my Digital Life\n\n4 years ago\n\n  * Some Blog\n\nQtVirtualKeyboard on Wayland\n\n6 years ago\n\n  * aseigo\n\nmoving house\n\n9 years ago\n\n  * whitespace\n\nOn tests and types\n\n9 years ago\n\n  * \u043f\u043e\u043a\u043e\u043f\u0430\u043b\u0441\u044f \u044f \u0442\u0443\u0442...\n\n\u0414\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 swap \u0432 Linux\n\n10 years ago\n\n  * Thousands of HATE...\n\nALT Linux\n\n13 years ago\n\n  * anarsoul's blog\n\nMigration to xubuntu\n\n13 years ago\n\n  * AndreyGL/D3D\n\nSoftware Occlusion Culling\n\n14 years ago\n\n  * \u0412\u043e\u0432\u0441\u0435 \u043d\u0435 \u0434\u043d\u0435\u0432\u043d\u0438\u043a\n\n  * Blogger: User Profile: derand\n\nSimple theme. Powered by Blogger.\n\nDiese Website verwendet Cookies von Google, um Dienste anzubieten und Zugriffe\nzu analysieren. Deine IP-Adresse und dein User-Agent werden zusammen mit\nMesswerten zur Leistung und Sicherheit f\u00fcr Google freigegeben. So k\u00f6nnen\nNutzungsstatistiken generiert, Missbrauchsf\u00e4lle erkannt und behoben und die\nQualit\u00e4t des Dienstes gew\u00e4hrleistet werden.Weitere InformationenOk\n\n", "frontpage": false}
