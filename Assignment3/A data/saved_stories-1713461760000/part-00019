{"aid": "40074632", "title": "Linux Magic System Request Key Hacks", "url": "https://docs.kernel.org/admin-guide/sysrq.html", "domain": "kernel.org", "votes": 1, "user": "ekiauhce", "posted_at": "2024-04-18 10:13:30", "comments": 0, "source_title": "Linux Magic System Request Key Hacks \u2014 The Linux Kernel documentation", "source_text": "Linux Magic System Request Key Hacks \u2014 The Linux Kernel documentation\n\n# The Linux Kernel\n\n6.9.0-rc4\n\n### Quick search\n\n### Contents\n\n  * Development process\n  * Submitting patches\n  * Code of conduct\n  * Maintainer handbook\n  * All development-process docs\n\n  * Core API\n  * Driver APIs\n  * Subsystems\n  * Locking\n\n  * Licensing rules\n  * Writing documentation\n  * Development tools\n  * Testing guide\n  * Hacking guide\n  * Tracing\n  * Fault injection\n  * Livepatching\n  * Rust\n\n  * Administration\n\n    * Linux kernel release 6.x <http://kernel.org/>\n    * The kernel\u2019s command-line parameters\n    * Linux allocated devices (4.x+ version)\n    * Documentation for /proc/sys\n    * Linux ABI description\n    * Feature status on all architectures\n    * Hardware vulnerabilities\n    * Reporting issues\n    * Reporting regressions\n    * How to quickly build a trimmed Linux kernel\n    * How to verify bugs and bisect regressions\n    * Bug hunting\n    * Bisecting a bug\n    * Tainted kernels\n    * Ramoops oops/panic logger\n    * Dynamic debug\n    * Explaining the \u201cNo working init found.\u201d boot hang message\n    * Documentation for Kdump - The kexec-based Crash Dumping Solution\n    * Performance monitor support\n    * pstore block oops/panic logger\n    * Rules on how to access information in sysfs\n    * Discovering Linux kernel subsystems used by a workload\n    * ACPI Support\n    * ATA over Ethernet (AoE)\n    * Auxiliary Display Support\n    * A block layer cache (bcache)\n    * The Android binderfs Filesystem\n    * Kernel Support for miscellaneous Binary Formats (binfmt_misc)\n    * Block Devices\n    * Boot Configuration\n    * Linux Braille Console\n    * btmrvl driver\n    * Control Groups version 1\n    * Control Group v2\n    * CIFS\n    * Clearing WARN_ONCE\n    * CPU load\n    * How CPU topology info is exported via sysfs\n    * Dell Remote BIOS Update driver (dell_rbu)\n    * Device Mapper\n    * EDID\n    * The EFI Boot Stub\n    * ext4 General Information\n    * File system Monitoring with fanotify\n    * NFS\n    * GPIO\n    * Notes on the change from 16-bit UIDs to 32-bit UIDs\n    * Hardware random number generators\n    * Using the initial RAM disk (initrd)\n    * I/O statistics fields\n    * Java(tm) Binary Kernel Support for Linux v1.03\n    * IBM\u2019s Journaled File System (JFS) for Linux\n    * Reducing OS jitter due to per-cpu kthreads\n    * Laptop Drivers\n    * Parallel port LCD/Keypad Panel support\n    * LDM - Logical Disk Manager (Dynamic Disks)\n    * Softlockup detector and hardlockup detector (aka nmi_watchdog)\n    * Linux Security Module Usage\n    * RAID arrays\n    * Media subsystem admin and user guide\n    * Memory Management\n    * Kernel module signing facility\n    * Mono(tm) Binary Kernel Support for Linux\n    * Namespaces\n    * Numa policy hit/miss statistics\n    * Parport\n    * Perf events and tool security\n    * Power Management\n    * Set udev rules for PMF Smart PC Builder\n    * Linux Plug and Play Documentation\n    * RapidIO Subsystem Guide\n    * Reliability, Availability and Serviceability (RAS)\n    * Error decoding\n    * Address translation\n    * Real Time Clock (RTC) Drivers for Linux\n    * Linux Serial Console\n    * Video Mode Selection Support 2.13\n    * Syscall User Dispatch\n    * Linux Magic System Request Key Hacks\n\n      * What is the magic SysRq key?\n      * How do I enable the magic SysRq key?\n      * How do I use the magic SysRq key?\n      * What are the \u2018command\u2019 keys?\n      * Okay, so what can I use them for?\n      * Sometimes SysRq seems to get \u2018stuck\u2019 after using it, what can I do?\n      * I hit SysRq, but nothing seems to happen, what\u2019s wrong?\n      * I want to add SysRQ key events to a module, how does it work?\n      * When I hit a SysRq key combination only the header appears on the console?\n      * I have more questions, who can I ask?\n      * Credits\n    * Thermal Subsystem\n    * USB4 and Thunderbolt\n    * Using UFS\n    * Unicode support\n    * Software cursor for VGA\n    * Video Output Switcher Control\n    * The SGI XFS Filesystem\n  * Build system\n  * Reporting issues\n  * Userspace tools\n  * Userspace API\n\n  * Firmware\n  * Firmware and Devicetree\n\n  * CPU architectures\n\n  * Unsorted documentation\n\n  * Translations\n\n### This Page\n\n  * Show Source\n\nEnglish\n\n  * Chinese (Simplified)\n  * Chinese (Traditional)\n\n# Linux Magic System Request Key Hacks\u00b6\n\nDocumentation for sysrq.c\n\n## What is the magic SysRq key?\u00b6\n\nIt is a \u2018magical\u2019 key combo you can hit which the kernel will respond to\nregardless of whatever else it is doing, unless it is completely locked up.\n\n## How do I enable the magic SysRq key?\u00b6\n\nYou need to say \u201cyes\u201d to \u2018Magic SysRq key (CONFIG_MAGIC_SYSRQ)\u2019 when\nconfiguring the kernel. When running a kernel with SysRq compiled in,\n/proc/sys/kernel/sysrq controls the functions allowed to be invoked via the\nSysRq key. The default value in this file is set by the\nCONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE config symbol, which itself defaults to 1.\nHere is the list of possible values in /proc/sys/kernel/sysrq:\n\n>   * 0 - disable sysrq completely\n>\n>   * 1 - enable all functions of sysrq\n>\n>   * >1 - bitmask of allowed sysrq functions (see below for detailed function\n> description):\n>  \n>     >     2 = 0x2 - enable control of console logging level 4 = 0x4 - enable\n> control of keyboard (SAK, unraw) 8 = 0x8 - enable debugging dumps of\n> processes etc. 16 = 0x10 - enable sync command 32 = 0x20 - enable remount\n> read-only 64 = 0x40 - enable signalling of processes (term, kill, oom-kill)\n> 128 = 0x80 - allow reboot/poweroff 256 = 0x100 - allow nicing of all RT\n> tasks\n>\n>\n\nYou can set the value in the file by the following command:\n\n    \n    \n    echo \"number\" >/proc/sys/kernel/sysrq\n\nThe number may be written here either as decimal or as hexadecimal with the 0x\nprefix. CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE must always be written in\nhexadecimal.\n\nNote that the value of /proc/sys/kernel/sysrq influences only the invocation\nvia a keyboard. Invocation of any operation via /proc/sysrq-trigger is always\nallowed (by a user with admin privileges).\n\n## How do I use the magic SysRq key?\u00b6\n\nOn x86\n\n    \n\nYou press the key combo ALT-SysRq-<command key>.\n\nNote\n\nSome keyboards may not have a key labeled \u2018SysRq\u2019. The \u2018SysRq\u2019 key is also\nknown as the \u2018Print Screen\u2019 key. Also some keyboards cannot handle so many\nkeys being pressed at the same time, so you might have better luck with press\nAlt, press SysRq, release SysRq, press <command key>, release everything.\n\nOn SPARC\n\n    \n\nYou press ALT-STOP-<command key>, I believe.\n\nOn the serial console (PC style standard serial ports only)\n\n    \n\nYou send a BREAK, then within 5 seconds a command key. Sending BREAK twice is\ninterpreted as a normal BREAK.\n\nOn PowerPC\n\n    \n\nPress ALT - Print Screen (or F13) - <command key>. Print Screen (or F13) -\n<command key> may suffice.\n\nOn other\n\n    \n\nIf you know of the key combos for other architectures, please submit a patch\nto be included in this section.\n\nOn all\n\n    \n\nWrite a single character to /proc/sysrq-trigger. Only the first character is\nprocessed, the rest of the string is ignored. However, it is not recommended\nto write any extra characters as the behavior is undefined and might change in\nthe future versions. E.g.:\n\n    \n    \n    echo t > /proc/sysrq-trigger\n\nAlternatively, write multiple characters prepended by underscore. This way,\nall characters will be processed. E.g.:\n\n    \n    \n    echo _reisub > /proc/sysrq-trigger\n\nThe <command key> is case sensitive.\n\n## What are the \u2018command\u2019 keys?\u00b6\n\nCommand| Function  \n---|---  \nb| Will immediately reboot the system without syncing or unmounting your\ndisks.  \nc| Will perform a system crash and a crashdump will be taken if configured.  \nd| Shows all locks that are held.  \ne| Send a SIGTERM to all processes, except for init.  \nf| Will call the oom killer to kill a memory hog process, but do not panic if\nnothing can be killed.  \ng| Used by kgdb (kernel debugger)  \nh| Will display help (actually any other key than those listed here will\ndisplay help. but h is easy to remember :-)  \ni| Send a SIGKILL to all processes, except for init.  \nj| Forcibly \u201cJust thaw it\u201d - filesystems frozen by the FIFREEZE ioctl.  \nk| Secure Access Key (SAK) Kills all programs on the current virtual console.\nNOTE: See important comments below in SAK section.  \nl| Shows a stack backtrace for all active CPUs.  \nm| Will dump current memory info to your console.  \nn| Used to make RT tasks nice-able  \no| Will shut your system off (if configured and supported).  \np| Will dump the current registers and flags to your console.  \nq| Will dump per CPU lists of all armed hrtimers (but NOT regular timer_list\ntimers) and detailed information about all clockevent devices.  \nr| Turns off keyboard raw mode and sets it to XLATE.  \ns| Will attempt to sync all mounted filesystems.  \nt| Will dump a list of current tasks and their information to your console.  \nu| Will attempt to remount all mounted filesystems read-only.  \nv| Forcefully restores framebuffer console  \nv| Causes ETM buffer dump [ARM-specific]  \nw| Dumps tasks that are in uninterruptible (blocked) state.  \nx| Used by xmon interface on ppc/powerpc platforms. Show global PMU Registers\non sparc64. Dump all TLB entries on MIPS.  \ny| Show global CPU Registers [SPARC-64 specific]  \nz| Dump the ftrace buffer  \n0-9| Sets the console log level, controlling which kernel messages will be\nprinted to your console. (0, for example would make it so that only emergency\nmessages like PANICs or OOPSes would make it to your console.)  \n  \n## Okay, so what can I use them for?\u00b6\n\nWell, unraw(r) is very handy when your X server or a svgalib program crashes.\n\nsak(k) (Secure Access Key) is useful when you want to be sure there is no\ntrojan program running at console which could grab your password when you\nwould try to login. It will kill all programs on given console, thus letting\nyou make sure that the login prompt you see is actually the one from init, not\nsome trojan program.\n\nImportant\n\nIn its true form it is not a true SAK like the one in a c2 compliant system,\nand it should not be mistaken as such.\n\nIt seems others find it useful as (System Attention Key) which is useful when\nyou want to exit a program that will not let you switch consoles. (For\nexample, X or a svgalib program.)\n\nreboot(b) is good when you\u2019re unable to shut down, it is an equivalent of\npressing the \u201creset\u201d button.\n\ncrash(c) can be used to manually trigger a crashdump when the system is hung.\nNote that this just triggers a crash if there is no dump mechanism available.\n\nsync(s) is handy before yanking removable medium or after using a rescue shell\nthat provides no graceful shutdown -- it will ensure your data is safely\nwritten to the disk. Note that the sync hasn\u2019t taken place until you see the\n\u201cOK\u201d and \u201cDone\u201d appear on the screen.\n\numount(u) can be used to mark filesystems as properly unmounted. From the\nrunning system\u2019s point of view, they will be remounted read-only. The remount\nisn\u2019t complete until you see the \u201cOK\u201d and \u201cDone\u201d message appear on the screen.\n\nThe loglevels 0-9 are useful when your console is being flooded with kernel\nmessages you do not want to see. Selecting 0 will prevent all but the most\nurgent kernel messages from reaching your console. (They will still be logged\nif syslogd/klogd are alive, though.)\n\nterm(e) and kill(i) are useful if you have some sort of runaway process you\nare unable to kill any other way, especially if it\u2019s spawning other processes.\n\n\u201cjust thaw it(j)\u201d is useful if your system becomes unresponsive due to a\nfrozen (probably root) filesystem via the FIFREEZE ioctl.\n\n## Sometimes SysRq seems to get \u2018stuck\u2019 after using it, what can I do?\u00b6\n\nWhen this happens, try tapping shift, alt and control on both sides of the\nkeyboard, and hitting an invalid sysrq sequence again. (i.e., something like\nalt-sysrq-z).\n\nSwitching to another virtual console (ALT+Fn) and then back again should also\nhelp.\n\n## I hit SysRq, but nothing seems to happen, what\u2019s wrong?\u00b6\n\nThere are some keyboards that produce a different keycode for SysRq than the\npre-defined value of 99 (see KEY_SYSRQ in include/uapi/linux/input-event-\ncodes.h), or which don\u2019t have a SysRq key at all. In these cases, run showkey\n-s to find an appropriate scancode sequence, and use setkeycodes <sequence> 99\nto map this sequence to the usual SysRq code (e.g., setkeycodes e05b 99). It\u2019s\nprobably best to put this command in a boot script. Oh, and by the way, you\nexit showkey by not typing anything for ten seconds.\n\n## I want to add SysRQ key events to a module, how does it work?\u00b6\n\nIn order to register a basic function with the table, you must first include\nthe header include/linux/sysrq.h, this will define everything else you need.\nNext, you must create a sysrq_key_op struct, and populate it with A) the key\nhandler function you will use, B) a help_msg string, that will print when\nSysRQ prints help, and C) an action_msg string, that will print right before\nyour handler is called. Your handler must conform to the prototype in\n\u2018sysrq.h\u2019.\n\nAfter the sysrq_key_op is created, you can call the kernel function\nregister_sysrq_key(int key, const struct sysrq_key_op *op_p); this will\nregister the operation pointed to by op_p at table key \u2018key\u2019, if that slot in\nthe table is blank. At module unload time, you must call the function\nunregister_sysrq_key(int key, const struct sysrq_key_op *op_p), which will\nremove the key op pointed to by \u2018op_p\u2019 from the key \u2018key\u2019, if and only if it\nis currently registered in that slot. This is in case the slot has been\noverwritten since you registered it.\n\nThe Magic SysRQ system works by registering key operations against a key op\nlookup table, which is defined in \u2018drivers/tty/sysrq.c\u2019. This key table has a\nnumber of operations registered into it at compile time, but is mutable, and 2\nfunctions are exported for interface to it:\n\n    \n    \n    register_sysrq_key and unregister_sysrq_key.\n\nOf course, never ever leave an invalid pointer in the table. I.e., when your\nmodule that called register_sysrq_key() exits, it must call\nunregister_sysrq_key() to clean up the sysrq key table entry that it used.\nNull pointers in the table are always safe. :)\n\nIf for some reason you feel the need to call the handle_sysrq function from\nwithin a function called by handle_sysrq, you must be aware that you are in a\nlock (you are also in an interrupt handler, which means don\u2019t sleep!), so you\nmust call __handle_sysrq_nolock instead.\n\n## When I hit a SysRq key combination only the header appears on the console?\u00b6\n\nSysrq output is subject to the same console loglevel control as all other\nconsole output. This means that if the kernel was booted \u2018quiet\u2019 as is common\non distro kernels the output may not appear on the actual console, even though\nit will appear in the dmesg buffer, and be accessible via the dmesg command\nand to the consumers of /proc/kmsg. As a specific exception the header line\nfrom the sysrq command is passed to all console consumers as if the current\nloglevel was maximum. If only the header is emitted it is almost certain that\nthe kernel loglevel is too low. Should you require the output on the console\nchannel then you will need to temporarily up the console loglevel using alt-\nsysrq-8 or:\n\n    \n    \n    echo 8 > /proc/sysrq-trigger\n\nRemember to return the loglevel to normal after triggering the sysrq command\nyou are interested in.\n\n## I have more questions, who can I ask?\u00b6\n\nJust ask them on the linux-kernel mailing list:\n\n    \n\nlinux-kernel@vger.kernel.org\n\n## Credits\u00b6\n\n  * Written by Mydraal <vulpyne@vulpyne.net>\n\n  * Updated by Adam Sulmicki <adam@cfar.umd.edu>\n\n  * Updated by Jeremy M. Dolan <jmd@turbogeek.org> 2001/01/28 10:15:59\n\n  * Added to by Crutcher Dunnavant <crutcher+kernel@datastacks.com>\n\n\u00a9The kernel development community. | Powered by Sphinx 5.0.1 & Alabaster 0.7.12 | Page source\n\n", "frontpage": false}
