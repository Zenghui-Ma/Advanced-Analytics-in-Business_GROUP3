{"aid": "40052833", "title": "Avoid This Mistake When Caching Asynchronous Results", "url": "https://maximorlov.com/caching-asynchronous-results/", "domain": "maximorlov.com", "votes": 1, "user": "stareatgoats", "posted_at": "2024-04-16 14:59:22", "comments": 0, "source_title": "Avoid This Mistake When Caching Asynchronous Results", "source_text": "Avoid This Mistake When Caching Asynchronous Results - Maxim Orlov\n\nSkip to content\n\n# Avoid This Mistake When Caching Asynchronous Results\n\n4 min read\n\nImplementing a robust cache is a challenging task. Some of the things you'll\nneed to consider are \u2014 What will you cache? When will you invalidate? And,\nwhat strategy will you implement? \ud83e\udd14\n\nThe primary job of a cache is to reduce load on upstream services. Therefore,\nlast thing you want is an ineffective and useless cache. \ud83d\ude24\n\nUnfortunately, this is something that happens all too often when caching\nasynchronous results.\n\nHere's what you should watch out for, and how you can implement a cache that\nguarantees no cache misses.\n\n## Cache stampede\n\nIn the context of web applications, a cache stampede occurs when several\nrequests are fetching the same resource in parallel. If the resource is\nmissing from the cache, each request ends up initiating a separate database\nquery.\n\nTo illustrate, suppose a query takes 3 seconds to complete and the incoming\ntraffic is 10 requests per second (for the same resource). On a cache miss,\nwe'll end up with 30 identical database queries before we start serving the\nresource from the cache!\n\nThe longer it takes for a query to complete and the higher the incoming\ntraffic, the larger the load on the database. This can result in slow response\ntimes or even a complete outage. (looking at you, Facebook)\n\nThe core of the problem is that requests aren't aware of each other. They act\nindependently which leads to duplicate work. Ideally, requests should know\nabout one another and reuse pending work.\n\nOne way to solve a cache stampede is to introduce a locking mechanism. On a\ncache miss, a request tries to acquire a lock for a particular resource and\nrecompute it only if it has acquired a lock.\n\n## Implement locks using promises\n\nAn ingenious way of implementing a locking mechanism is to use promises.\nInstead of storing the value in the cache, we store the corresponding promise.\n\nWe can make use of the fact that promises are created synchronously, whereas\nquery results are returned asynchronously. This ensures that with multiple\nconcurrent requests, only the first request will propagate a query to the\ndatabase. Subsequent requests will reuse the same promise and wait until it\nfulfills.\n\nLet's look at some code.\n\nBelow, we have a getUser function that takes a user ID and returns a promise\nthat fulfills with the user object. The function first checks if there is a\npromise for that particular user ID in the cache. If there is, return the\npromise. If there isn't, initiate a query to get the user from the database\nand store the resulting promise in the cache before returning it.\n\n    \n    \n    const userPromiseCache = new Map(); function getUser(userId) { // If the promise is not stored in the cache, fetch the user from DB // and store the resulting promise in the cache if (!userPromiseCache.has(userId)) { const userPromise = db.findUserById(userId) .catch((error) => { // Have the promise remove itself from the cache if it rejects userPromiseCache.delete(userId); return Promise.reject(error); }); // Store promise in the cache userPromiseCache.set(userId, userPromise); } // Return the promise from cache return userPromiseCache.get(userId); }\n\nNotice the error handler attached to the promise. It ensures the promise will\nremove itself from the cache if it rejects. Otherwise, we'll end up caching\nthe rejection and future requests will return an error. It's ok to use the\n.catch() method here since there's no other way. Generally though, you want to\navoid mixing Promise.then() with async/await syntax.\n\nBecause the promise is created and returned synchronously, subsequent calls\nwith the same user ID are guaranteed to reuse the same promise.\n\nUsually, a locking mechanism involves complex logic for lock acquisition. This\ntechnique gives you simple and straightforward locks.\n\nPromises are a language-specific construct and this technique works only for\nin-memory cache inside JavaScript code. For external cache storages like\nRedis, you'll need to manually implement locking using a Pub/Sub pattern.\n\n## Memoizing promises\n\nSeen from another angle, this cache implementation is just memoizing the\ngetUser function. When we call the function with the same userId, we get the\nsame cached result (a promise).\n\nMemoization is an optimization technique that stores the results of expensive\nfunction calls and returns the cached result when the same inputs occur again.\n\nThere are several libraries in the JavaScript ecosystem that help with\nmemoization, including memoizee. We can simplify the above implementation to\njust:\n\n    \n    \n    import memoizee from \"memoizee\"; const getUser = memoizee( (userId) => db.findUserById(userId), { promise: true } );\n\nWith promise: true we let the library know that the function returns a\npromise. It will then make sure to remove promise rejections like we manually\ndid earlier.\n\nLooks clean, doesn't it?! \u2728\n\nMake sure you have a cache eviction policy in place to avoid outgrowing your\napplication's memory limits. In memoizee, you can limit the cache size with\nthe max property.\n\nYou have now learned the peril of caching asynchronous values and how to avoid\nit. With this knowledge in hand, you're ready to implement a robust cache with\nmore cache hits!\n\n## Master Asynchronous JavaScript \ud83d\ude80\n\nLearn how to write modern and easy-to-read asynchronous code with a FREE 5-day\nemail course.\n\nThrough visual graphics you will learn how to decompose async code into\nindividual parts and put them back together using a modern async/await\napproach. Moreover, with 30+ real-world exercises you'll transform knowledge\ninto a practical skill that will make you a better developer.\n\nGet Lesson 1 now \ud83d\udc47\ud83c\udffc\n\nYou'll also get tips on building scalable Node.js applications about twice a\nmonth. I respect your email privacy. Unsubscribe any time.\n\n### You might also like\n\n### 14 Linting Rules To Help You Write Asynchronous Code in JavaScript\n\nA compiled list of linting rules to specifically help you with writing\nasynchronous code in JavaScript and Node.js.\n\nRead article\n\n### Why You Shouldn't Mix Promise.then() With Async/Await Syntax\n\nMixing Promise.then() with async/await syntax is a recipe for bugs. Here's why\nyou should avoid it and what to do instead.\n\nRead article\n\n### Using Callbacks With Async/Await\n\nHow do you make a callback-based asynchronous function work nicely with\nasync/await? You promisify it.\n\nRead article\n\nCopyright 2019-2024\n\nDesign by Marli Creative\n\n", "frontpage": false}
