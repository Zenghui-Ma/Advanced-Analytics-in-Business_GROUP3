{"aid": "40111146", "title": "Shared libs, rpath and the runtime linker", "url": "https://carlosrdrz.dev/shared-libs-rpath-and-the-runtime-linker", "domain": "carlosrdrz.dev", "votes": 1, "user": "carlosrdrz", "posted_at": "2024-04-22 03:12:20", "comments": 0, "source_title": "Shared libs, rpath and the runtime linker", "source_text": "Shared libs, rpath and the runtime linker\n\n# carlosrdrz.dev\n\n# Shared libs, rpath and the runtime linker\n\nSun 21 April 2024\n\nLinux\n\nIf you are like me, maybe you understand that binaries can have statically or\ndynamically linked dependencies (shared libs) with each strategy having its\nown set of pros and cons. Maybe you also know that when a binary has shared\nlibs, you can use ldd to learn more about which shared libraries that binary\nis using, and where they specifically are located in the file system.\n\nThis is the story of how troubleshooting why a binary refused to run, I ended\nup learning a ton more about shared libraries.\n\n# The problem\n\nI was working on compiling the code for a project. The idea was to check if we\ncould use our own compiling toolchain instead of CMake, which was the one\ncommonly used for that project until then. This would bring a bunch of\nbenefits because of integrations with lots of other tools.\n\nWe made good progress and managed to have something that successfully\ncompiled, but the problem was that when we tried to run the binary, we were\ngetting an error like this:\n\n    \n    \n    \u279c ./run_server ./run_server: error while loading shared libraries: liblz4.so.1: cannot open shared object file: No such file or directory\n\nNaturally, this being a problem with a shared library that couldn't be found,\nI expected ldd would indeed show that there was a library missing:\n\n    \n    \n    \u279c ldd ./run_server linux-vdso.so.1 (0x00007ffd9dfa5000) liblz4.so.1 => /lib64/liblz4.so.1 (0x00007fa0eb31a000) libz.so.1 => /lib64/libz.so.1 (0x00007fa0eb300000) ...\n\n> Note: ... means there is (irrelevant) output omitted\n\nInstead, it turns out that some of them were not found, but liblz4.so.1\nspecifically (the one the error was complaining about) was found! I found that\nvery surprising. How come ldd finds it, but when we run the binary, it does\nnot? Remember this, because we will come back to it later!\n\nMy initial thought was: okay, maybe the shared lib location is a symlink\npointing to nowhere, or maybe it had the wrong permissions. The error very\nclearly says \"No such file or directory\" but I guess it doesn't hurt to check:\n\n    \n    \n    \u279c ls -la /lib64/libz.so.1 lrwxrwxrwx 1 root root 14 Oct 30 02:16 /lib64/libz.so.1 -> libz.so.1.2.11 \u279c ls -la /lib64/libz.so.1.2.11 -rwxr-xr-x 1 root root 102672 Oct 30 02:16 /lib64/libz.so.1.2.11\n\nIt's all good. Others should have permission to access the dir and read the\nlibrary, which makes sense. Probably something much bigger would be broken if\nthat wasn't the case.\n\nSince it seems /lib64 does indeed contain that lib, I thought I could use\nLD_LIBRARY_PATH to force the binary to check in /lib64. I was pretty confident\nthis wouldn't make any difference because that's a pretty standard directory\nfor shared libs, and because ldd said the lib could be found there (which\nmeant that it was already checking that path).\n\n    \n    \n    \u279c LD_LIBRARY_PATH=/lib64/ ./run_server ./run_server: error while loading shared libraries: libthird-party_zlib_z.so: cannot open shared object file: No such file or directory\n\nSurprisingly, too, it started complaining about a different lib (libthird-\nparty_zlib_z.so), so indeed it seems /lib64 was not being used after all.\n(Remember this, too!)\n\nStill, as we can see, there are more libraries not found anyway, so that\ndidn't solve much.\n\nI was running out of ideas, so I turned to the internet. Initially, some\nGoogle searches, until I eventually went to my favorite LLM for this sort of\nquestion. \"Maybe it'll help?\" - I thought.\n\nIt required some prompt engineering since the initial suggestions were way too\nbasic, but after a while, it recommended I check if the binary had something\ncalled rpath set. It suggested a command to check that.\n\n    \n    \n    \u279c readelf -d ./run_server | head -n 10 Dynamic section at offset 0xbf93cf8 contains 67 entries: Tag Type Name/Value 0x000000000000000f (RPATH) Library rpath: [$ORIGIN/./__libs__] 0x0000000000000001 (NEEDED) Shared library: [liblz4.so.1] 0x0000000000000001 (NEEDED) Shared library: [libz.so.1] ...\n\nOh, so it is set! What is this? A linker flag?\n\nLet's check the man pages:\n\n    \n    \n    \u279c man ld ... -rpath=dir Add a directory to the runtime library search path. This is used when linking an ELF executable with shared objects. All -rpath arguments are concatenated and passed to the runtime linker, which uses them to locate shared objects at runtime. ... The tokens $ORIGIN and $LIB can appear in these search directories. They will be replaced by the full path to the directory containing the program or shared object in the case of $ORIGIN and either lib - for 32-bit binaries - or lib64 - for 64-bit binaries - in the case of $LIB. ...\n\nIt turns out that when a binary has a rpath set, it adds that path to the\nruntime search paths (LD_LIBRARY_PATH, ldconfig, etc). The question is: why\ndid my binary have a rpath? And why couldn't the linker find the lib in that\ndirectory?\n\nI could only guess, but after spending some time learning about rpath and our\ntoolchain, I concluded that all of this had to do with ensuring isolation\nbetween what I was building and whatever shared libs were installed in my\nsystem.\n\nInstead of simply running my binary against the shared libs installed in the\nsystem, the compile toolchain knows exactly which versions of those shared\nlibs to use (since they are marked as dependencies), so it drops them in a\nfolder, and sets rpath to that folder to ensure those are used (instead of the\nsystem's).\n\nThe value of rpath in my binary was: $ORIGIN/./__libs__. The key thing to\nunderstand here is $ORIGIN, which means the path is relative to the binary\npath.\n\nIt turns out I broke all of this because I copied the binary from the location\nwhere the toolchain created the binary to somewhere in /tmp, completely\nunaware of the fact that the binary was (silently, I must say) referencing\nlibraries with a relative path.\n\nOnce that was understood, the possible solutions were straightforward: Symlink\nthe file instead of copying it, or simply use it from that original path.\n\n# The mystery is not fully solved\n\nHaving fixed my issue, I was happy I could continue with my original goal.\n\nBut there was a question in the back of my mind that was bothering me: Why was\nthe binary complaining about not finding the shared lib, if ldd found it in\n/lib64?\n\nEven accounting for the issue that I caused by copying the binary somewhere\nelse, surely if ldd was finding the lib in /lib64, the binary should find it\nas well, and run with that version.\n\n    \n    \n    \u279c ./run_server ./run_server: error while loading shared libraries: liblz4.so.1: cannot open shared object file: No such file or directory \u279c ldd ./run_server linux-vdso.so.1 (0x00007ffd9dfa5000) liblz4.so.1 => /lib64/liblz4.so.1 (0x00007fa0eb31a000) libz.so.1 => /lib64/libz.so.1 (0x00007fa0eb300000) [ ... ]\n\nAs mentioned, when running the binary, it complains liblz4.so.1 does not\nexist, but surprisingly ldd can find it in /lib64/liblz4.so.1. Isn't that\nweird?\n\nTo understand what is going on, I had to learn more about how these binaries\nload these shared libraries, so let's go and do that.\n\nUsually, binaries deployed in Linux are ELF binaries. ELF binaries can be\nstatically linked, or dynamically linked, which means libraries need to be\nlinked at runtime. This process of linking shared libraries is done by a piece\nof software called the \"linker runtime\" (which usually is ld.so when using\nlibc).\n\nThe question here is: when executing an ELF binary, how do we know where to\nfind the runtime linker?\n\nIt turns out every ELF binary includes a \"program header\" called .interp where\nthat is specified. Here's an example using bash:\n\n    \n    \n    \u279c readelf -l /usr/bin/bash Elf file type is DYN (Shared object file) Entry point 0x31d30 There are 13 program headers, starting at offset 64 Program Headers: [...] INTERP 0x0000000000000318 0x0000000000000318 0x0000000000000318 0x000000000000001c 0x000000000000001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] [...]\n\nMost binaries specify the default runtime linker, which is at /lib64/ld-\nlinux-x86-64.so.2 in Linux.\n\nInterestingly, you can call this runtime directly to get more information:\n\n    \n    \n    \u279c /lib64/ld-linux-x86-64.so.2 /lib64/ld-linux-x86-64.so.2: missing program name Try '/lib64/ld-linux-x86-64.so.2 --help' for more information. \u279c /lib64/ld-linux-x86-64.so.2 --help Usage: /lib64/ld-linux-x86-64.so.2 [OPTION]... EXECUTABLE-FILE [ARGS-FOR-PROGRAM...] You have invoked 'ld.so', the program interpreter for dynamically-linked ELF programs. Usually, the program interpreter is invoked automatically when a dynamically-linked executable is started. You may invoke the program interpreter program directly from the command line to load and run an ELF executable file; this is like executing that file itself, but always uses the program interpreter you invoked, instead of the program interpreter specified in the executable file you run. Invoking the program interpreter directly provides access to additional diagnostics, and changing the dynamic linker behavior without setting environment variables (which would be inherited by subprocesses). --list list all dependencies and how they are resolved --verify verify that given object really is a dynamically linked object we can handle --inhibit-cache Do not use /etc/ld.so.cache --library-path PATH use given PATH instead of content of the environment variable LD_LIBRARY_PATH [ ... ]\n\nThis runtime linker is used to find out the dependencies (shared libraries)\nthat are required for a binary to run. Then, depending on how it has been\nconfigured (using something like ldconfig) those libraries are resolved (found\nin the filesystem) and linked at runtime.\n\nWe can use this runtime linker to run any binaries. For example, this will\nresolve bash dependencies, resolve them, link them, and run bash, which ends\nup dropping me in a bash shell:\n\n    \n    \n    \u279c /lib64/ld-linux-x86-64.so.2 /usr/bin/bash [carlosrdrz@myserver ~]$\n\nThe thing is, to avoid having you prepend every command with its runtime\nlinker, whatever runs the ELF binary does it for you. It reads that .interp\nsection, finds the right runtime linker and calls it to run the binary, so the\nprevious call is equivalent to simply doing:\n\n    \n    \n    \u279c /usr/bin/bash [carlosrdrz@myserver ~]$\n\nAlright so now we know how things run, but how can we print the list of\ndependencies required for a binary to run? You might have noticed there are\nsome arguments we can use in the runtime linker to get info about it, for\nexample:\n\n    \n    \n    \u279c /lib64/ld-linux-x86-64.so.2 --list /usr/bin/bash linux-vdso.so.1 (0x00007ffcff56a000) libtinfo.so.6 => /lib64/libtinfo.so.6 (0x00007f7cac760000) libc.so.6 => /lib64/libc.so.6 (0x00007f7cac400000) /lib64/ld-linux-x86-64.so.2 (0x00007f7cac8f4000)\n\nThat's useful! And at the same time looks very similar to what ldd provides.\nSo, what is ldd doing?\n\nI was surprised when I learned this:\n\n    \n    \n    \u279c whereis ldd ldd: /usr/bin/ldd /usr/share/man/man1/ldd.1.gz \u279c readelf -l /usr/bin/ldd readelf: /usr/bin/ldd: Error: Not an ELF file - it has the wrong magic bytes at the start \u279c file /usr/bin/ldd /usr/bin/ldd: Bourne-Again shell script, ASCII text executable\n\nldd is a script! I've always assumed it was a binary for some reason. We can\nread its code and see what it does, or even better, we could just run it with\nbash -x and see what it does.\n\n    \n    \n    \u279c bash -x /usr/bin/ldd /usr/bin/bash + TEXTDOMAIN=libc + TEXTDOMAINDIR=/usr/share/locale + RTLDLIST='/lib/ld-linux.so.2 /lib64/ld-linux-x86-64.so.2 /libx32/ld-linux-x32.so.2' + warn= [ ... ] reducing some output here for brevity [ ... ] +++ LD_TRACE_LOADED_OBJECTS=1 +++ LD_WARN= +++ LD_BIND_NOW= +++ LD_LIBRARY_VERSION= +++ LD_VERBOSE= +++ /lib64/ld-linux-x86-64.so.2 /usr/bin/bash linux-vdso.so.1 (0x00007fff40151000) libtinfo.so.6 => /lib64/libtinfo.so.6 (0x00007f3acff3c000) libc.so.6 => /lib64/libc.so.6 (0x00007f3acfc00000) /lib64/ld-linux-x86-64.so.2 (0x00007f3ad00d0000) + return 0 + exit 0\n\nI think there are two things to notice from that (or by analyzing the script\ndirectly):\n\n  * There is a hardcoded list of possible runtime linkers\n  * ldd is simply calling /lib64/ld-linux-x86-64.so.2 with some env variables, which makes it print the shared libs dependencies.\n\nSo we've just learned that it turns out you can do this to get the list of\nshared libs for a binary:\n\n    \n    \n    \u279c LD_TRACE_LOADED_OBJECTS=1 /lib64/ld-linux-x86-64.so.2 /usr/bin/bash linux-vdso.so.1 (0x00007ffecb94b000) libtinfo.so.6 => /lib64/libtinfo.so.6 (0x00007f181395f000) libc.so.6 => /lib64/libc.so.6 (0x00007f1813600000) /lib64/ld-linux-x86-64.so.2 (0x00007f1813af3000)\n\nOr also this (because as I said, the right runtime linker will get called\nanyway)\n\n    \n    \n    \u279c LD_TRACE_LOADED_OBJECTS=1 /usr/bin/bash linux-vdso.so.1 (0x00007ffecb94b000) libtinfo.so.6 => /lib64/libtinfo.so.6 (0x00007f181395f000) libc.so.6 => /lib64/libc.so.6 (0x00007f1813600000) /lib64/ld-linux-x86-64.so.2 (0x00007f1813af3000)\n\nSo... you might be guessing where am I going with all of this.\n\nWhat happens if you specify your own .interp header in your binaries?\n\n    \n    \n    \u279c readelf -l ./run_server Elf file type is EXEC (Executable file) Entry point 0x37bb540 There are 12 program headers, starting at offset 64 Program Headers: [...] INTERP 0x00000000000002e0 0x00000000002002e0 0x00000000002002e0 0x0000000000000028 0x0000000000000028 R 0x1 [Requesting program interpreter: /usr/local/platform/lib/ld.so] [...]\n\nWhen you specify your own runtime linker, it will be used for resolving all\nthose shared libraries.\n\nWhat you might not expect is that, if ldd does not have those runtime linkers\nin its hardcoded list of runtime linkers, it will simply try to use the\ndefault one, so its output will be completely useless to you. ldd will ask\n/lib64/ld-linux-x86-64.so.2 to print the shared libs, but ultimately, when\nrunning the binary, it is a different runtime linker linking those shared\nlibraries!\n\nRemember that weird thing where setting LD_LIBRARY_PATH to /lib64 when running\nour binary made it find one of the libs? Maybe now you can guess what was\ngoing on!\n\n/lib64/ld-linux-x86-64.so is hardcoded to look for libs in some default paths,\nlike /lib64, whereas /usr/local/platform/lib/ld.so (being a company-specific\nthing) was not (because of reasons I won't elaborate now).\n\nWhen using ldd, the default runtime linker was being used, so it found the lib\nin /lib64, but when running the binary, the company runtime linker was used,\nand therefore the lib couldn't be found. When I set LD_LIBRARY_PATH to /lib64,\nit added that \"default\" dir to the runtime search dir, and made it available.\n\n# Learnings\n\nAside from the satisfaction of resolving a good old troubleshooting mystery,\nthere are some good learnings here that could be useful in the future.\n\nFirst, that whole thing about rpath is something we might find in the future.\nIt's good to know that sometimes binaries reference shared libs using relative\npaths, and ldd is not very clear about that happening. Copying a binary to a\ndifferent directory might make it not work!\n\nAlso, most importantly, the easiest way to get the source of truth from the\nruntime linker is to run your binary using LD env vars, since that ensures\nthat the right runtime linker is giving you that information.\n\nFor example:\n\n    \n    \n    \u279c LD_TRACE_LOADED_OBJECTS=1 $YOUR_BINARY\n\nor:\n\n    \n    \n    \u279c LD_DEBUG=libs $YOUR_BINARY\n\nThose will print a lot of information about shared library usage in your\nbinary, and you will be sure those are being printed by the real runtime\nlinker.\n\nIt's worth clarifying that this assumes a libc linker, whereas other projects\n(for example musl) use a different runtime linker that might not support these\nenv vars and might have different mechanisms to figure this out.\n\nYou can also find more about this env vars with man ld.so.\n\nHaving said all of that, the main issue continued to be the same: I moved my\nbinary to a different folder, it had an rpath, and most of the libraries were\nin that rpath directory, so they could not be found.\n\nTruth be told, though, using ldd didn't help much with troubleshooting. In\nfact, it probably made things more difficult, since it wasn't aware of the\nbinary using a different runtime linker, which made it give completely\nincorrect results.\n\nA couple of warnings would have been nice! Maybe \"rpath folder does not exist\"\nor \"runtime linker not found\"? That would have been useful!\n\n## links\n\n  * Twitter\n\n## social\n\n  * atom feed\n\n", "frontpage": false}
