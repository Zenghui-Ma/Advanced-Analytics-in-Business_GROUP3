{"aid": "40047808", "title": "Code Locality Concerns (2023)", "url": "https://chrisgriffing.com/blog/code-locality-concerns", "domain": "chrisgriffing.com", "votes": 1, "user": "mooreds", "posted_at": "2024-04-16 02:27:39", "comments": 0, "source_title": "Code Locality Concerns", "source_text": "Code Locality Concerns | Chris Griffing\n\n# Chris Griffing\n\nA Collection of Random Ramblings and Eclectic Interests\n\n## Code Locality Concerns\n\n### September 20, 2023\n\nRecently, on stream, I needed to focus an element. It wasn't focusing until I\nkicked the focus to the next iteration of the event loop. There are a few ways\nto do such a thing and it brought up a concern I had about code locality vs\nbeing idiomatic.\n\nIn this particular case, it came down to a useEffect vs a setTimeout with a\ntimeout value of 0.\n\n## The Problem\n\nI have a search button on the marketing and documentation site for Vexilla at\nhttps://vexilla.dev. After a recent co-stream with GrahamTheDev and Todd\nLibby, I discovered that there was a focus issue with my \"Search\"\nfunctionality. When a user tabs to the button and activates, they can search\nusing Pagefind. If they close the modal, it should refocus the button that\nthey used to show the modal.\n\nIt turns out that this was not as simple as it should have been. I made a\nuseRef and attached it to the button. The ref itself was resolving to the HTML\nelement as expected, but the focus() wasn't actually focusing the button.\n\nFirst, we made sure that the element could be focused via dev tools and\nfocus(). Yup. Worked as expected. So it wasn't just an issue of the button not\nbeing the right ref.\n\n## The fix\n\nI'm not 100% certain about the \"why\" of the problem. It seems like maybe cmdk\nis doing something funky with their backdrop when the dialog is showing. A\nviewer suggested a useEffect which ended up working. Once I knew that a\nuseEffect fixed it it became apparent what was happening. We were trying to\nfocus something that may have been currently unfocusable due to the backdrop.\n\nHere is an example of the useEffect approach:\n\n    \n    \n    export function Search() { const [open, setOpen] = useState(false); // ... useEffect(() => { if (!open) { searchButtonRef.current?.focus(); } }, [open]); return ( <> <Button> /* ... */ </Button> <CommandDialog open={open} onOpenChange={(open) => { if (!open) { setOpen(false); } }} > // ...\n\nHere is an example of the setTimeout code:\n\n    \n    \n    export function Search() { const [open, setOpen] = useState(false); // ... return ( <> <Button ref={searchButtonRef}> /* ... */ </Button> <CommandDialog open={open} onOpenChange={(open) => { if (!open) { setOpen(false); // need to kick the focus to next iteration of the event loop // similar to a useEffect with open as the dependency setTimeout(() => { if (searchButtonRef.current) { searchButtonRef.current.focus(); } }, 0); } }} > // ...\n\n## The Concern\n\nSince we knew what the issue was now, it was down to a matter of preference.\n\nThe \"idiomatic\" approach would indeed be the useEffect. However, I feel like\nthis introduces a layer of indirection. Rather than being able to see the\nfocus happen in the context of the close event, it became something you would\nhave to venture outside of that context to understand.\n\nAnother approach would be to use a setTimeout with a timeout of 0 to kick the\nfocus() to the next iteration of the event loop. I prefer this approach\nbecause it exists within the event handler's context.\n\nYou could make the argument that a useEffect makes sense because the focus is\na side effect of state changing. I think that the event was already its own\nside effect because user interaction (and an event caused by it) is a side\neffect by definition when thinking about functional programming. The user\nitself is a side effect.\n\n## Code Locality\n\nIn my opinion, code locality becomes more important than being idiomatic\nsometimes, especially in this case. The moment you have to look outside of the\nevent's context you have introduced a context switch to the developer. You can\nfind all sorts of articles about general context switching on the internet.\nThey often focus on the context switch of going from your code editor to your\nemail client or a meeting/etc. I think it is an underappreciated version of\ncontext switch to go from one part of the codebase to another.\n\nIn the same way that every abstraction incurs a cost, so does every\nindirection, for the same reasons. Leaving your original context forces you to\nmaintain that state in working memory. In the case of this exact problem, the\ncontext is the event that is triggered when changing opened/closed state.\nNeeding to go to a useEffect that is outside the scope of that event is a\nneedless indirection that actually ONLY relates to the event in the first\nplace.\n\nSo, how do you feel about it? Am I wrong? No, its the kids that are wrong...\nJust kidding, but that was a good reference, right?\n\n#### Streaming\n\nsee more\n\nI live-code on Twitch. We are always looking for sponsors and partnered\ncontent. Check it out.\n\n#### Other Blog Posts\n\n  * ##### Code Locality Concerns\n\n  * ##### Considering 'Considered Harmful' Essays Still Being Harmful\n\n  * ##### Side Project Hell: It's not as bad as you think\n\n  * ##### E2E Testing Expo Apps with Detox\n\n  * ##### Interface Driven Validation and API Documentation for Typescript\n\n  * ##### Porting nanostores to lua\n\n  * ##### Like a Git Machine\n\n  * ##### neovim-treesitter is Awesome\n\n  * ##### Why Feature Flags?\n\n  * ##### Have yourself a VSCode Biscuit\n\n\u00a9 2023 Chris Griffing\n\n", "frontpage": false}
