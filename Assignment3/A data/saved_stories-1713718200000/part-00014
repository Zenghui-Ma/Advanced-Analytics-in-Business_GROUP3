{"aid": "40103407", "title": "Programming Is Mostly Thinking", "url": "http://agileotter.blogspot.com/2014/09/programming-is-mostly-thinking.html", "domain": "agileotter.blogspot.com", "votes": 23, "user": "ingve", "posted_at": "2024-04-21 05:40:07", "comments": 3, "source_title": "Programming Is Mostly Thinking", "source_text": "Agile Otter Blog: Programming Is Mostly Thinking\n\nTim Ottinger's thoughts on Software Development.\n\n## Monday, September 29, 2014\n\n### Programming Is Mostly Thinking\n\n> Pretend you have a really great programming day.\n\n> You only have to attend a few meetings, have only a few off-topic\n> conversations, don't get distracted or interrupted much, don't have to do a\n> bunch of status or time reporting, and you put in a good six hours of\n> serious programming [note: this RARELY happens in an 8-10 hour day].\n\n> I want to review your work in the morning, so I print out a diff of your\n> day's work before going home.\n\n> Sadly, overnight the version control system crashes and they have to recover\n> from the previous day's backup. You have lost an entire day's work.\n\n> If I give you the diff, how long will it take you to type the changes back\n> into the code base and recover your six-hours' work?\n\n### Programming is 11/12ths Thinking\n\nI've been touting this figure for some time now, and people keep asking me\nwhere the study is that produced such an odd number.\n\nWell, it's not pulled out of thin air and it's not the result of a thorough\nscientific study.\n\nI have done informal polls now for a few years, though I've not kept good\nrecords. My goal was not to become the scientist who cracks the\nstatistical/mathematical code for programming activities. I was looking for a\nreasonable answer to a reasonable question.\n\nHowever, this answer surprised me. In a long Quora post titled \"How do\nprogrammers code so quickly?\" one responder offered that it was a combination\nof physical skills (muscle memory, skill with tools, debugging skills, typing\nskill) and knowing where to search for info. His post was swamped and\noverwhelmed by posts explaining that typing and tools are not the most\nimportant aid to quick code production.\n\n### Software Factories\n\nI have seen the stickers and slogans on stickers and social media for a long\ntime that \"typing is not the bottleneck\" (though every once in a while the\ninability of some programmers to type is a bottleneck).\n\nI am keenly aware that most management still subscribes to the idea that\nmotion is work. They are fairly convinced that a lack of motion is a lack of\nwork. That makes sense in a lawn care service, a factory assembly line, or a\nwarehouse operation.\n\nNearly all of the visible work done in producing physical goods is motion.\nPeople roll steel, stamp, press, mill, pick and place, bolt/screw/rivet, and\non.\n\nModern factories produce goods with Computer Numerical Control machines, which\nproduce perfect copies of an original model that may not even exist in real\nlife. These machines work from abstract models -- just data, really -- and\nperform perfect motion. Humans tend the machines, rather than working the wood\nby hand.\n\nI have some great guitars that were produced at affordable costs because of\nthe degree of automation brought by such machines.\n\nGreat boutique guitars are produced entirely by hand at higher cost and I\ndon't put down that effort either. The world has room for both.\n\nSoftware developers have perfected the factory. It runs flawlessly bit-perfect\ncopies. You just click the \"copy\" or \"download\" button. It's so cheap that the\npurchasers happily cover the costs of the factory. Those who are cautious will\ndouble check the checksums that come with the download, but most people don't\nbother. The machines are reliable and efficient and quick and cheap.\n\nOnce the initial model (really, just data) exists, then the marginal cost of\nall the bit-perfect copies is essentially zero. Yes, this is just copying and\nnot creating, but that's what factories do. Custom shops might produce unique\nitems (like guitars) but factories create copies of originals.\n\nThe software factory tends to give you a progress bar, so you can visualize\nthe motion of bits, but in many ways you can say that the product doesn't\nreally exist. It's a pattern of tiny charged v. uncharged areas of metal on a\nplate (well, probably) and you don't even pay for the plate or the magnet or\nthe laser when you create the copy. It's already there.\n\nSoftware is an intellectual good.\n\n### The Design Shop\n\nIn my years of working with Uncle Bob Martin, I heard him continually tell\ncustomers and students that software development is not a fabrication\noperation, but a design operation. Once the initial design is done, all the\nduplication is done by machines at nearly zero cost.\n\nSo what programmers and testers and POs and Scrum Masters and software\nmanagement area all doing (if they're doing it right) is designing the data\nmodel that will later be used by the factory to create copies for use by\ncustomers, patrons, and other people in the community the software is intended\nto serve.\n\nYet the mechanistic, Industrial-Age idea of software development as a factory\npersists, and developers dutifully try to make it look like they're doing\nphysical labor at the detriment of the process.\n\nAll intellectual activities are hard to observe and monitor. An idea that is\n80% complete has no physical manifestation. It's an idea, and it's not done\nyet. Sometimes we have experiments or proof-of-concept code or notes, but they\ndon't give an accurate \"% complete\" number as does physical work.\n\nA chair being manufactured looks about 50% done at the 50% mark. When it's\ndone, it looks done.\n\nA design for a chair may not exist on paper until it is more than 70%\ncomplete. And we don't know that it's really 70% done, because it's not\nfinished being designed yet.\n\n### The Answer: Really?\n\nI have asked this question at conventions, client companies, to my peers, to\ncolleagues, and to strangers I have met for the first time when I find out\nthey are programmers.\n\nThe answer I receive most often is \"about half an hour.\"\n\nI could use the 8-hour day, ignoring meetings and interruptions and status\nreports, but that feels like padding the answer. I stick to the six hours\ndoing things that programmers identify as programming work.\n\nThere are twelve half-hours in six hours. One half-hour to retype all the\nchanges made in six hours of hard programming work.\n\nWhat in the world can that mean? How can it be so little?\n\n### The Meaning Behind the Answer\n\nRight now I suspect a bunch of managers are about to go yell at their\nprogrammers for putting in a half-hour's work in an 8-hour day! That would be\na horrible misunderstanding of what was actually happening.\n\nWhat is really happening?\n\n  * Programmers were typing on and off all day. Those 30 minutes are to recreate the net result of all the work they wrote, un-wrote, edited, and reworked through the day. It is not all the effort they put in, it is only the residue of the effort.\n  * Programmers are avoiding defects as best they can. In order to do that, they have to be continuously evaluating the code as they write it, hypothesizing the kinds of defects or security vulnerabilities they might be introducing. After all, they receive their harshest criticism for introducing defects into the shared code base.\n  * Programming is a kind of lossy compression. The code only says what the program must do when it is running. Why a programmer chose one particular way over others, how it influences the rest of the system, what errors were introduced and removed, and what pitfalls it avoids are not (generally) present in the text of the program.\n  * Most of the work is not in making the change, but in deciding how to make the change. Deciding requires us to understand the code that already exists. This is especially time-consuming when the code is messy or the design is not very obvious in the source code.\n  * Programmers work in a social context since all their results are integrated into a shared code base (and most use pair programming or other \"many eyes\" techniques). Programmers may be helping other programmers or testers or operations people get a handle on their work. Connecting and communicating with others has benefits and costs that don't appear in the code.\n\nSix hours of intellectual work (reading, researching, deciding, confirming,\nvalidating, verifying) translates to about 30 minutes worth of net lines-of-\ncode change to a code base.\n\nThat's not additional lines of code. We often have weeks when we fix bugs and\nadd features and have fewer lines of code at end of the week than we had at\nthe beginning of the week. I once got in trouble for having multiple weeks\nwhere we had negative lines of code -- we didn't know the 'grand boss' over\nour team was reporting SLOC as if it measured progress. Sigh.\n\nProgrammers will gladly explain that the work they did was reading, learning,\nunderstanding, sometimes guessing, researching, debugging, testing, compiling,\nrunning, hypothesizing and disproving their ideas of what the code should look\nlike. In short, they were thinking and deciding.\n\nMost of what goes on is intellectual work.\n\nOne of the quora responders wrote:\n\n> You see the fingers flying over the keyboard; you don't see the hours spent\n> in talking to users, discussing the problems with coworkers, doing research\n> and thinking the problems through.\n\nAnother suggested:\n\n> I achieve it firstly (to the extent that I do) by 'helping' the customer to\n> eliminate the unnecessary notions from their idea, which they often\n> mistakenly call 'requirements' and sometimes even say they are 'must have'.\n> This is the biggest possible acceleration in the delivery of a solution\n> because I can do an infinite amount of no work in no time at all.\n\nAnd yet another:\n\n> Really good developers do 90% or more of the work before they ever touch the\n> keyboard; really understanding the requirements and devising an appropriate\n> solution.\n\nThese are not unique unusual answers. I find that most of the time, \"knowing\nwhat not to write\", \"doing less,\" \"working in smaller steps\", and \"having\nfirst figured out what to do\" are common answers. Programming is much more\nabout thinking than about typing.\n\nI have examined a lot of the change logs (diffs). It has consistently looked\nlike 30+/-10 minutes of change on a good day (at least to me).\n\nI'm confident enough to tout this number as effectively true, though I should\nmention that no company I work with has so far been willing to delete a whole\nday's work to prove or disprove this experiment yet. Remember, I have only\nestimates and examinations of daily diffs to work from. The result here is not\nscientific.\n\nI should also let you know that people who do more typing or more cut/paste\nare often doing less thinking and understanding, which results in more errors\nand more burden on other programmers to understand and correct their code.\n\nCode is just the residue of the work.\n\n### So What?\n\nIf programming is 1/12th motion and 11/12ths thinking, then we shouldn't push\npeople to be typing 11/12ths of the time. We should instead provide the\nmaterials, environment, and processes necessary to ensure that the thinking we\ndo is of high quality.\n\nDoing otherwise is optimizing the system for the wrong effect.\n\nWhat if we changed our tactics, and intentionally built systems for thinking\ntogether about software and making decisions easier to make? I think that\nproductivity lies in this direction.\n\nSo I invite you: how can you experiment with learning on-the-job to create\nsystems where the thinking is optimized?\n\nEmail ThisBlogThis!Share to TwitterShare to FacebookShare to Pinterest\n\n#### 1 comment:\n\n  1. A J MishraJune 29, 2023 at 12:09 AM\n\nThank you so much for such an informative blog post! Check out more about How\nto Ensure Quality in Software Development and share your thought about it.\n\nReplyDelete\n\nReplies\n\nReply\n\nAdd comment\n\nLoad more...\n\nNewer Post Older Post Home\n\nSubscribe to: Post Comments (Atom)\n\n## Grab The Feed\n\nPosts\n\nAtom\n\nPosts\n\nComments\n\nAtom\n\nComments\n\n## Tell Me Anonymously\n\nIn addition to comments (which everyone sees) you can also leave me an\nanonymous comment at SayAt.Me\n\n## Buy Me A Taco!\n\nYou can send a donation, perhaps the price of a taco, via\npaypal.me/TimOttinger\n\n## Industrial Logic\n\nWe at Industrial Logic have taken our practice beyond run-of-the-mill Agile or\nScrum or even XP. We are now \"anzeneers.\" We build safely to build safety for\nall.\n\n## Popular Posts\n\n  * Preserving Wasteful Practices\n\nHabit is powerful. Inhabitants of intersection set People who place symbolic\nvalue on the wasteful practice People who have bu...\n\n  * Is It My Fault You Can't Handle The Truth?\n\nYou can't handle it! In 2018 or 2019, I was introduced to the idea of hyper-\nrationality. I think it was under another name (to ...\n\n  * Maximize Value, not Quantity\n\nI was chatting with a manager who was once a PO on a team I coached many years\nago. This is only my best memory of the conversation (I didn&...\n\n  * 14 Weird Observations About Agile Team Velocity\n\n(note: I added a 15th, but was worried that changing the title would\ninvalidate links, so you get a bonus observation at no extra cost) I ...\n\n  * Bug Teams v. The Nature Of Defects\n\nHow it Happens You realize that you're not getting as much done as you\nexpected to get done. It's troublesome because you have pl...\n\n  * I Want Agile Back\n\nNote: this was originally all plain text and a little shorter. As more people\nhave joined the conversation, and other supportive materia...\n\n  * Preplanning Poker: Is This Story Even Possible?\n\nThe story says \"attach an e-commerce server.\" Well, maybe it says \"As a\nproduct manager I want my system to incorporate an ...\n\n  * Programming Is Mostly Thinking\n\nPretend you have a really great programming day. You only have to attend a few\nmeetings, have only a few off-topic conversations, don&...\n\n  * Splitting Stories - A Resource Listicle\n\nI've noticed that for several years now, one of the most frequently asked\nquestions in agile forums deals with the splitting of stories...\n\n  * Defending Scrum Against Stupid Arguments\n\nI'm not a big scrum promoter, but I am VERY familiar with scrum and have\ncoached many teams and always been able to improve their succes...\n\n## Agile In A Flash\n\nGet your copy of Agile In A Flash today! Maybe outfit your whole team...\n\n## About Me\n\nAgileotter\n\nView my complete profile  \n---  \n  \nSimple theme. Theme images by gaffera. Powered by Blogger.\n\nDiese Website verwendet Cookies von Google, um Dienste anzubieten und Zugriffe\nzu analysieren. Deine IP-Adresse und dein User-Agent werden zusammen mit\nMesswerten zur Leistung und Sicherheit f\u00fcr Google freigegeben. So k\u00f6nnen\nNutzungsstatistiken generiert, Missbrauchsf\u00e4lle erkannt und behoben und die\nQualit\u00e4t des Dienstes gew\u00e4hrleistet werden.Weitere InformationenOk\n\n", "frontpage": true}
