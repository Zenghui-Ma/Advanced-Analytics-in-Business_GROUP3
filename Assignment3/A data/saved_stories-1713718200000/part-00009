{"aid": "40103378", "title": "J8 Notation \u2013 Fixing the JSON-Unix Mismatch", "url": "https://www.oilshell.org/release/latest/doc/j8-notation.html", "domain": "oilshell.org", "votes": 1, "user": "thunderbong", "posted_at": "2024-04-21 05:32:43", "comments": 0, "source_title": "J8 Notation - Fixing the JSON-Unix Mismatch", "source_text": "J8 Notation - Fixing the JSON-Unix Mismatch\n\nWhy Sponsor Oils? | source | all docs for version 0.20.0 | all versions | oilshell.org\n\n# J8 Notation - Fixing the JSON-Unix Mismatch\n\nJ8 Notation is a set of text interchange formats. It's a syntax for:\n\n  1. strings / bytes\n  2. tree-shaped records (like JSON)\n  3. line-based streams (like Unix)\n  4. tables (like TSV)\n\nIt's part of the Oils project, and is intended to solve the JSON-Unix\nMismatch: the Unix kernel deals with bytes, while JSON deals with Unicode\nstrings (plus UTF-16 errors).\n\nIt's backward compatible with JSON, and built on top of it.\n\nBut just like JSON isn't only for JavaScript, J8 Notation isn't only for Oils.\nAny language understands JSON should also understand J8 Notation.\n\n(Note: J8 replaced the similar QSN design in January 2024. QSN wasn't as\ncompatible with both JSON and YSH code.)\n\nTable of Contents\n\nQuick Picture\n\nGoals\n\nReference\n\nTODO / Diagrams\n\nJ8 Strings - Unicode and bytes\n\nReview of JSON strings\n\nJ8 Description\n\nWhat's representable by each style?\n\nAssymmetry of Encoders and Decoders\n\nYSH has 2 of the 3 styles\n\nJ8 Strings vs. POSIX Shell Strings\n\nJSON8 - Tree-Shaped Records\n\nReview of JSON\n\nJSON8 Description\n\nJ8 Lines - Lines of Text\n\nRelated\n\nTSV8 - Table-Shaped Text\n\nReview of TSV\n\nTSV8 Description\n\nDesign Notes\n\nSummary\n\nAppendix\n\nRelated Links\n\nFuture Work\n\nFAQ\n\nWhy are byte escapes spelled \\yff, and not \\xff as in C?\n\nWhy have both u'' and b'' strings, if only b'' is technically needed?\n\nWhy not use double quotes like u\"\" and b\"\"?\n\nHow do I write a J8 encoder and decoder?\n\nGlossary\n\n## Quick Picture\n\nThere are 3 styles of J8 strings:\n\n    \n    \n    \"hi \ud83d\ude42 \\uD83D\\uDE42\" # JSON-style, with surrogate pair b'hi \ud83d\ude42 \\yF0\\y9F\\y99\\y82' # Can be ANY bytes, including UTF-8 u'hi \ud83d\ude42 \\u{1F642}' # nice alternative syntax\n\nThey all denote the same decoded string \u2014 \"hi\" and two U+1F642 smiley faces:\n\n    \n    \n    hi \ud83d\ude42 \ud83d\ude42\n\nWhy did we add these u'' and b'' strings?\n\n  * We want to represent any string that a Unix kernel can emit (argv arrays, env variables, filenames, file contents, etc.)\n\n    * J8 encoders emit b'' strings to avoid losing information.\n  * u'' strings are like b'' strings, but they can only express valid Unicode strings.\n\nNow, starting with J8 strings, we define the formats JSON8:\n\n    \n    \n    { name: \"Alice\", signature: b'\\y01 ... \\yff', // binary data }\n\nJ8 Lines:\n\n    \n    \n    doc/hello.md \"doc/with spaces.md\" b'doc/with byte \\yff.md'\n\nand TSV8:\n\n    \n    \n    !tsv8 size name !type Int Str 42 doc/hello.md 55 \"doc/with spaces.md\" 99 b'doc/with byte \\yff.md'\n\nTogether, these are called J8 Notation.\n\n(JSON8 and TSV8 are still to be fully implemented in Oils.).\n\n## Goals\n\n  1. Fix the JSON-Unix mismatch: all text formats should be able to express byte strings.\n\n     * But it's OK to use plain JSON in Oils, e.g. when filenames are known to be strings.\n  2. Provide an option to avoid the surrogate pair / UTF-16 legacy of JSON.\n  3. Allow expressing metadata about strings vs. bytes.\n  4. Turn TSV into an exterior data frame format.\n\n     * Unix tools like awk, cut, and sort already understand tables informally.\n\nNon-goals:\n\n  1. \"Replace\" JSON. JSON8 is backward compatible with JSON, and sometimes the lossy encoding is OK.\n  2. Resolve the strings vs. bytes dilemma in all situations.\n\n     * Like JSON, our spec is syntactic. We don't specify a mapping from J8 strings to interior data types in any particular language.\n\n## Reference\n\nSee the Data Notation Table of Contents in the Oils Reference.\n\n### TODO / Diagrams\n\n  * Diagram of Evolution\n\n    * JSON strings \u2192 J8 Strings\n    * J8 strings as a building block \u2192 JSON8 and TSV8\n  * Venn Diagrams of Data Language Relationships\n\n    * If you add the left \"gutter\" column, every TSV is valid TSV8.\n    * Every TSV8 is also syntactically valid TSV. For example, you can import it into a spreadsheet, and remove/ignore the gutter column and type row.\n    * TODO: make a screenshot and test it\n  * Doc: How to turn a JSON library into a J8 Notation library.\n\n    * Issue: an interior type that can represent byte strings.\n\n## J8 Strings - Unicode and bytes\n\nLet's review JSON strings, and then describe J8 strings.\n\n### Review of JSON strings\n\nJSON strings are enclosed in double quotes, and may have these escape\nsequences:\n\n    \n    \n    \\\" \\\\ \\/ \\b \\f \\n \\r \\t \\u1234\n\nProperties of JSON:\n\n  * The encoded form must also be valid UTF-8.\n  * The encoded form can't contain literal control characters, including literal tabs or newlines. (This is good for TSV8, because it means a literal tab is always a field separator.)\n\n### J8 Description\n\nThere are 3 styles of J8 strings:\n\n  1. JSON strings \"\"\n  2. b'' strings\n  3. u'' strings\n\nb'' strings have these escapes:\n\n    \n    \n    \\yff # byte escape \\u{1f926} # code point escape. UTF-16 escapes like \\u1234 # are ILLEGAL \\' # single quote, in addition to \\\" \\\" \\\\ \\/ # same as JSON \\b \\f \\n \\r \\t\n\n(JSON-style double-quoted strings remain the same in J8 Notation; they do not\nadd the \\' escape.)\n\nExamples:\n\n    \n    \n    b'' b'hello' b'\\\\' b'\"double\" \\'single\\'' b'nul byte \\y00, unicode \\u{1f642}'\n\nu'' strings have all the same escapes, but not \\yff. This implies that they're\nalways valid unicode strings. (If JSON-style \\u1234 escapes were allowed, they\nwouldn't be.)\n\nExamples:\n\n    \n    \n    u'' u'hello' u'unicode string \\u{1f642}'\n\nA string without a prefix, like 'foo', is equivalent to u'foo':\n\n    \n    \n    'this is a u string' # discouraged, unless the context is clear u'this is a u string' # better to be explicit\n\n### What's representable by each style?\n\nThese relationships might help you understand the 3 styles of strings:\n\nStrings representable by u'' = All Unicode Strings (no more and no less)\n\n\u2282\n\nStrings representable by \"\" (JSON-style) = All Unicode Strings \u222a Surrogate\nHalf Errors\n\n\u2282\n\nStrings representable by b'' = All Byte Strings\n\nExamples:\n\n  * The JSON message \"\\udd26\" represents a string that's not Unicode \u2014 it has a surrogate half error. This string is not representable with u'' strings.\n  * The J8 message b'\\yff' represents a byte string. This string is not representable with JSON strings or u'' strings.\n\n### Assymmetry of Encoders and Decoders\n\nA few things to notice about J8 encoders:\n\n  1. They can emit only \"\" strings, possibly using the Unicode replacement char U+FFFD. This is a strict JSON encoder.\n  2. They must emit b'' strings to preserve all information, because U+FFFD replacement is lossy.\n  3. They never need to emit u'' strings.\n\n     * This is because \"\" strings (and b'' strings) can represent all values that u'' strings can. Still, u'' strings may be desirable in some situations, like when you want \\u{1f642} escapes, or to assert that a value must be a valid Unicode string.\n\nOn the other hand, J8 decoders must accept all 3 kinds of strings.\n\n### YSH has 2 of the 3 styles\n\nA nice property of YSH is that the u'' and b'' strings are valid code:\n\n    \n    \n    echo u'hi \\u{1f642}' # u respected in YSH, but not OSH var myBytes = b'\\yff\\yfe'\n\nThis is useful for correct code generation, and simplifies the language.\n\nBut JSON-style strings aren't valid in YSH. The two usages of double quotes\ncan't really be reconciled, because JSON looks like \"line\\n\" and shell looks\nlike \"x = ${myvar}\".\n\n### J8 Strings vs. POSIX Shell Strings\n\nWhen the encoded form of a J8 string doesn't contain a backslash, it's\nidentical to a POSIX shell string.\n\nIn this case, it can make sense to omit the u'' prefix. Example:\n\n    \n    \n    shell_string='hi \ud83d\ude42' var ysh_str = u'hi \ud83d\ude42' var ysh_str = 'hi \ud83d\ude42' # same thing\n\nAn encoded J8 string has no backslashes when the original string has all these\nproperties:\n\n  1. Valid Unicode (no non-UTF-8 bytes).\n  2. No ASCII control characters. All bytes are 0x20 and greater.\n  3. No backslashes or single quotes. (All other required escapes are control characters.)\n\n## JSON8 - Tree-Shaped Records\n\nNow that we've defined J8 strings, we can define JSON8, an obvious extension\nof JSON.\n\n### Review of JSON\n\nSee https://json.org\n\n    \n    \n    [primitive] null true false [number] 42 -1.2e-4 [string] \"hello\\n\" [array] [1, 2, 3] [object] {\"key\": 42}\n\n### JSON8 Description\n\nJSON8 is like JSON, but:\n\n  1. All strings can be J8 strings \u2014 one of the 3 styles describe above.\n  2. Object/Dict keys may be unquoted, like {age: 42}\n\n     * Unquoted keys must be a valid JS identifier name matching the pattern [a-zA-Z_][a-zA-Z0-9_]*.\n  3. Trailing commas are allowed on objects and arrays: {\"d\": 42,} and [42,]\n  4. C- and JavaScript-style single-line comments like //\n\n     * No block comments, and no # comments\n\nExample:\n\n    \n    \n    { name: \"Bob\", // comment age: 30, sig: b'\\y00\\y01 ... \\yff', // trailing comma, binary data }\n\n## J8 Lines - Lines of Text\n\nJ8 Lines is another format built on J8 strings.\n\nFor example, to represent represent 4 filenames, simply use 4 lines:\n\n    \n    \n    dir/my-filename.txt # unquoted string is JS name and . - / \"dir/with spaces.txt\" # JSON-style b'dir/with bytes \\yff.txt' # J8-style u'dir/unicode \\u{3bc}'\n\nLiteral control characters like newlines are illegal in J8 strings, which\nmeans that they always occupy one physical line.\n\n  * Leading spaces on each line are ignored, which allows aligning the quotes.\n  * Trailing spaces are also ignored, to aid readability. That is, significant spaces must appear in quotes.\n\nJ8 Lines can be viewed as a degenerate case of TSV8, described in the next\nsection.\n\n### Related\n\n  * https://jsonlines.org/ - this allows not just strings, any value like {} and []\n\n## TSV8 - Table-Shaped Text\n\nLet's review TSV, and then describe TSV8.\n\n### Review of TSV\n\nTSV has a very short specification:\n\n  * https://www.iana.org/assignments/media-types/text/tab-separated-values\n\nExample:\n\n    \n    \n    name<TAB>age alice<TAB>44 bob<TAB>33\n\nLimitations:\n\n  * Fields can't contain tabs or newlines.\n  * There's no escaping, so unprintable bytes in field values result in an unprintable TSV file.\n  * Spaces are easy to confuse with tabs.\n\n### TSV8 Description\n\nTSV8 is like TSV with:\n\n  1. A !tsv8 prefix and required column names.\n  2. An optional !type line, with types Bool Int Float Str.\n  3. Other optional column attributes.\n  4. Rows of data, each starting with an empty \"gutter\" column.\n\nExample:\n\n    \n    \n    !tsv8 age name !type Int Str # optional types !other x y # more column metadata 44 alice 33 bob 1 \"a\\tb\" 2 b'nul \\y00' 3 u'unicode \\u{3bc}'\n\nTypes:\n\n    \n    \n    [Bool] false true [Int] JSON numbers, restricted to [0-9]+ [Float] same as JSON [Str] J8 string (any of the 3 styles)\n\nRules for cells:\n\n  1. They can be any of 4 forms in J8 Lines:\n\n    1. Unquoted\n    2. JSON-style \"\"\n    3. u''\n    4. b''\n  2. Leading and trailing whitespace must be stripped, as in J8 Lines.\n\nTODO: What about empty cells? Are they equivalent to null? TSV apparently\ncan't have empty cells, as the rule is [character]+, not [character]+.\n\nColumn attributes:\n\n  * !format could be Instant / Duration?\n\n### Design Notes\n\nTODO: This section will be filled in as we implement TSV8.\n\n  * Null Issues:\n\n    * Are bools nullable? Seems like no reason, but you could be missing\n    * Are ints nullable? In SQL they probably are\n    * Are floats nullable? Yes, like NA in R.\n    * Decoders can use a parallel typed column to indicate nulls?\n  * It's OK to use plain TSV in YSH programs as well. You don't have to add types if you don't want to.\n\n## Summary\n\nThis document described an upgrade of JSON strings:\n\n  * J8 Strings (in 3 styles)\n\nAnd data formats that built on top of these strings:\n\n  * JSON8 - tree-shaped records\n  * J8 Lines - Unix streams\n  * TSV8 - table-shaped data\n\n## Appendix\n\n### Related Links\n\n  * https://json.org/\n  * JSON extensions\n\n    * https://json5.org/\n    * JSON with Commas and Comments\n    * Survey: https://github.com/json-next/awesome-json-next\n\n### Future Work\n\nWe could have an SEXP8 format for:\n\n  * Concrete syntax trees, with location information\n  * Textual IRs like WebAssembly\n\n## FAQ\n\n### Why are byte escapes spelled \\yff, and not \\xff as in C?\n\nBecause in JavaScript and Python, \\xff is a code point, not a byte. That is,\nit's a synonym for \\u00ff, which is encoded in UTF-8 as the 2 bytes 0xc3 0xbf.\n\nThis is exactly the confusion we want to avoid, so \\yff is explicitly\ndifferent.\n\nOne of Chrome's JSON encoders also has this confusion.\n\n### Why have both u'' and b'' strings, if only b'' is technically needed?\n\nA few reasons:\n\n  1. Apps in languages like Python and Rust could make use of the distinction. Oils doesn't have a string/bytes distinction (on the \"interior\"), but many languages do.\n  2. Using u'' strings can avoid hacks like WTF-8, which is often required for round-tripping arbitrary JSON messages. Our u'' strings don't require WTF-8 because they can't represent surrogate halves.\n  3. u'' strings add trivial weight to the spec, since compared to b'' strings, they simply remove \\yff. This is true because encoded J8 strings must be valid UTF-8.\n\n### Why not use double quotes like u\"\" and b\"\"?\n\nJ8-style strings could have used double quotes. But single quotes make the new\nstyles more visually distinct from \"\", and it allows '' as a synonym for u''.\n\nCompared to \"\" strings, '' strings don't have a UTF-16 legacy.\n\n### How do I write a J8 encoder and decoder?\n\nThe list of errors at ref/chap-errors.html may be a good starting point.\n\nTODO: describe the Oils implementation.\n\n## Glossary\n\n  * J8 Strings - the building block for JSON8 and TSV8. There are 3 similar syntaxes: \"foo\" and b'foo' and u'foo'.\n  * JSON strings - double quoted strings \"foo\".\n  * J8-style strings - either b'foo' or u'foo'.\n\nFormats built on J8 strings:\n\n  * J8 Lines - unquoted and J8 strings, one per line.\n  * JSON8 - An upgrade of JSON.\n  * TSV8 - An upgrade of TSV.\n\nGenerated on Sun, 04 Feb 2024 00:32:22 -0500\n\n", "frontpage": false}
