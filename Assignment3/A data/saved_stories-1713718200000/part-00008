{"aid": "40103375", "title": "A Sketch of the Biggest Idea in Software Architecture (2022)", "url": "https://www.oilshell.org/blog/2022/03/backlog-arch.html", "domain": "oilshell.org", "votes": 1, "user": "thunderbong", "posted_at": "2024-04-21 05:32:03", "comments": 0, "source_title": "A Sketch of the Biggest Idea in Software Architecture", "source_text": "A Sketch of the Biggest Idea in Software Architecture\n\nWhy Sponsor Oils? | blog | oilshell.org\n\n# A Sketch of the Biggest Idea in Software Architecture\n\n2022-03-12 (Last updated 2022-05-25)\n\nThis post was called Backlog: Software Architecture until I edited it and saw\na coherent theme emerge.\n\nIt elaborates on narrow waists: an idea in #software-architecture that relates\nto networking, operating systems, language design, compilers, and distributed\nsystems.\n\nAnother title I considered is An Overview of Software Composition at Runtime.\nThat is, you can contrast these two styles of building software out of parts:\n\n  1. Fine-grained static types, build-time composition, static linking, APIs, and version numbers\n  2. Coarse-grained \"waists\", runtime composition, ABIs, IPC, and versionless protocols\n\nMany programmers are familiar with the first style. This post is about the\nsecond style, which you see at large scales and long time horizons.\n\nThis post is long and dense with links, so you may want to read it in multiple\nsittings. Let me know what you think in the comments! I especially welcome\nreferences to similar material.\n\nTable of Contents\n\nBackground\n\nMotivating Design Questions\n\nWhat Is a Narrow Waist?\n\nPrecisely Defining \"The Unix Philosophy\"\n\nCharacteristics of Narrow Waists\n\nFallacies\n\nRelated Ideas\n\nExamples and Elaboration\n\nThe Web Evolved In A Versionless Manner\n\nBytes and Text Are Essential Narrow Waists\n\nSlogan: Text Is The Only Thing You Can Agree On\n\nCSV, JSON, HTML - Tables, Records, Documents\n\nTradeoffs Between Dynamic and Static Types (FAQ)\n\nRefinements\n\nProjection to Waists\n\nEmulation of Waists\n\nExtension of Waists\n\nComposition Between Waists\n\nAddition of Waists\n\nHierarchy Among Waists\n\nCall to Action\n\nJon Postel Made the Internet's Waist Narrow\n\nConclusion\n\nAppendices\n\nThe Lambda Calculus Is a Narrow Waist\n\nWiki, Zulip\n\n## Background\n\nI'm happy that there was great discussion on the last post, The Internet Was\nDesigned With a Narrow Waist:\n\n  * Hacker News\n  * lobste.rs\n  * Reddit /r/linux and /r/ProgrammingLanguages\n\nI wrote about abstract ideas, but readers understood and applied them. And a\nreader answered my question about the history of the narrow waist, which I\nrepeat in the Call to Action below.\n\nOn the other hand, there were a few responses that exhibited exactly the\nmisconceptions I want to push back on. In particular, the lack of\nconsideration for tradeoffs:\n\n  * Local convenience vs. global economy, flexibility, generality, and extension\n  * The code perspective vs. the system perspective\n  * Fine-grained types vs. coarse-grained \"waists\"\n\nTo be convincing about this, I would dive into examples: show code, analyze\nexisting designs, and propose new designs. I collected a great deal of\nmaterial on the wiki and in Zulip.\n\nBut I probably shouldn't spend months writing and arguing about #software-\narchitecture. It's better to build something with the principles I'm\nespousing.\n\nSo I'm squeezing many topics into this single post. I state the main points,\nwith some justification.\n\nUpdate: I want to expand the project, as mentioned in November. We now have a\nGithub Sponsors account, and I'm waiting for a response to a NLnet grant\napplication.\n\n## Motivating Design Questions\n\nTo be concrete, here are some questions that these ideas will help us with:\n\n  1. Should shells have two tiers?\n\n     * Both external processes and internal \"functions\"? Both pipelines of bytes and pipelines of structured data?\n     * I argue that processes and byte streams should still be \"primary\" because it makes the shell more interoperable and useful. They are both fundamental narrow waists. Last January: \"Shells Should Shell Out\".\n  2. Is JSON the new narrow waist for shell?\n\n     * It's a narrow waist, but it's not as universal as text or byte streams. For example, HTML and CSV are not the same as JSON, and they shouldn't be.\n  3. How can we design a better distributed OS?\n\n     * We need a simple, extensible OS designed around a few narrow waists. This is the claim in Kubernetes is Our Generation's Multics.\n     * For example, this diagram indicates several O(M \u00d7 N) code explosions. Narrow waists would make the system simultaneously smaller and more powerful.\n     * This problem is out of scope for Oil, but these ideas may be useful to others.\n  4. Is Docker designed well? How could it be improved?\n\n     * I bring up this example because I've seen the claim that \"the Unix philosophy is obvious\" and has been absorbed into standard practice.\n     * This couldn't be further from the truth: Docker is a recent design, and its style is profoundly anti-Unix. (Oil's build now uses podman, which is a nice, compatible improvement.)\n     * But despite its design, Docker solved a real problem, and has notable innovations.\n\nSo I believe the ideas below are relevant to the biggest forces and\ndevelopments in the industry. I'm glad that Docker is being \"refactored away\"\ninto something more Unix-y on two fronts: into OCI by Red Hat and others, and\nout of Kubernetes. (Related: Docker's Second Death)\n\n## What Is a Narrow Waist?\n\nMost readers understood the last post: I borrowed the narrow waist term from\nnetworking and extended it to software.\n\nBut it's become clear to me that not all narrow waists are alike. It's worth\ndistinguishing these categories, and more:\n\n  1. Small, simple mechanisms like the Internet Protocol, UTF-8, and JSON.\n\n     * These waists are \"narrow\" in a strong sense. It's not a coincidence that Jon Postel, Ken Thompson, and Doug Crockford were their \"editors\" or creators.\n  2. Language standards like POSIX shell, JavaScript, and C++.\n\n     * These are big and hard to reimplement. I know this first hand from working on Oil!\n     * These are narrow waists because they solve the interoperability problem of {user programs ...} \u00d7 {language implementations ...}\n  3. \"Accidental\" waists like Win32 and x86.\n\n     * Their evolution isn't guided by a standards body. They're also big and hard to reimplement.\n  4. APIs like LLVM. As the home page says, LLVM isn't a virtual machine. It's really a software library that changes with each release, requiring consumers to change their code. This makes it different than the other narrow waists, which are more about runtime composition.\n  5. ... ?\n\nSo it's worth being more specific, and the posts below will refine definitions\nand explore related concepts.\n\nThe clearest objection I see to the narrow waist idea is that a narrow waist\nis simply a standard! Standards enable interoperability.\n\nBut standards have to come from somewhere. A narrow waist may or may not\nbecome a standard. Also, LLVM is not a standard, and isn't intended to be one.\n\nThe hourglass metaphor also suggests why the idea is powerful, and what to aim\nfor. You want something small that interfaces with many other things.\n\n### Precisely Defining \"The Unix Philosophy\"\n\nI spent a week drafting a post called Diagrams of Three Narrow Waists in Unix.\nThe first sentence is:\n\n> Have you heard vague claims about \"the Unix Philosophy\", and are you\n> confused or skeptical about it?\n\nThis is a valuable post, because surprisingly the narrow waist idea says\nsomething new and more specific about Unix! I justify this with references,\nincluding the classic ones on this Wikipedia page.\n\nI have diagrams of these 3 narrow waists:\n\n  1. Processes\n\n     * {native code, shebang script, shell function, ...} \u00d7 { start, kill, pipe, redirect, run with privileges, ... }\n  2. File Descriptors\n\n     * {file, pipe, terminal, socket, ... } \u00d7 {read, write, ioctl, ... }\n  3. Tree-Shaped Namespaces of unstructured data (file systems)\n\n     * {disk, SSD, memory with tmpfs, file with loopback, ... } \u00d7 { ls, mount, version with git, serve over HTTP, ... }\n\nThe diagrams show that Unix uses multiple narrow waists to achieve dynamic and\nextensible polymorphism.\n\nThe file descriptor case shows both sides of the tradeoff. You don't\nstatically know what syscalls are valid on a descriptor. You also don't know\nwhat errors you'll get! I re-learned this lesson with:\n\n  * A bug in Oil 0.9.6: write() can fail with EISDIR if the descriptor returned by open() points to a directory.\n  * Bugs in Hello World: write() can fail with ENOSPC if the descriptor points to a disk file. Python 2 has the bug but Python 3 fixed it.\n\nNevertheless, the polymorphic design of file descriptors makes Unix compose,\nand is one reason why shell is powerful! I give examples in the post.\n\nGo addresses this problem with single function interfaces like Reader and\nWriter, and more generally the -er pattern. Here's an interesting quote:\n\n> It would be nice if Haskell had [open polymorphism], possibly using Go as a\n> model.\n>\n> \u2014 Philip Wadler: Featherweight Go\n\nMore:\n\n  * I mention the relationship to Plan 9 (fixing the composition bugs in Unix) and REST (the uniform interface constraint).\n  * I link to two important academic papers, and related analysis of Unix.\n  * I also noticed that Lines of Text is distinct narrow waist from Text, which the last post depicted.\n\n    * In fact Oil's QSN format takes advantage of this narrow waist, while the GNU's NUL-delimited format doesn't. (This the format xargs -0 accepts , mentioned in the xargs post.)\n    * In particular, wc -l, head, tail, and tail -f work \"for free\" with QSN, but you need more code like to support the NUL-delimited format, like head -z and tail -z.\n\nThis post isn't done, but it's the one I want to publish the most.\n\n### Characteristics of Narrow Waists\n\nIn software, the most important characteristic of a narrow waist is that it\nreduces an O(M x N) code explosion, allowing interoperability and code reuse.\n\nI also realized that there are two distinct senses of the word \"narrow\":\n\n  1. In terms of architectural connection (topology).\n\n     * For example, applications and physical networks are decoupled by the the Internet's narrow waist. They don't interface directly with each other.\n  2. In terms of the size of the concept.\n\n     * IP is a small concept, and Unix is a small handful of concepts.\n     * But the web is a large set of concepts (HTTP, HTML, SVG, etc.). C++ and shell are also large.\n\nSo this issue deserves some more thought, and perhaps more terminology.\n\nHere are more ways to characterize narrow waists:\n\n  1. They are compromises. They make systems economical and possible, not necessarily optimal.\n\n     * If you have a small or specialized network, you can design something more efficient than the Internet.\n  2. They arise through a mix of explicit design and implicit evolution.\n\n     * Both the Internet and the web were designed and subject to evolution. But I'd say the web evolved more.\n  3. The design can be done well or poorly. The evolution can be guided or haphazard.\n\n     * JSON was an explicit design, and it's much better than CSV.\n     * We should try to do better at design, because the resulting network effects mean we often get \"stuck\" with bad designs.\n\nRegarding evolution:\n\n  4. Narrow waists can last for decades, usually evolving in a versionless manner.\n\n     * For example, Unix shell is one of the oldest languages in wide use, and there's continuous compatibility between Thompson shell, Bourne Shell, Korn shell, bash, OSH, and Oil.\n     * A narrow waist has an amount of inertia that's proportional to the amount of functionality that hinges on it.\n  5. But narrow waists can also move!\n\n     * TCP/IP \u2192 HTTP\n     * POSIX C APIs \u2192 Linux x86 ABI\n  6. They're subject to extreme economic pressure and network effects. For example:\n\n     * Windows 10 emulates Linux with WSL. (Windows also had a different kind of Unix emulation decades earlier.)\n     * Linux emulates Windows with WINE.\n  7. The downside of inertia is that narrow waists can inhibit innovation.\n\n     * For example, hardware-software co-design is inhibited because of decades-old ISAs.\n  8. Narrow waists are often overextended to new applications.\n\n     * The web was arguably overextended from a network of hyperlinked documents to an application delivery platform (single-page apps in JavaScript)\n     * It was also extended to a desktop UI framework via Electron.\n     * Linux was arguably overextended to embedded devices, especially those with real-time requirements.\n\nSome recent narrow waists include Docker / OCI, the Language Server Protocol,\nand WebAssembly. I should be more specific about their varying degrees of\nsuccess with respect to design and user adoption. For example, I think\nWebAssembly is useful, but less general than what's been recently claimed.\nIt's a deep compromise which involves winners and losers.\n\n### Fallacies\n\nHere are some common objections to the idea.\n\n(1) Textual data is hard to manipulate with programs.\n\nThis is not an objection to the narrow waist principle! The main claims of the\nprinciple are about interoperability and economy of implementation.\n\nI want to make a Simple vs. Easy argument. Narrow waists are simple in Rich\nHickey's terms (not \"complected\"), but not necessarily easy to use. For\nexample, Unix shell can be hard to learn, but its power results in a small,\nextensible operating system.\n\n(2) The web is really messy, and thus unreliable.\n\nI make a strong Messy vs. Stable distinction. Messy systems aren't necessarily\nunreliable. Quite the contrary \u2014 the need for stability is the cause of the\nmess! Continuous backward compatibility (like the the many iterations of CSS)\nmakes a mess, but keeps the system working.\n\nThis relates to another concept I've been having a hard time describing:\nversionless evolution, which I describe below.\n\n### Related Ideas\n\nWe can understand the narrow waist more precisely by relating it to these\nideas:\n\n  1. Metcalfe's Law states that the value of a network is proportional to N^2, where N is the number of nodes.\n\n     * This is related to, but distinct from, the M \u00d7 N architectural connections of a narrow waist. Architectural connections are not network node connections.\n     * Thinking about the architectural hierarchy of narrow waists may clarify this. For example, CSV, JSON, and HTML are narrow waists at \"level 1\". And each of them is literally text, which is at \"level 0\". Generic operations are \"inherited\", which makes the system smaller. (This idea really needs diagrams.)\n  2. The Internet Protocol follows the End-to-End Principle and it's a narrow waist.\n\n     * This doesn't mean the two principles are the same. I view the narrow waist as more descriptive and predictive when applied to software.\n\n## Examples and Elaboration\n\nLet's apply these principles to real world systems. Again, I claim the narrow\nwaist is the most important idea in software architecture, because it\ndescribes the biggest and longest-lived systems.\n\n### The Web Evolved In A Versionless Manner\n\nI'd like to elaborate on the \"versionless\" property of many narrow waists. You\ncan contrast two philosophies of versioning:\n\n  1. Version numbers that indicate breaking changes, e.g. Semantic Versioning.\n\n     * Linux distros and package managers like NPM like often pair semantic versioning with ad hoc constraint solvers to find a set of compatible versions for dependencies. This model can be brittle because you may end up running a set of versions that's never been tested together.\n  2. Continuous backward compatibility, i.e. versionless evolution.\n\n     * There are also version numbers here, but they indicate feature additions rather than breaking changes.\n\nFor example, the web doesn't have incompatible versions, and JSON was\nexplicitly designed by Doug Crockford to be versionless.\n\nHistory proves this rule. In Don't Break X, I mentioned that XHTML and\nECMAScript 4 both tried to break the web with radical changes, but they failed\nbecause of the inertia of narrow waists.\n\nIn contrast, HTML5 and ECMAScript 5 evolved the web in a compatible way. We\nshould study and disseminate the history of the web avoid repeating mistakes\nwe get \"stuck with\".\n\nHere's a good way of thinking about versionless evolution:\n\n> Relaxing a requirement should be a compatible change. Strengthening a\n> promise should be a compatible change.\n>\n> \u2014 Rich Hickey in Maybe Not (2018, YouTube)\n\nExamples:\n\n  * HTML5 defined <hr> and <hr /> to mean the same thing, whereas previous versions of HTML were stricter. (This is the self-closing tag issue.) So HTML5 relaxes a requirement on web page authors, which is a compatible change.\n  * Adding a new feature strengthens the promise that the browser makes to the web page author. For example, HTML5 added a <video> tag, which is a compatible change.\n\nI mention Hickey's framing of \"versionless evolution\" in my comments on\n\nFollowing the Unix philosophy without getting left-pad (raku-advent.blog via\nReddit) 51 points, 23 comments - 06 Dec 2021\n\nThe original post has a serious misunderstanding of the Unix philosophy, and\nthe rebuttals are instructive.\n\n  * Related: Feature Detection Is Better Than Version Detection. Web pages often use feature detection in JavaScript, sometimes via polyfills.\n\n### Bytes and Text Are Essential Narrow Waists\n\nI have a recurring debate about \"text vs. fine-grained types\", mostly with\npeople who are frustrated with ad hoc, incorrect #parsing in shell.\n\nI think that a shell with support for JSON, QSN, QTT and HTML will address\nthis problem. It will reduce the amount of parsing in shell programs, and make\nit correct.\n\nI also claim that parsing is an O(M + N) problem, while types can create O(M \u00d7\nN) problems \u2014 and often do.\n\nTo give more color on that, here's an important comment which I mentioned in\nJanuary, June, July, and August:\n\nMy comment on\n\nA case against text protocols (dead link to unmdplyr-new.bearblog.dev via\nlobste.rs) 17 points, 37 comments on 2020-12-31\n\nI make the M \u00d7 N argument, and use concrete examples like IntelliJ and\nWebAssembly's text format:\n\n> You have M formats and N operations, and writing M \u00d7 N tools is infeasible,\n> even for the entire population of programmers in the world.\n\nI also note the tradeoff:\n\n> It's not an absolute; in reality people do try to fill out every cell in the\n> M \u00d7 N grid [in certain domains]. They get partway there, and there are some\n> advantages to that for sure.\n\nI also quote Rust designer Graydon Hoare on text. While his \"rant\" is mostly\nabout the information density of text, it also touches on the wide range of\noperations that text supports.\n\nAlways bet on text (graydon2.dreamwidth.org via Hacker News) 355 points, 196\ncomments - on Oct 14, 2014\n\n> [Text] can be compared, diffed, clustered, corrected, summarized and\n> filtered algorithmically. It permits multiparty editing. It permits\n> branching conversations, lurking, annotation, quoting, reviewing,\n> summarizing, structured responses, exegesis, even fan fic. The breadth,\n> scale and depth of ways people use text is unmatched by anything.\n\nI note a problematic M \u00d7 N explosion in code generated by protocol buffers (as\nopposed to source code).\n\nComment by maintainer Josh Haberman on\n\nDon't Use Protobuf for Telemetry (richardstartin.github.io via Hacker News)\n223 points, 187 comments - on Dec 30, 2020\n\nFor example, equality becomes schema-dependent rather than generic. This is\nworth it in many systems, but it's a tradeoff.\n\n### Slogan: Text Is The Only Thing You Can Agree On\n\nHere are two variations of a slogan. It's meant to drive home the point of\ntext as a narrow waist.\n\n> The lowest common denominator between a PowerShell, Elvish, Rash, and\n> nushell script is a Bourne shell script (and eventually an Oil script).\n\nThis is because each alternative shell chooses a different kind of structured\ndata as its narrow waist (.NET objects, tree-structured data, Racket data\nstructures, and tables, respectively). Text is the most structured format they\nall agree on, and shell is the language of coarse-grained composition with\ntext.\n\nI predict that this will be a real thing, and isn't theoretical! I have no\ndoubt that there are already bash scripts invoking PowerShell scripts out\nthere, and more complex agglomerations will arise as alternative shells become\npopular.\n\nIt doesn't mean those shells aren't worth using, or more potentially more\nconvenient. But it highlights the need for a better Bourne-style shell.\n\nBased on my comment on\n\nUnix Shell: History and Trivia (oilshell.org via lobste.rs) 18 points, 20\ncomments on 2021-08-06\n\nand\n\nThis subthread of\n\nGoogle/zx 3.0 release (github.com via lobste.rs) 28 points, 21 comments on\n2021-08-16\n\nA second phrasing:\n\n> The lowest common denominator between a Common Lisp, Clojure, and Racket\n> program is a Bourne shell script (and eventually an Oil script).\n\nAgain, these languages are similar, but have incompatible data models. (It's\nnot just the compound data structures; Clojure's notion of numbers and strings\nis borrowed from the JVM.)\n\nBased on this subthread on Unix in\n\nWhy Static Languages Suffer From Complexity (hirrolot.github.io via Reddit) 81\npoints, 56 comments - 19 Jan 2022\n\nThese two slogans are really another way of phrasing a slogan from the last\npost:\n\n> Unix is equally inconvenient for every programmer, and that's a good thing.\n\n### CSV, JSON, HTML - Tables, Records, Documents\n\nThe full title of this post is:\n\n> CSV, JSON, and HTML are Different Because Tables, Records, and Documents Are\n> Different\n\nThis is again pushing back on the notion that JSON is \"the\" new narrow waist\nof shell. Tables and documents are essential structures in software, and\nexpressing them in JSON is awkward.\n\nI can give examples of this, e.g.\n\n    \n    \n    {\"name\": \"alice\", \"age\": 42} {\"name\": \"bob\", \"age\": 43}\n\nand\n\n    \n    \n    [\"a\", {\"href\": \"/home\"}, [\"anchor text\"]]\n\nThis framing comes from the paper Unifying Tables, Objects, and Documents\n(Meijer and Schulte, 2003), but the technical details differ.\n\n### Tradeoffs Between Dynamic and Static Types (FAQ)\n\nText as a narrow waist is at odds with fine-grained, static types. My goal is\nto highlight tradeoffs, and analyze situations where each style is natural and\nefficient.\n\nMany programmers seem to think there is no tradeoff \u2014 or at least they say\nthat on the Internet. I believe that when they create working systems they\noften use the dynamic, coarse-grained view!\n\nThis recent comment links to typical responses, which by now form a FAQ:\n\n  * In distributed systems, types are local illusions. They allow reasoning about a single address space.\n\n    * Big systems are written in multiple languages. The bigger the system, the more heterogeneous the code.\n    * Big systems can't be upgraded atomically. They're often running a mix of inconsistent schema versions.\n  * In distributed systems, field presence is dynamic. Discussion about Maybe Not by Rich Hickey.\n  * When models and reality collide, reality wins. Discussion about On Types.\n\n    * Static types are models; data from network/disk is reality.\n    * The map is not the territory.\n  * Static types and metaprogramming are at odds, and metaprogramming is useful.\n\n    * I wrote about this in 2016: Type Checking vs. Metaprogramming; ML vs. Lisp.\n    * Now I also frame it as Rust vs. Zig. Rust favors type checking, Zig favors metaprogramming, and we don't know how to reconcile this.\n    * A new reference: F# Designer Don Syme Explains the Downsides of Type-Level Programming\n  * A recent thought: Extensibility is Inherently Dynamic.\n\n    * This came from an interesting post On Variance and Extensibility, which was brought up in the discussion of the last post.\n    * How can a piece of code do anything useful with data it does not understand? This relates to the static build and \"atomic upgrade\" problem. If you have a static view of all operations on a kind of data (like images), you should take advantage of it. But often you don't.\n\nHere's a related, fantastic video which I want to signal-boost:\n\nSyme & Matsakis: F# in the Static v. Dynamic divide (youtube.com via Reddit)\n19 points, 6 comments - 27 Dec 2021\n\nI don't know the F# language, but it apparently has a very Clojure-like view\nof data, despite being statically typed. The \"type provider\" mechanism\naddresses the problem of types that are only available runtime, e.g. in SQL\nschemas, or implicitly in JSON and CSV files.\n\nOverall, the fallacy is that we use dynamic typing when we're \"too lazy to\nwrite down the types\". There are many useful programs that aren't 100%\nstatically typed, and I claim this trend is increasing. (Slogan: Poorly\nFactored Software is Eating the World.)\n\nThe real issues are scale in space and time, heterogeneity, and extensibility!\n\n## Refinements\n\nIn the discussion of the extensibility post, I said that I'm getting at theory\nand guidelines for runtime composition and versionless evolution. Shell is\nabout software composition at runtime, as opposed composition via static\nlinking.\n\nSo in addition to the Perlis-Thompson Principle, narrow waists, and O(M \u00d7 N)\ncode explosions, here are some more concepts that are worth exploring.\n\n### Projection to Waists\n\nI need a name for the idea of code reuse by changing the representation of\ndata to a narrow waist. Examples:\n\n  1. The /proc file system projects kernel metadata onto the narrow waist of the file system.\n\n     * Now you can use existing tools like ls and open() to explore the state of processes.\n  2. Any system that uses FUSE is also like this, e.g. Michael Greenberg's File File System projects JSON onto a virtual file system. This allows reuse of tools like cd and ls.\n  3. The gron tool projects tree-like JSON onto the narrow waist of \"lines of text\". This allows reuse of tools like grep and awk.\n\nNotice that JSON is a narrow waist, but it's been projected onto two others:\nthe file system, and lines of text. Which one is appropriate (if any) depends\non what set of tools helps you solve a particular problem.\n\n### Emulation of Waists\n\nThis is the most straightforward one. As mentioned above, there's a big\nincentive for Windows to emulate Linux, and vice versa. The platform gets\nthousands and thousands of applications \"for free\".\n\nWin32 is the stable Linux userland ABI (and the consequences) (sporks.space\nvia lobste.rs) 43 points, 44 comments on 2022-02-27\n\nAnother example is when Illumos borrowed FreeBSD's Linux syscall ABI emulation\nin order to run user-uploaded Docker containers. This is dynamic, runtime\ncomposition with ABIs, not static composition by compiling code against kernel\nAPIs expressed as C header files.\n\n### Extension of Waists\n\nI think \"waist extension\" is a good term for the following ideas:\n\n  * The web is a humble and brilliant extension of Unix, adding simple networking and hyperlinks (from this recent comment; a longer comment from 2013).\n\n    * This design was not obvious! There is a long history of hypertext systems that were not built on Unix. It would be nice to research explain the history.\n    * apenwarr in 2006: The web works because it mostly just paraphrases Unix's cleverness. (\"Working\" is an important property that a lot of software lacks.)\n    * Web Sites Are Naturally Made With Shell Scripts (2020)\n  * git is a distributed extension of the Unix file system.\n\n    * Again, earlier systems were not like this, e.g. CVS and SVN. As with the web, the idea is only obvious in hindsight. It's obvious when it becomes \"air\", but someone had to invent it.\n    * git has a messy UI, but a clean narrow waist. This article seems like a good explanation, but there may be better ones: Git is a purely functional data structure.\n\n### Composition Between Waists\n\nUnix has multiple waists: processes, file descriptors, file systems, lines of\ntext, unstructured text, and bytes. Each of them allows M \u00d7 N things to\ncompose, but they also must compose amongst themselves.\n\n\"A few things that compose\" is tantamount to the Perlis-Thompson Principle.\nWhen I started this series, I wasn't sure if this term and \"narrow waist\" were\nnecessary \u2014 maybe they're both tantamount to \"simplicity\".\n\nBut after working through examples, I see them as distinct but related. So it\nwould be nice to write more clearly about how narrow waists relate. This seems\nlike a distinct style of long-lived architecture.\n\nAgain, let me know if you have references. I don't want to write about ideas\nthat other people have already explained, or invent new terms when there are\nexisting ones.\n\n### Addition of Waists\n\nIt's common to create a new, larger narrow waist out of existing smaller ones.\n\nFor example, the Language Server Protocol uses JSON-RPC for notifications and\nresponses.\n\nIn turn, JSON-RPC is built on top of JSON and a transport like TCP/IP or\npipes.\n\n### Hierarchy Among Waists\n\nThere's a clear hierarchy among data representations in Unix, which affects\nwhich operations are valid:\n\n  * In the last post, I mentioned that text (ASCII, UTF-8) is a special case of bytes, and inherits operations on bytes.\n  * I mentioned above the Lines of Text is a special case of text.\n  * Likewise, JSON, CSV, and HTML are all text. and inherit operations on text.\n\n## Call to Action\n\n### Jon Postel Made the Internet's Waist Narrow\n\nAfter a very helpful reader e-mail, I added an appendix to the last post. I\nwant to transcribe the first 10 minutes of the video of Van Jacobsen. He\ndescribes the role of Jon Postel as Internet specification editor \u2014\nspecifically, his relentless, decades-long drive for minimalism in the\nInternet's design:\n\n> This narrow waist is not something that God gives you. It's something that\n> you make. It's hard engineering.\n\nand\n\n> We unfortunately don't have a lot of Jon Postel's in the world. It would be\n> nice to get one on nearly every project.\n\nThis reminds me of the sentiments by Ken Thompson quoted in Unix Shell:\nHistory and Trivia. They share a taste for minimalism that unlocks enormous\nfunctionality.\n\nI also enjoyed reading these memorials:\n\n  * RFC 2468: I Remember IANA (1998) by Vint Cerf. Submitted to Hacker News.\n  * RFC 2441: Working with Jon (1998)\n\nThe point is that people have to behave differently to create valuable,\ninteroperable systems!\n\n## Conclusion\n\nAfter more than a year of circling these #software-architecture topics, I feel\npretty good about them. They've informed Oil's design and will continue to. It\nhelps to be precise about definitions and support claims with examples.\n\nI hope this outline was also useful to you. I wish I could have written a\nshorter post, but I didn't have time :-)\n\nAnd again, please send related references. They will help with future articles\non these ideas. (I was surprised that the history of the narrow waist in\nnetworking is not well documented or agreed upon.)\n\nNow I want to switch gears to something more \"tactical\": translating Oil to\nC++! That has been on hold for a full year, since the last milestone in March\n2021.\n\nI also want to expand the project. Please donate to my new Github Sponsors\npage if you think we need a new, principled shell. I'll ask for donations\nagain in upcoming blog posts. All of the money will go to contributors and\n\"employees\", not to me!\n\n## Appendices\n\n### The Lambda Calculus Is a Narrow Waist\n\nThis a \"fun\" post to help us with the definition. It's based on this quote\nfrom chapter 5 of Types and Programming Languages:\n\n> [The importance of the lambda calculus] arises from the fact that it can be\n> viewed simultaneously as a simple programming language in which computations\n> can be described and as a mathematical object about which rigorous\n> statements can be proved.\n\n  * In other words, it reduces an M \u00d7 N explosion of {arbitrary algorithms ...} \u00d7 {inductive cases in proofs about them}.\n  * Derived forms with respect to lambda calculus are like intermediate representations in compilers. Proofs about languages are laborious for a very similar reason that implementing compilers is laborious!\n\n### Wiki, Zulip\n\nThis post was long, but there are still important things I left out. As\nmentioned in the Motivating Design Questions section, these ideas relate to\nthe design of foundational cloud software like Docker and Kubernetes.\n\nBut I want Oil to be in better shape before I continue writing about these\ntopics. For now here are my Wiki pages and Zulip links. (I really wish I had a\nsingle brainstorming and research app.)\n\n  * https://github.com/oilshell/oil/wiki/Perlis-Thompson-Principle\n\n    * Everything is an X is an important narrow waist argument that deserves more diagrams. Every good language is derives its power from composition. The composition comes from the narrow waist of its core data structures. (This is another case where a narrow waist differs from a standard.)\n  * https://github.com/oilshell/oil/wiki/M-by-N-Code-Explosions\n\n    * An ongoing list of real problems that narrow waists can solve! The cornucopia of Linux distros and language package managers annoys me.\n  * https://github.com/oilshell/oil/wiki/Composable-Distributed-OS\n\n    * An elaboration on another lobste.rs subthread of Unix Shell: History and Trivia.\n\nI also mentioned the #containers Zulip stream in December. Here is a (sloppily\nsketched) overview thread:\n\n  * Docker Summary. The Value of Docker, and its anti-Unix design. Other threads substantiate these claims with experience.\n\n  * Discuss This Post on Reddit\n  * Get notified about new posts via @oilsforunix on Twitter\n  * Read Posts Tagged: software-architecture distributed-systems comments zulip-links\n  * Back to the Blog Index\n\n", "frontpage": false}
