{"aid": "40158816", "title": "The first framework that lets you visualize your React/Node.js app's code", "url": "https://wasp-lang.dev/blog/2024/04/25/first-framework-that-lets-you-visualize-react-node-app-code", "domain": "wasp-lang.dev", "votes": 1, "user": "matijash", "posted_at": "2024-04-25 15:37:15", "comments": 0, "source_title": "The first framework that lets you visualize your React/NodeJS app's code", "source_text": "The first framework that lets you visualize your React/NodeJS app's code | Wasp\n\nSkip to main content\n\n# The first framework that lets you visualize your React/NodeJS app's code\n\nApril 25, 2024 \u00b7 9 min read\n\nVinny\n\nDevRel @ Wasp\n\n## Visualize the Prize\n\nImagine you\u2019re working on your full-stack app, and you want to implement a new\nfeature. It\u2019s a complicated one, so you whip out a pen and paper, or head over\nto tldraw, and start drawing a diagram of what your app currently looks like,\nfrom database, to server, and on over to the client.\n\nBut how cool would it be if you had a tool that visualized your entire full-\nstack app for you? And what if that tool had the potential to do greater\nthings, like instantly add useful functionality for you across your entire\nstack, or be paired with AI and Large Language Models for code generation?\n\nWell, that idea is already a reality, and it\u2019s called wasp studio. Check it\nout here:\n\n## Wasp Studio is the Name\n\nFirst off, Wasp is a full-stack React, NodeJS, and Prisma framework with\nsuperpowers. It just crossed 10,000 stars on GitHub, and it has been used to\ncreate over 50,000 projects.\n\nWhy is it special? It uses a config file and its own compiler to manage a\nbunch of features for you, like auth, cron jobs, routes, and email sending,\nsaving you tons of time and letting you focus on the fun stuff.\n\nThis combination of Wasp\u2019s central config file, which acts as a set of\ninstructions for the app, and compiler also allow Wasp to do a bunch of\ncomplex and interesting tasks for you via one-line commands, such as:\n\n  * full-stack deployments \u2192 wasp deploy\n  * starting a development database with Docker \u2192 wasp start db\n  * scaffold entire example apps, such as a SaaS starter \u2192 wasp new\n  * giving you a visual schematic of your entire full-stack app \u2192 wasp studio\n\nIf you wanna try them out yourself all you have to do is:\n\n  1. install Wasp with curl -sSL https://get.wasp-lang.dev/installer.sh | sh\n  2. scaffold a new To Do app in TypeScript with wasp new -t todo-ts\n  3. then to get the visualizer as in the screenshot below, run wasp studio\n\nLet\u2019s break down what we\u2019re seeing here real quick:\n\n  * Our main App component in the middle in blue shows the app\u2019s name, database we\u2019re using, and its Auth method\n  * Entities to the left in yellow show us which database models we\u2019ve defined\n  * Actions and Queries to the far left in red and green show us our server operations that act on our database entities\n  * Routes and Pages on the right show us where our React components live and if they require authorization or not (denoted by \ud83d\udd12)\n\nAnd if you\u2019re wondering what this might look like with a more complex app,\nhere\u2019s what it looks like when run against Open SaaS - our free, open-source\nSaaS boilerplate starter.\n\nWhat\u2019s great about this is that we have an overview of all our database\nentities and which server functions (aka \u201coperations\u201d) they depend on. In the\ntop left of the picture above, you\u2019ll even see a cron job, dailyStatsJob,\nwhich runs every hour (0 * * * *).\n\nThis, for example, makes developing backend logic a breeze, especially if\nyou\u2019re not a seasoned backend developer. Consider that the code that gets you\nthere is as simple as this:\n\n    \n    \n    job dailyStatsJob { executor: PgBoss, perform: { fn: import { calculateDailyStats } from \"@src/calculateDailyStats\" }, schedule: { cron: \"0 * * * *\" }, entities: [User, DailyStats, Logs, PageViewSource] }\n\nYep, that\u2019s all it takes for you to get asynchronous jobs on your server. Now\nyour calculateDailyStats function will run every hour \u2014 no third party\nservices needed \ud83d\ude42\n\n## Is this a Party Trick!?\n\nOk. You might be thinking, the visualizer is cool, but does it actually serve\na purpose or is it just a nice \u201cparty trick\u201d? And to be honest, for now it is\na party trick.\n\nBut it\u2019s a party trick with a lot of potential up its sleeve. Let me explain.\n\nOf course, you can use it in its current form to get a better perspective of\nyour app, or maybe plan some new features, but in the future you will be able\nto use it to do a lot more, such as:\n\n  * add new auth methods with a few clicks\n  * quickly scaffold functional client-side components with server operations\n  * instantly add new full-stack functionality to your entire app, like Stripe payments\n  * collaborate easily with Large Language Models (LLMs) to generate features on-the-fly!\n\nAgain, this is all possible because of the central configuration file which\nacts as a set of \u201cinstructions\u201d for your app. With this file Wasp literally\nknows how your app is built, so it can easily display your app to you in\nvisual form. It also makes it a lot easier to build new parts of your app for\nyou in exciting new ways.\n\nTake a look at another snippet from a Wasp config file below. This is all it\ntakes to get full-stack auth for your web app! That\u2019s because the Wasp\ncompiler is managing that boilerplate code for you.\n\n    \n    \n    app todoVisualize { title: \"todo-visualize\",\n    \n    auth: { userEntity: User, methods: { usernameAndPassword: {}, google: {}, }, } }\n    \n    entity User {=psl id Int @id @default(autoincrement()) tasks Task[] psl=}\n\n# A Picture is Worth a Thousand Tokens\n\nNow that we know a bit about how Wasp works, let\u2019s dive deeper into the\npotential of Wasp and wasp studio in combination with LLMs as a future use\ncase.\n\nCurrently one of the biggest constraints to AI-assisted code generation is\ncontext. By now, we all know that LLMs like to hallucinate, but they also have\na pretty bad \u201cmemory\u201d. So, if you were to try and get them to build features\nfor your app, to make sure that the new feature works with it, you have to\nconstantly \u201cremind\u201d them of how the app works, its structure, and\ndependencies.\n\nBut with Wasp\u2019s config file, which is essentially just a higher-level\nabstraction of a full-stack app and its features, we give the LLM the context\nit needs to successfully build new features for the app at hand.\n\nAnd this works really well because we don\u2019t only give the LLM the context it\nneeds, but Wasp\u2019s compiler also takes on the responsibility of writing most of\nthe boilerplate for us to begin with (thanks, pal), giving the LLM the simpler\ntasks of writing, e.g.:\n\n  * modifications to the Wasp config file\n  * functions to be run on the server\n  * React components that use Wasp code\n\nIn this sense, the LLM has to hold a lot less in context and can be forgiven\nfor its bad memory, because Wasp is the one making sure everything stays\nnicely glued together!\n\nTo further bring the point home, let\u2019s take a look again at that Auth code\nthat we introduced above:\n\n    \n    \n    auth: { userEntity: User, methods: { usernameAndPassword: {}, google: {}, },\n\nConsider that this code gives auth across your entire stack. So, not only do\nyou get all the auth logic generated and managed for you on the server, but\nyou even get UI components and auth hooks made available to you on the client!\n\nOn the other hand, without the abstractions that Wasp gives us, we end up\nrelying on the LLM, with it\u2019s bad memory and tendency to hallucinate, to write\na bunch of boilerplate for us over and over again like this JWT middleware\npictured below:\n\nAnd LLMs are pretty good at coding boilerplatey, repetitive tasks in\nisolation. But expecting them to do it as part of a cohesive full-stack app\nmeans that we have a ton more surface area for exposure to possible errors.\n\nWith Wasp, on the other hand, it\u2019s just a few lines of code. If it\u2019s easy for\nhumans to write, it\u2019s also super easy for an LLM to write.\n\nBy the way, not only does this save us a lot of headache, it also can save us\na lot of money too, as AI-generated Wasp apps use ~10-40x less tokens (i.e.\ninput and output text) than comparable tools, so they generate code at a\nfraction of the price.\n\n## Helping the Computers Help Us\n\nAs technologies continue to improve, programming will become more accessible\nto users with less expert knowledge because more of that expert knowledge will\nbe embedded in our tools.\n\nBut that means we will need abstractions that allow for us, the humans, to\nwork easily with these tools.\n\nLike the LLM example above, we can build tools that get AIs to write all the\nboilerplate for us over and over again, but the question is, should we be\nletting them do that when they could be doing other more useful things? LLMs\nare great at producing a wealth of new ideas quickly. Why not build tools that\nlet AIs help us in this regard?\n\nThat\u2019s exactly what we have planned for the future of wasp studio. A visual\ninterface that allows you to piece together new features of your app, with or\nwithout the help of LLMs, and then A/B test those different ideas quickly.\n\nNot only that, but we also then have an abstraction at our disposal that\nallows for easy collaboration with users who are less technically inclined.\nWith the help of such tools, even your Product Manager could get in on the fun\nand start building new features for the developers to sign off on.\n\nWhat\u2019s so powerful about Wasp and its feature set, is that we get code that\u2019s\nsimpler to read, debug, and maintain, for both people and machines. Coupled\nwith a visual interface, we will be able to quickly iterate on new features\nacross the entire stack, using it as a planning and orchestration tool\nourselves, or as a way to more easily debug and oversee the work an LLM might\nbe doing for us.\n\nThis is a pretty exciting look at the future of web development and with these\nnew tools will come lots of new ways to utilize them.\n\nWhat are some ways that you think a tool like wasp studio could be used? What\nother developments in the realm of AI x Human collaboration can you imagine\nare coming soon?\n\nTags:\n\n  * react\n  * nodejs\n\nEdit this page\n\n### Join our developer community\n\nWasp is 100% open source. Join our Discord to learn from others and get help\nwhenever you need it!\n\nJoin our Discord \ud83d\udc7e\n\n\u2192\n\n\ud83d\udceb\n\n### Subscribe to our newsletter\n\nOnce per month - receive useful blog posts and Wasp news.\n\n  * Visualize the Prize\n  * Wasp Studio is the Name\n  * Is this a Party Trick!?\n  * Helping the Computers Help Us\n\nDocs\n\n  * Getting started\n  * Todo app tutorial\n\nCommunity\n\n  * Discord\n\nMore\n\n  * GitHub\n  * Contact\n\nCopyright \u00a9 2024 Wasp.\n\n", "frontpage": false}
