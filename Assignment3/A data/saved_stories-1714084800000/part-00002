{"aid": "40159738", "title": "How to Compress URL Parameters", "url": "https://stackoverflow.com/questions/21802866/how-to-compress-url-parameters", "domain": "stackoverflow.com", "votes": 2, "user": "ppmqq", "posted_at": "2024-04-25 16:39:41", "comments": 0, "source_title": "How to compress URL parameters", "source_text": "javascript - How to compress URL parameters - Stack Overflow\n\n#\n\nJoin Stack Overflow\n\nBy clicking \u201cSign up\u201d, you agree to our terms of service and acknowledge you\nhave read our privacy policy.\n\n# OR\n\nAlready have an account? Log in\n\nSkip to main content\n\nStack Overflow\n\n  1. About\n  2. Products\n  3. For Teams\n\n  1. Stack Overflow Public questions & answers\n  2. Stack Overflow for Teams Where developers & technologists share private knowledge with coworkers\n  3. Talent Build your employer brand\n  4. Advertising Reach developers & technologists worldwide\n  5. Labs The future of collective knowledge sharing\n  6. About the company\n\n##### CollectivesTM on Stack Overflow\n\nFind centralized, trusted content and collaborate around the technologies you\nuse most.\n\nLearn more about Collectives\n\nTeams\n\nQ&A for work\n\nConnect and share knowledge within a single location that is structured and\neasy to search.\n\nLearn more about Teams\n\nGet early access and see previews of new features.\n\nLearn more about Labs\n\n# How to compress URL parameters\n\nAsk Question\n\nAsked 10 years, 2 months ago\n\nModified 6 months ago\n\nViewed 49k times\n\nThis question shows research effort; it is useful and clear\n\n82\n\nSave this question.\n\nShow activity on this post.\n\nSay I have a single-page application that uses a third party API for content.\nThe app\u2019s logic is in-browser only; there is no backend I can write to.\n\nTo allow deep-linking into the state of the app, I use pushState() to keep\ntrack of a few variables that determine the state of the app. (Note that\nUbersicht\u2019s public version doesn\u2019t do this yet.)\n\n  * Variables: repos, labels, milestones, username, show_open (bool), with_comments (bool), and without_comments (bool).\n  * URL format: ?label=label_1,label_2,label_3&repos=repo_1....\n  * Values: the usual suspects. Roughly, [a-zA-Z][a-zA-Z0-9_-], or any boolean indicator.\n\nSo far so good.\n\nNow, since the query string can be a bit long and unwieldy and I would like to\nbe able to pass around URLs like\nhttp://espy.github.io/ubersicht/?state=SOMOPAQUETOKENTHATLOSSLESSLYDECOMPRESSESINTOTHEORIGINALVALUES#hoodiehq,\nthe shorter the better.\n\nMy first attempt was going to be using some zlib-like algorithm for this. Then\n@flipzagging pointed to antirez/smaz, which looks more suitable for short\nstrings. (JavaScript version here.)\n\nSince = and & are not specifically handled in the Javascript version (see line\n9 of the main lib file), we might be able to tweak things a little there.\n\nFurthermore, there is an option for encoding the values in a fixed table. With\nthis option, the order of arguments is pre-defined and all we need to keep\ntrack of is the actual value. Example: turn a=hamster&b=cat into 7hamster3cat\n(length+chars) or hamster|cat (value + |), potentially before the smaz\ncompression.\n\nIs there anything else I should be looking for?\n\n  * javascript\n  * url\n  * browser\n  * compression\n  * single-page-application\n\nShare\n\nCC BY-SA 4.0\n\nImprove this question\n\nFollow this question to receive notifications\n\nedited Nov 16, 2021 at 4:44\n\nZearin\n\n1,47222 gold badges1717 silver badges3636 bronze badges\n\nasked Feb 15, 2014 at 20:00\n\nJan LehnardtJan Lehnardt\n\n2,64911 gold badge1717 silver badges1414 bronze badges\n\n2\n\n  * 1\n\npacker with base62 encoding is worth a shot. i use deflate() and inflate() a\nlot, but you'll need to base64 the output of deflate...\ndanml.com/js/compression.js\n\n\u2013 dandavis\n\nFeb 19, 2014 at 0:59\n\n  * @OP - Could you store the values in a cookie or isolated storage instead of the querystring?\n\n\u2013 O.O\n\nFeb 24, 2014 at 20:43\n\nAdd a comment |\n\n## 13 Answers 13\n\nReset to default\n\nThis answer is useful\n\n68\n\nSave this answer.\n\n+200\n\nThis answer has been awarded bounties worth 200 reputation by Sven\n\nShow activity on this post.\n\nA working solution putting various bits of good (or so I think) ideas together\n\nI did this for fun, mainly because it gave me an opportunity to implement an\nHuffman encoder in PHP and I could not find a satisfactory existing\nimplementation.\n\nHowever, this might save you some time if you plan to explore a similar path.\n\n### Burrows-Wheeler+move-to-front+Huffman transform\n\nI'm not quite sure BWT would be best suited for your kind of input. This is no\nregular text, so recurring patterns would probably not occur as often as in\nsource code or plain English.\n\nBesides, a dynamic Huffman code would have to be passed along with the encoded\ndata which, for very short input strings, would harm the compression gain\nbadly.\n\nI might well be wrong, in which case I would gladly see someone prove me to\nbe.\n\nAnyway, I decided to try another approach.\n\n### General principle\n\n1) define a structure for your URL parameters and strip the constant part\n\nfor instance, starting from:\n\n    \n    \n    repos=aaa,bbb,ccc& labels=ddd,eee,fff& milestones=ggg,hhh,iii& username=kkk& show_open=0& show_closed=1& show_commented=1& show_uncommented=0\n\nextract:\n\n    \n    \n    aaa,bbb,ccc|ddd,eee,fff|ggg,hhh,iii|kkk|0110\n\nwhere , and | act as string and/or field terminators, while boolean values don't need any.\n\n2) define a static repartition of symbols based on the expected average input\nand derive a static Huffman code\n\nSince transmitting a dynamic table would take more space than your initial\nstring, I think the only way to achhieve any compression at all is to have a\nstatic huffman table.\n\nHowever, you can use the structure of your data to your advantage to compute\nreasonable probabilities.\n\nYou can start with the repartition of letters in English or other languages\nand throw in a certain percentage of numbers and other punctuation signs.\n\nTesting with a dynamic Huffman coding, I saw compression rates of 30 to 50%.\n\nThis means with a static table you can expect maybe a .6 compression factor\n(reducing the lenght of your data by 1/3), not much more.\n\n3) convert this binary Huffmann code into something an URI can handle\n\nThe 70 regular ASCII 7 bits chars in that list\n\n    \n    \n    !'()*-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\n\nwould give you an expansion factor of about 30%, practically no better than a\nbase64 encode.\n\nA 30% expansion would ruin the gain from a static Huffman compression, so this\nis hardly an option!\n\nHowever, since you control the encoding client and server side, you can use\nabout anything that is not an URI reserved character.\n\nAn interesting possiblity would be to complete the above set up to 256 with\nwhatever unicode glyphs, which would allow to encode your binary data with the\nsame number of URI-compliant characters, thus replacing a painful and slow\nbunch of long integer divisions with a lightning fast table lookup.\n\n### Structure description\n\nThe codec is meant to be used both client and server side, so it is essential\nthat server and clients share a common data structure definition.\n\nSince the interface is likely to evolve, it seems wise to store a version\nnumber for upward compatibility.\n\nThe interface definition will use a very minimalistic description language,\nlike so:\n\n    \n    \n    v 1 // version number (between 0 and 63) a en // alphabet used (English) o 10 // 10% of digits and other punctuation characters f 1 // 1% of uncompressed \"foreign\" characters s 15:3 repos // list of expeced 3 strings of average length 15 s 10:3 labels s 8:3 milestones s 10 username // single string of average length 10 b show_open // boolean value b show_closed b show_commented b show_uncommented\n\nEach language supported will have a frequency table for all its used letters\n\ndigits and other computerish symbols like -, . or _ will have a global\nfrequency, regardless of languages\n\nseparators (, and |) frequencies will be computed according to the number of\nlists and fields present in the structure.\n\nAll other \"foreign\" characters will be escaped with a specific code and\nencoded as plain UTF-8.\n\n# Implementation\n\nThe bidirectional conversion path is as follows:\n\nlist of fields <-> UTF-8 data stream <-> huffman codes <-> URI\n\nHere is the main codec\n\n    \n    \n    include ('class.huffman.codec.php'); class IRI_prm_codec { // available characters for IRI translation static private $translator = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff\u0100\u0101\u0102\u0103\u0104\u0105\u0106\u0107\u0108\u0109\u010a\u010b\u010c\u010d\u010e\u010f\u0110\u0111\u0112\u0113\u0114\u0115\u0116\u0117\u0118\u0119\u011a\u011b\u011c\u011d\u011e\u011f\u0120\u0121\u0122\u0123\u0124\u0125\u0126\u0127\u0128\u0129\u012a\u012b\u012c\u012d\u012e\u012f\u0130\u0131IJij\u0134\u0135\u0136\u0137\u0138\u0139\u013a\u013b\u013c\u013d\u013eL\u00b7l\u00b7\u0141\u0142\u0143\u0144\u0145\u0146\u0147\u0148\u02bcn\u014a\u014b\u014c\u014d\u014e\u014f\u0150\u0151\u0152\u0153\u0154\u0155\u0156\u0157\u0158\u0159\u015a\u015b\u015c\u015d\u015e\u015f\u0160\u0161\u0162\u0163\u0164\u0165\u0166\u0167\u0168\u0169\u016a\u016b\u016c\u016d\u016e\u016f\u0170\u0171\u0172\u0173\u0174\u0175\u0176\u0177\u0178\u0179\u017a\u017b\u017c\u017d\u017es\u0180\u0181\u0182\u0183\u0184\u0185\"; const VERSION_LEN = 6; // version number between 0 and 63 // ======================================================================== // constructs an encoder // ======================================================================== public function __construct ($config) { $num_record_terminators = 0; $num_record_separators = 0; $num_text_sym = 0; // parse config file $lines = file($config, FILE_IGNORE_NEW_LINES|FILE_SKIP_EMPTY_LINES); foreach ($lines as $line) { list ($code, $val) = preg_split('/\\s+/', $line, 2); switch ($code) { case 'v': $this->version = intval($val); break; case 'a': $alphabet = $val; break; case 'o': $percent_others = $val; break; case 'f': $percent_foreign = $val; break; case 'b': $this->type[$val] = 'b'; break; case 's': list ($val, $field) = preg_split('/\\s+/u', $val, 2); @list ($len,$num) = explode (':', $val); if (!$num) $num=1; $this->type[$field] = 's'; $num_record_terminators++; $num_record_separators+=$num-1; $num_text_sym += $num*$len; break; default: throw new Exception (\"Invalid config parameter $code\"); } } // compute symbol frequencies $total = $num_record_terminators + $num_record_separators + $num_text_sym + 1; $num_chars = $num_text_sym * (100-($percent_others+$percent_foreign))/100; $num_sym = $num_text_sym * $percent_others/100; $num_foreign = $num_text_sym * $percent_foreign/100; $this->get_frequencies ($alphabet, $num_chars/$total); $this->set_frequencies (\" .-_0123456789\", $num_sym/$total); $this->set_frequencies (\"|\", $num_record_terminators/$total); $this->set_frequencies (\",\", $num_record_separators/$total); $this->set_frequencies (\"\\1\", $num_foreign/$total); $this->set_frequencies (\"\\0\", 1/$total); // create Huffman codec $this->huffman = new Huffman_codec(); $this->huffman->make_code ($this->frequency); } // ------------------------------------------------------------------------ // grab letter frequencies for a given language // ------------------------------------------------------------------------ private function get_frequencies ($lang, $coef) { $coef /= 100; $frequs = file(\"$lang.dat\", FILE_IGNORE_NEW_LINES|FILE_SKIP_EMPTY_LINES); foreach ($frequs as $line) { $vals = explode (\" \", $line); $this->frequency[$vals[0]] = floatval ($vals[1]) * $coef; } } // ------------------------------------------------------------------------ // set a given frequency for a group of symbols // ------------------------------------------------------------------------ private function set_frequencies ($symbols, $coef) { $coef /= strlen ($symbols); for ($i = 0 ; $i != strlen($symbols) ; $i++) $this->frequency[$symbols[$i]] = $coef; } // ======================================================================== // encodes a parameter block // ======================================================================== public function encode($input) { // get back input values $bools = ''; foreach (get_object_vars($input) as $prop => $val) { if (!isset ($this->type[$prop])) throw new Exception (\"unknown property $prop\"); switch ($this->type[$prop]) { case 'b': $bools .= $val ? '1' : '0'; break; case 's': $strings[] = $val; break; default: throw new Exception (\"Uh oh... type \".$this->type[$prop].\" not handled ?!?\"); } } // set version number and boolean values in front $prefix = sprintf (\"%0\".self::VERSION_LEN.\"b$bools\", $this->version); // pass strings to our Huffman encoder $strings = implode (\"|\", $strings); $huff = $this->huffman->encode ($strings, $prefix, \"UTF-8\"); // translate into IRI characters mb_internal_encoding(\"UTF-8\"); $res = ''; for ($i = 0 ; $i != strlen($huff) ; $i++) $res .= mb_substr (self::$translator, ord($huff[$i]), 1); // done return $res; } // ======================================================================== // decodes an IRI string into a lambda object // ======================================================================== public function decode($input) { // convert IRI characters to binary mb_internal_encoding(\"UTF-8\"); $raw = ''; $len = mb_strlen ($input); for ($i = 0 ; $i != $len ; $i++) { $c = mb_substr ($input, 0, 1); $input = mb_substr ($input, 1); $raw .= chr(mb_strpos (self::$translator, $c)); } $this->bin = ''; // check version $version = $this->read_bits ($raw, self::VERSION_LEN); if ($version != $this->version) throw new Exception (\"Version mismatch: expected {$this->version}, found $version\"); // read booleans foreach ($this->type as $field => $type) if ($type == 'b') $res->$field = $this->read_bits ($raw, 1) != 0; // decode strings $strings = explode ('|', $this->huffman->decode ($raw, $this->bin)); $i = 0; foreach ($this->type as $field => $type) if ($type == 's') $res->$field = $strings[$i++]; // done return $res; } // ------------------------------------------------------------------------ // reads raw bit blocks from a binary string // ------------------------------------------------------------------------ private function read_bits (&$raw, $len) { while (strlen($this->bin) < $len) { if ($raw == '') throw new Exception (\"premature end of input\"); $this->bin .= sprintf (\"%08b\", ord($raw[0])); $raw = substr($raw, 1); } $res = bindec (substr($this->bin, 0, $len)); $this->bin = substr ($this->bin, $len); return $res; } }\n\nThe underlying Huffman codec\n\n    \n    \n    include ('class.huffman.dict.php'); class Huffman_codec { public $dict = null; // ======================================================================== // encodes a string in a given string encoding (default: UTF-8) // ======================================================================== public function encode($input, $prefix='', $encoding=\"UTF-8\") { mb_internal_encoding($encoding); $bin = $prefix; $res = ''; $input .= \"\\0\"; $len = mb_strlen ($input); while ($len--) { // get next input character $c = mb_substr ($input, 0, 1); $input = substr($input, strlen($c)); // avoid playing Schlemiel the painter // check for foreign characters if (isset($this->dict->code[$c])) { // output huffman code $bin .= $this->dict->code[$c]; } else // foreign character { // escape sequence $lc = strlen($c); $bin .= $this->dict->code[\"\\1\"] . sprintf(\"%02b\", $lc-1); // character length (1 to 4) // output plain character for ($i=0 ; $i != $lc ; $i++) $bin .= sprintf(\"%08b\", ord($c[$i])); } // convert code to binary while (strlen($bin) >= 8) { $res .= chr(bindec(substr ($bin, 0, 8))); $bin = substr($bin, 8); } } // output last byte if needed if (strlen($bin) > 0) { $bin .= str_repeat ('0', 8-strlen($bin)); $res .= chr(bindec($bin)); } // done return $res; } // ======================================================================== // decodes a string (will be in the string encoding used during encoding) // ======================================================================== public function decode($input, $prefix='') { $bin = $prefix; $res = ''; $len = strlen($input); for ($i=0 ;;) { $c = $this->dict->symbol($bin); switch ((string)$c) { case \"\\0\": // end of input break 2; case \"\\1\": // plain character // get char byte size if (strlen($bin) < 2) { if ($i == $len) throw new Exception (\"incomplete escape sequence\"); $bin .= sprintf (\"%08b\", ord($input[$i++])); } $lc = 1 + bindec(substr($bin,0,2)); $bin = substr($bin,2); // get char bytes while ($lc--) { if ($i == $len) throw new Exception (\"incomplete escape sequence\"); $bin .= sprintf (\"%08b\", ord($input[$i++])); $res .= chr(bindec(substr($bin, 0, 8))); $bin = substr ($bin, 8); } break; case null: // not enough bits do decode further // get more input if ($i == $len) throw new Exception (\"no end of input mark found\"); $bin .= sprintf (\"%08b\", ord($input[$i++])); break; default: // huffman encoded $res .= $c; break; } } if (bindec ($bin) != 0) throw new Exception (\"trailing bits in input\"); return $res; } // ======================================================================== // builds a huffman code from an input string or frequency table // ======================================================================== public function make_code ($input, $encoding=\"UTF-8\") { if (is_string ($input)) { // make dynamic table from the input message mb_internal_encoding($encoding); $frequency = array(); while ($input != '') { $c = mb_substr ($input, 0, 1); $input = mb_substr ($input, 1); if (isset ($frequency[$c])) $frequency[$c]++; else $frequency[$c]=1; } $this->dict = new Huffman_dict ($frequency); } else // assume $input is an array of symbol-indexed frequencies { $this->dict = new Huffman_dict ($input); } } }\n\nAnd the huffman dictionary\n\n    \n    \n    class Huffman_dict { public $code = array(); // ======================================================================== // constructs a dictionnary from an array of frequencies indexed by symbols // ======================================================================== public function __construct ($frequency = array()) { // add terminator and escape symbols if (!isset ($frequency[\"\\0\"])) $frequency[\"\\0\"] = 1e-100; if (!isset ($frequency[\"\\1\"])) $frequency[\"\\1\"] = 1e-100; // sort symbols by increasing frequencies asort ($frequency); // create an initial array of (frequency, symbol) pairs foreach ($frequency as $symbol => $frequence) $occurences[] = array ($frequence, $symbol); while (count($occurences) > 1) { $leaf1 = array_shift($occurences); $leaf2 = array_shift($occurences); $occurences[] = array($leaf1[0] + $leaf2[0], array($leaf1, $leaf2)); sort($occurences); } $this->tree = $this->build($occurences[0], ''); } // ----------------------------------------------------------- // recursive build of lookup tree and symbol[code] table // ----------------------------------------------------------- private function build ($node, $prefix) { if (is_array($node[1])) { return array ( '0' => $this->build ($node[1][0], $prefix.'0'), '1' => $this->build ($node[1][1], $prefix.'1')); } else { $this->code[$node[1]] = $prefix; return $node[1]; } } // =========================================================== // extracts a symbol from a code stream // if found : updates code stream and returns symbol // if not found : returns null and leave stream intact // =========================================================== public function symbol(&$code_stream) { list ($symbol, $code) = $this->get_symbol ($this->tree, $code_stream); if ($symbol !== null) $code_stream = $code; return $symbol; } // ----------------------------------------------------------- // recursive search for a symbol from an huffman code // ----------------------------------------------------------- private function get_symbol ($node, $code) { if (is_array($node)) { if ($code == '') return null; return $this->get_symbol ($node[$code[0]], substr($code, 1)); } return array ($node, $code); } }\n\n### Example\n\n    \n    \n    include ('class.iriprm.codec.php'); $iri = new IRI_prm_codec (\"config.txt\"); foreach (array ( 'repos' => \"discussion,documentation,hoodie-cli\", 'labels' => \"enhancement,release-0.3.0,starter\", 'milestones' => \"1.0.0,1.1.0,v0.7\", 'username' => \"mklappstuhl\", 'show_open' => false, 'show_closed' => true, 'show_commented' => true, 'show_uncommented' => false ) as $prop => $val) $iri_prm->$prop = $val; $encoded = $iri->encode ($iri_prm); echo \"encoded as $encoded\\n\"; $decoded = $iri->decode ($encoded); var_dump($decoded);\n\noutput:\n\n    \n    \n    encoded as 5\u0136\u016f\u0165\u00ca\u0115CO\u0114\u0180\u016a\u013c\u0164\u0142m\u0104ZE\u00c7\u017d\u00c9\u012f\u00f3\u0161\u00fc\u00ffj\u0127\u0169\u00c5\u00ec\u00c7\u0113O\u012a\u00e4\u0156\u00cf\u0145\u00ed\u017b\u00c9\u0112Qm\u00ecFOy\u00e4\u0156\u011eq\u00e6\u0160\u0179\u014d\u00cd\u0118\u00c6\u0164\u0145\u00cb\u0126 object(stdClass)#7 (8) { [\"show_open\"]=> bool(false) [\"show_closed\"]=> bool(true) [\"show_commented\"]=> bool(true) [\"show_uncommented\"]=> bool(false) [\"repos\"]=> string(35) \"discussion,documentation,hoodie-cli\" [\"labels\"]=> string(33) \"enhancement,release-0.3.0,starter\" [\"milestones\"]=> string(16) \"1.0.0,1.1.0,v0.7\" [\"username\"]=> string(11) \"mklappstuhl\" }\n\nIn that example, the input got packed into 64 unicode characters, for an input\nlength of about 100, yielding a 1/3 reduction.\n\nAn equivalent string:\n\n    \n    \n    discussion,documentation,hoodie-cli|enhancement,release-0.3.0,starter| 1.0.0,1.1.0,v0.7|mklappstuhl|0110\n\nWould be compressed by a dynamic Huffman table to 59 characters. Not much of a\ndifference.\n\nNo doubt smart data reordering would reduce that, but then you would need to\npass the dynamic table along...\n\n### Chinese to the rescue?\n\nDrawing on ttepasse's idea, one could take advantage of the huge number of\nAsian characters to find a range of 0x4000 (12 bits) contiguous values, to\ncode 3 bytes into 2 CJK characters, like so:\n\n    \n    \n    // translate into IRI characters $res = ''; $len = strlen ($huff); for ($i = 0 ; $i != $len ; $i++) { $byte = ord($huff[$i]); $quartet[2*$i ] = $byte >> 4; $quartet[2*$i+1] = $byte &0xF; } $len *= 2; while ($len%3 != 0) $quartet[$len++] = 0; $len /= 3; for ($i = 0 ; $i != $len ; $i++) { $utf16 = 0x4E00 // CJK page base, enough range for 2**12 (0x4000) values + ($quartet[3*$i+0] << 8) + ($quartet[3*$i+1] << 4) + ($quartet[3*$i+2] << 0); $c = chr ($utf16 >> 8) . chr ($utf16 & 0xFF); $res .= $c; } $res = mb_convert_encoding ($res, \"UTF-8\", \"UTF-16\");\n\nand back:\n\n    \n    \n    // convert IRI characters to binary $input = mb_convert_encoding ($input, \"UTF-16\", \"UTF-8\"); $len = strlen ($input)/2; for ($i = 0 ; $i != $len ; $i++) { $val = (ord($input[2*$i ]) << 8) + ord ($input[2*$i+1]) - 0x4E00; $quartet[3*$i+0] = ($val >> 8) &0xF; $quartet[3*$i+1] = ($val >> 4) &0xF; $quartet[3*$i+2] = ($val >> 0) &0xF; } $len *= 3; while ($len %2) $quartet[$len++] = 0; $len /= 2; $raw = ''; for ($i = 0 ; $i != $len ; $i++) { $raw .= chr (($quartet[2*$i+0] << 4) + $quartet[2*$i+1]); }\n\nThe previous output of 64 Latin chars\n\n    \n    \n    5\u0136\u016f\u0165\u00ca\u0115CO\u0114\u0180\u016a\u013c\u0164\u0142m\u0104ZE\u00c7\u017d\u00c9\u012f\u00f3\u0161\u00fc\u00ffj\u0127\u0169\u00c5\u00ec\u00c7\u0113O\u012a\u00e4\u0156\u00cf\u0145\u00ed\u017b\u00c9\u0112Qm\u00ecFOy\u00e4\u0156\u011eq\u00e6\u0160\u0179\u014d\u00cd\u0118\u00c6\u0164\u0145\u00cb\u0126\n\nwould \"shrink\" to 42 Asian characters:\n\n    \n    \n    \u4e59\u583d\u5b74\u5cf4\u52c0\u57a7\u58e9\u5778\u51ab\u5698\u4f70\u5ada\u51f2\u54a9\u4fc7\u5671\u5235\u5dcb\u5a1c\u597e\u57f5\u5cfc\u5714\u594c\u5911\u555d\u556f\u5dbc\u52f2\u5a52\u5a45\u51cb\u51cb\u4f13\u508a\u53b7\u4f96\u54a5\u5304\u51af\u5871\u50cc\n\nHowever, as you can see, the sheer bulk of your average ideogram makes the\nstring actually longer (pixel-wise), so even if the idea was promising, the\noutcome is rather disappointing.\n\n### Picking thinner glyphs\n\nOn the other hand, you can try to pick \"thin\" characters as a base for URI\nencoding. For instance:\n\n    \n    \n    \u2588\u144a\u0250\u2032\u04cf\u025c\u2c66\u025b\u1d4ei\u00efa\u0292\u16ec\u0163\u029f\ua78c\u026d\u1807\u0702\u0627l\u029d\u0292\u16c1\u205ae\u0287\u020b\u0287\u03af\u05df\u1819\u06c3\u1fd7\u1963\u025b\u012d\ua78c\u17f2\u16e7\u0f1a\u01ab\u0719\u06d4\u02c0\u0237\u02c1\u0287\u02b9\u012d\u2215\u0671;\u0142\u0269\u0575;J\u205a\u0129i\u2044\u0288\u2588\n\ninstead of\n\n    \n    \n    \u25885\u0136\u016f\u0165\u00ca\u0115CO\u0114\u0180\u016a\u013c\u0164\u0142m\u0104ZE\u00c7\u017d\u00c9\u012f\u00f3\u0161\u00fc\u00ffj\u0127\u0169\u00c5\u00ec\u00c7\u0113O\u012a\u00e4\u0156\u00cf\u0145\u00ed\u017b\u00c9\u0112Qm\u00ecFOy\u00e4\u0156\u011eq\u00e6\u0160\u0179\u014d\u00cd\u0118\u00c6\u0164\u0145\u00cb\u0126\u2588\n\nThat will shrink the length by half with proportional fonts, including in a\nbrowser address bar.\n\nMy best candidate set of 256 \"thin\" glyphs so far:\n\n    \n    \n    \u180a\u0f0d\u144aj\u0f0b\u0f0b\u1d4ei\u0268\u026d\u1d85\u026a\u1d7bl \u2044\u2215\u0e40'\ua78b\ua78c\ua876\u0269t\u01ab\u029d|\u00a6\u01c0I \u1427f\u025f\u0f34s\u0282\u204f\u0283r\u0279\u027b\u0589\u16ec\u236e\u02b9\u2032 \u205a\u205dr\u2358\u0f14\u237f\u1835\u1963\u025b\u025c\u025cJ\u01c2\u02c0\u02c1\u0295\u0f11,. \u2219\u0196\u17f2\u1819e\u0259\u0254c\u0255e\u0259\u0575\u2d4f\u2d51\u0f1d\u0f0e\u055b\u03b3\u03b3\u16bd\u16c1\u16c2\u16cc\u16cd\u16d9\u16e7\u0261\u0292\u09f7\u2373\u0269\u0390\u03af\u03b9\u03ca\u1d7c\u1f30\u1f31\u1f32\u1f33\u1f34\u1f35\u1f36\u1f37\u1f76\u03af\u1fd0\u1fd1\u1fd2\u0390\u1fd6\u1fd7\u23b0\u23b1\u1806\u03b8\u055d\u03b4\u029fa\u0250z\u0290a\u222ba\u0c79\u1814/:;\\ijlt\u00ec\u00ed\u00ee\u00ef\u0129\u012b\u012d\u012f\u0131\u0135\u013a\u013c\u0142\u0163\u0167s\u019a\u01ab\u01ad\u01d0\u01f0\u0209\u020b\u021b\u0234\u0237\u0249\u0268\u026a\u026b\u026c\u026d\u0287\u0288\u029d\u02d0\u02d1\u02f8;\u00b7\u03f3\u0456\u0457\u0458\u04cf\u1807\u1d09\u1d75\u1d7b\u1d85\u1d96\u1e2d\u1e2f\u1e37\u1e39\u1e3b\u1e3d\u1e6b\u1e6d\u1e6f\u1e71\u1e97\u1e61\u1ec9\u1ecb\u205e\u23ba\u23bb\u23bc\u23bd\u2c61\u2c66\ua789\u0f08\u01c1\u2016\u0f05\u0f1a\u014b\u03b2\u03c7\u03b2\u03c7\u0e32\u1811\u2af6\u00f0\u1681\u1686\u168b\u1690\u1695o\u1d16\u1d17\u0275o\u2d57xx\u028b\u0e45\u0281\u0263\u16ebvv\u028c\u1d0a\n\n# Conclusion\n\nThis implementation should be ported to JavaScript to allow client-server\nexchange. You should also provide a way to share the structure and Huffman\ncodes with the clients.\n\nIt is not difficult and rather fun to do, but that means even more work :).\n\nThe Huffman gain in term of characters is around 30%.\n\nOf course these characters are multibyte for the most part, but if you aim for\nthe shortest URI it does not matter. Except for the booleans that can easily\nbe packed to 1 bit, those pesky strings seem rather reluctant to be\ncompressed. It might be possible to better tune the frequencies, but I doubt\nyou will get above 50% compression rate.\n\nOn the other hand, picking thin glyphs does actually more to shrink the\nstring.\n\nSo all in all the combination of both might indeed achieve something, though\nit's a lot of work for a modest result.\n\nShare\n\nCC BY-SA 3.0\n\nImprove this answer\n\nFollow this answer to receive notifications\n\nedited Feb 24, 2014 at 13:47\n\nanswered Feb 24, 2014 at 0:46\n\nkuroi nekokuroi neko\n\n8,60711 gold badge2020 silver badges4444 bronze badges\n\n6\n\n  * 4\n\nYour post also deserves a bounty - I'll be back.\n\n\u2013 Sven\n\nFeb 25, 2014 at 8:05\n\n  * Thanks. I'm not here for the money anyway :). I could port the relevant bit to JavaScript to make a more suited response, but at any rate I think the JS port of Google's protocol buffers is not the right tool for the job. You would embark literally thousands of lines of JavaScript to swat a fly, and the resulting \"compressed\" string would actually be longer than your stripped down message payload.\n\n\u2013 kuroi neko\n\nFeb 25, 2014 at 10:00\n\n  * Really curious about the downvote... Is this post violating a law?\n\n\u2013 kuroi neko\n\nOct 29, 2015 at 13:53\n\n  * Here's your bounty. Not sure 200 is too much, but SO let's you only award in incremental steps, so no 100 additional bounty. On the other hand, your answer got significantly more upvotes than the other one, and I take it as a positive vote from the audience.\n\n\u2013 Sven\n\nNov 2, 2015 at 17:27\n\n  * 1\n\nAny JS implementation of this?\n\n\u2013 rraallvv\n\nMay 25, 2018 at 5:40\n\n| Show 1 more comment\n\nThis answer is useful\n\n17\n\nSave this answer.\n\nShow activity on this post.\n\nJust as you yourself propose, I would first get rid of all the characters that\nare not carrying any information, because they are part of the \"format\".\n\nE.g. turn\n\"labels=open,ssl,cypher&repository=275643&username=ryanbrg&milestones=&with_comment=yes\"\nto \"open,ssl,cyper|275643|ryanbrg||yes\".\n\nThen use a Huffmann encoding with a fixed probability vector (resulting in a\nfixed mapping from characters to variable length bitstrings - with the most\nprobable characters mapped to shorter bitstrings and less probable characters\nmapped to longer bitstrings).\n\nYou could even use different probability vectors for the different parameters.\nFor example in the parameter \"labels\" the alpha characters will have high\nprobability, but in the \"repository\" parameter the numeric characters will\nhave the highest probability. If you do this, you should consider the\nseparator \"|\" a part of the preceeding parameter.\n\nAnd finally turn the long bitstring (which is the concatenation all the\nbitstrings to which the characters were mapped) into something you can put\ninto an URL by base64url encoding it.\n\nIf you could send me a set of representative parameter lists, I could run them\nthrough a Huffmann coder to see how well they compress.\n\nThe probability vector (or equivalently the mapping from characters to\nbitstrings) should be encoded as constant arrays into the Javascript function\nthat is sent to the browser.\n\nOf course you could go even further and - for example - try to get a list of\npossible lables with their probabilities. Then you could map entire lables to\nbitstrings with a Huffmann encoding. This will give you better compression,\nbut you will have extra work for those labels that are new (e.g. falling back\nto the single character encoding), and of course the mapping (which - as\nmentioned above - is a constant array in the Javascript function) will be much\nlarger.\n\nShare\n\nCC BY-SA 3.0\n\nImprove this answer\n\nFollow this answer to receive notifications\n\nanswered Feb 16, 2014 at 22:44\n\nmschoenertmschoenert\n\n32111 silver badge55 bronze badges\n\nAdd a comment |\n\nThis answer is useful\n\n17\n\nSave this answer.\n\n+100\n\nThis answer has been awarded bounties worth 100 reputation by Sven\n\nShow activity on this post.\n\nWhy not using protocol-buffers?\n\n> Protocol buffers are a flexible, efficient, automated mechanism for\n> serializing structured data \u2013 think XML, but smaller, faster, and simpler.\n> You define how you want your data to be structured once, then you can use\n> special generated source code to easily write and read your structured data\n> to and from a variety of data streams and using a variety of languages. You\n> can even update your data structure without breaking deployed programs that\n> are compiled against the \"old\" format.\n\nProtoBuf.js converts objects to protocol buffer messages and vice vera.\n\nThe following object converts to: CgFhCgFiCgFjEgFkEgFlEgFmGgFnGgFoGgFpIgNqZ2I=\n\n    \n    \n    { repos : ['a', 'b', 'c'], labels: ['d', 'e', 'f'], milestones : ['g', 'h', 'i'], username : 'jgb' }\n\n## Example\n\nThe following example is built using require.js. Give it a try on this\njsfiddle.\n\n    \n    \n    require.config({ paths : { 'Math/Long' : '//rawgithub.com/dcodeIO/Long.js/master/Long.min', 'ByteBuffer' : '//rawgithub.com/dcodeIO/ByteBuffer.js/master/ByteBuffer.min', 'ProtoBuf' : '//rawgithub.com/dcodeIO/ProtoBuf.js/master/ProtoBuf.min' } }) require(['message'], function(message) { var data = { repos : ['a', 'b', 'c'], labels: ['d', 'e', 'f'], milestones : ['g', 'h', 'i'], username : 'jgb' } var request = new message.arguments(data); // Convert request data to base64 var base64String = request.toBase64(); console.log(base64String); // Convert base64 back var decodedRequest = message.arguments.decode64(base64String); console.log(decodedRequest); }); // Protobuf message definition // Message definition could also be stored in a .proto definition file // See: https://github.com/dcodeIO/ProtoBuf.js/wiki define('message', ['ProtoBuf'], function(ProtoBuf) { var proto = { package : 'message', messages : [ { name : 'arguments', fields : [ { rule : 'repeated', type : 'string', name : 'repos', id : 1 }, { rule : 'repeated', type : 'string', name : 'labels', id : 2 }, { rule : 'repeated', type : 'string', name : 'milestones', id : 3 }, { rule : 'required', type : 'string', name : 'username', id : 4 }, { rule : 'optional', type : 'bool', name : 'with_comments', id : 5 }, { rule : 'optional', type : 'bool', name : 'without_comments', id : 6 } ], } ] }; return ProtoBuf.loadJson(proto).build('message') });\n\nShare\n\nCC BY-SA 3.0\n\nImprove this answer\n\nFollow this answer to receive notifications\n\nedited Jan 21, 2016 at 10:16\n\nanswered Feb 24, 2014 at 21:12\n\njgbjgb\n\n1,21655 gold badges1818 silver badges2828 bronze badges\n\n5\n\n  * 5\n\nBounty awarded for having a real implementation in Javascript that looks like\nit is shortening data and returning it back.\n\n\u2013 Sven\n\nFeb 25, 2014 at 8:03\n\n  * 1\n\nProtocol buffers : 4000 lines of JavaScript. Require.js : 2000 lines of\nJavaScript. Expansion factor superior to 1. If this is a solution, what was\nthe problem? ;)\n\n\u2013 kuroi neko\n\nFeb 25, 2014 at 9:54\n\n  * @kuroineko require.js is optional. Long.js, ByteBuffer.js and ProtoBuf.js are minified and gziped 20Kb (1 second download time over a 128 Kbps connection). This proposal is straightforward and backward compatible with future changes (old bookmarks).\n\n\u2013 jgb\n\nFeb 25, 2014 at 10:37\n\n  * I'm not here to argue, but this compatibility depends on an external port of Google's libraries, which are maintained only for C++, Python and Ruby. In my opinion, the flaw in this solution is to embark everything client-side, while a server-side tool could do 90% of the work and pass only the minimal data to the clients (the parameters structure and the compressed string), reducing the client-side code to a small coder/decoder (and more efficient than base64 encode, or else the \"compressed\" string would actually be longer than the raw data!).\n\n\u2013 kuroi neko\n\nFeb 25, 2014 at 10:59\n\n  * 3\n\njsfiddle is broken. Get a 404 for\nrawgit.com/dcodeIO/protobuf.js/master/dist/...\n\n\u2013 Ryan\n\nMay 18, 2020 at 21:54\n\nAdd a comment |\n\nThis answer is useful\n\n13\n\nSave this answer.\n\nShow activity on this post.\n\nI have a cunning plan! ^(And a drink of gin tonic)\n\nYou doesn't seem to care about the length of the bytestream but of the length\nof the resulting glyphs, e.g. what the string which is displayed to the user.\n\nBrowser are pretty good in converting an IRI to the underlying [URI][2] while\nstill displaying the IRI in the address bar. IRIs have a greater repertoire of\npossible characters while your set of possible chars is rather limited.\n\nThat means you can encode bigrams of your chars (aa, ab, ac, ..., zz & special\nchars) into one char of the full unicode spectrum. Say you've got 80 possible\nASCII chars: the number of possible combinations of two chars is 6400. Which\nare easy findable in Unicodes assigned chars, e.g. in the han unified CJK\nspectrum:\n\n    \n    \n    aa \u2192 \u4e00 ab \u2192 \u4e01 ac \u2192 \u4e02 ad \u2192 \u4e03 ...\n\nI picked CJK because this is only (slighty) reasonable if the target chars are\nassigned in unicode and have assigned glyphs on the major browser and\noperating systems. For that reason the private use area is out and the more\nefficient version using trigrams (whose possible combinations could use all of\nUnicodes 1114112 possible code points) are out.\n\nTo recap: the underlying bytes are still there and \u2013 given UTF-8 encoding \u2013\npossible even longer, but the string of displayed characters the user sees and\ncopies is 50% shorter.\n\n### Ok, Ok, reasons, why this solution is insane:\n\n  * IRIs are not perfect. A lot of lesser tools than modern browser have their problems.\n\n  * The algorithm needs obviously a lot of more work. You'll need a function which maps the bigrams to the target chars and back. And it should preferable work arithmetically to avoid big hash tables in memory.\n\n  * The target chars should be checked if they are assigned and if they are simple chars and not fancy unicodian things like combining chars or stuff that got lost somewhere in Unicode normalization. Also if the target area is an continuous span of assigned chars with glyphs.\n\n  * Browser are sometimes wary of IRIs. For good reason, given the IDN homograph attacks. Are they OK with all these non-ASCII-chars in their address bar?\n\n  * And the biggest: people are notoriously bad at remembering characters in scripts they don't know. They are even worse at trying to (re)-type these chars. And copy'n'paste can go wrong in many different clicks. There is a reason URL shorteners use Base64 and even smaller alphabets.\n\n... speaking of which: That would be my solution. Offloading the work of\nshortening links either to the user or integrating goo.gl or bit.ly via their\nAPIs.\n\nShare\n\nCC BY-SA 3.0\n\nImprove this answer\n\nFollow this answer to receive notifications\n\nanswered Feb 15, 2014 at 21:56\n\nttepassettepasse\n\n74644 silver badges99 bronze badges\n\n0\n\nAdd a comment |\n\nThis answer is useful\n\n10\n\nSave this answer.\n\nShow activity on this post.\n\nSmall tip: Both parseInt and Number#toString support radix arguments. Try\nusing a radix of 36 to encode numbers (or indexes into lists) in URLs.\n\nShare\n\nCC BY-SA 3.0\n\nImprove this answer\n\nFollow this answer to receive notifications\n\nanswered Feb 15, 2014 at 20:13\n\nthomasfuchsthomasfuchs\n\n5,45622 gold badges1919 silver badges3838 bronze badges\n\nAdd a comment |\n\nThis answer is useful\n\n8\n\nSave this answer.\n\nShow activity on this post.\n\nUpdate: I released an NPM package with some more optimizations, see\nhttps://www.npmjs.com/package/@yaska-eu/jsurl2\n\nSome more tips:\n\n  * Base64 encodes with a..zA..Z0..9+/=, and un-encoded URI characters are a..zA..Z0..9-_.~. So Base64 results only need to swap +/= for -_. and it won't expand URIs.\n  * You could keep an array of key names, so that objects could be represented with the first character being the offset in the array, e.g. {foo:3,bar:{g:'hi'}} becomes a3,b{c'hi'} given key array ['foo','bar','g']\n\nInteresting libraries:\n\n  * JSUrl specifically encodes JSON so it can be put in a URL without changes, even though it uses more characters than specified in the RFC. {\"name\":\"John Doe\",\"age\":42,\"children\":[\"Mary\",\"Bill\"]} becomes ~(name~'John*20Doe~age~42~children~(~'Mary~'Bill)) and with a key dictionary ['name','age','children'] that could be ~(0~'John*20Doe~1~42~2~(~'Mary~'Bill)), thus going from 101 bytes URI encoded to 38.\n\n    * Small footprint, fast, reasonable compression.\n  * lz-string uses an LZW-based algorithm to compress strings to UTF16 for storing in localStorage. It also has a compressToEncodedURIComponent() function to produce URI-safe output.\n\n    * Still only a few KB of code, pretty fast, good/great compression.\n\nSo basically I'd recommend picking one of these two libraries and consider the\nproblem solved.\n\nShare\n\nCC BY-SA 4.0\n\nImprove this answer\n\nFollow this answer to receive notifications\n\nedited Dec 5, 2018 at 11:04\n\nanswered Jun 8, 2015 at 18:54\n\nw00tw00t\n\n18.1k88 gold badges5555 silver badges6262 bronze badges\n\n1\n\n  * Hey, just a small sidenote: base64 encoding ultimately makes strings longer, especially if you were using basic ascii in the first place (a whole lot encoding space will remain unused).\n\n\u2013 Christian\n\nMay 1, 2023 at 12:55\n\nAdd a comment |\n\nThis answer is useful\n\n8\n\nSave this answer.\n\nShow activity on this post.\n\nThere are two main aspects to the problem: encoding and compression.\n\nGeneral purpose compression doesn\u2019t seem to work well on small strings. As\nbrowsers don\u2019t provide any API to compress strings, you also need to load the\nsource, which can be huge.\n\nBut a lot of characters can be saved by using an efficient encoding. I have\nwritten a library named \u03bc to handle the encoding and decoding part.\n\nThe idea is to specify as much as information available about the structure\nand domain of the URL parameters as a specification. This specification can be\nthen used to drive the encoding and decoding. For example:\n\n  * booleans can be encoded using just one bit;\n  * integers can be converted to base64 (thereby reducing the number of characters required);\n  * object keys need not be encoded (because they can be inferred from the specification);\n  * enums can be encoded using log_2(numberOfAllowedValues) bits.\n\nShare\n\nCC BY-SA 4.0\n\nImprove this answer\n\nFollow this answer to receive notifications\n\nedited Nov 14, 2021 at 21:52\n\nH\u00fcseyin BABAL\n\n15.4k44 gold badges5151 silver badges7474 bronze badges\n\nanswered Mar 5, 2016 at 4:31\n\nAnantha KumaranAnantha Kumaran\n\n10.3k88 gold badges3535 silver badges3636 bronze badges\n\n3\n\n  * 2\n\nI like this implementation! Tried it in our project and seems to be working\nnicely. Now just need to get it working with angular routing :)\n\n\u2013 RichieRock\n\nNov 28, 2017 at 14:13\n\n  * Is it compatible with IE9?\n\n\u2013 Sachin Singh\n\nDec 6, 2018 at 8:58\n\n  * I haven't tested it explicitly with IE9, but it should work as the implementation doesn't depend on any browser-specific api.\n\n\u2013 Anantha Kumaran\n\nDec 7, 2018 at 9:14\n\nAdd a comment |\n\nThis answer is useful\n\n3\n\nSave this answer.\n\nShow activity on this post.\n\nPerhaps you can find a url shortener with a jsonp API, that way you could make\nall the URLs really short automatically.\n\nhttp://yourls.org/ even has jsonp support.\n\nShare\n\nCC BY-SA 3.0\n\nImprove this answer\n\nFollow this answer to receive notifications\n\nedited Feb 15, 2014 at 22:44\n\nanswered Feb 15, 2014 at 22:32\n\nJeenaJeena\n\n2,22233 gold badges2828 silver badges4646 bronze badges\n\n1\n\n  * 2\n\nI think this solution, while valid in a general case, is ruled out by the\nrestriction of \"no backend to write to\", no matter how sophisticated the\nmethod of communication. :)\n\n\u2013 Sven\n\nFeb 19, 2014 at 14:57\n\nAdd a comment |\n\nThis answer is useful\n\n2\n\nSave this answer.\n\nShow activity on this post.\n\nIt looks like the Github APIs have numeric IDs for many things (looks like\nrepos and users have them, but labels don't) under the covers. It might be\npossible to use those numbers instead of names wherever advantageous. You then\nhave to figure out how to best encode those in something that'll survive in a\nquery string, e.g. something like base64(url).\n\nFor example, your hoodie.js repository has ID 4780572.\n\nPacking that into a big-endian unsigned int (as many bytes as we need) gets us\n\\x00H\\xf2\\x1c.\n\nWe'll just toss the leading zero, we can always restore that later, now we\nhave H\\xf2\\x1c.\n\nEncode as URL-safe base64, and you have SPIc (toss any padding you might get).\n\nGoing from hoodiehq/hoodie.js to SPIc seems like a good-sized win!\n\nMore generally, if you're willing to invest the time, you can try to exploit a\nbunch of redudancies in your query strings. Other ideas are along the lines of\npacking the two boolean params into a single character, possibly along with\nother state (like what fields are included). If you use base64-encoding (which\nseems the best option here due to the URL-safe version -- I looked at base85,\nbut it has a bunch of characters that won't survive in a URL), that gets you 6\nbits of entropy per character... there's a lot you can do with that.\n\nTo add to Thomas Fuchs' note, yes, if there's some kind of inherent, immutable\nordering in some of things you're encoding, than that would obviously also\nhelp. However, that seems hard for both the labels and the milestones.\n\nShare\n\nCC BY-SA 3.0\n\nImprove this answer\n\nFollow this answer to receive notifications\n\nedited Feb 15, 2014 at 21:44\n\nanswered Feb 15, 2014 at 21:39\n\ndjcdjc\n\n11.7k55 gold badges4242 silver badges5454 bronze badges\n\nAdd a comment |\n\nThis answer is useful\n\n2\n\nSave this answer.\n\nShow activity on this post.\n\nWhy not use a third party link shortener?\n\n(I am assuming you don't have a problem with URI length limits since you\nmentioned this is an existing application.)\n\nIt looks like you're writing a Greasemonkey script or thereabouts, so perhaps\nyou have access to GM_xmlhttpRequest(), which would allow use of a third party\nlink shortener.\n\nOtherwise, you'd need to use XMLHttpRequest() and host your own link\nshortening service on the same server to avoid crossing the same-origin policy\nboundary. A quick online search for hosting your own shorteners supplied me\nwith a list of 7 free/open source PHP link shortener scripts and one more on\nGitHub, though the question likely excludes this kind of approach since \"The\napp\u2019s logic is in-browser only, and there is no backend I can write to.\"\n\nYou can see example code implementing this kind of thing in the URL Shortener\nUserScript (for Greasemonkey), which pops up a shortened version of the\ncurrent page's URL when you press SHIFT+T.\n\nOf course, shorteners will redirect users to the long form URL, but this would\nbe a problem in any non-server-side solution. At least a shortener can\ntheoretically proxy (like Apache's RewriteRule with [P]) or use a <frame> tag.\n\nShare\n\nCC BY-SA 3.0\n\nImprove this answer\n\nFollow this answer to receive notifications\n\nanswered Feb 24, 2014 at 19:37\n\nAdam KatzAdam Katz\n\n15.4k55 gold badges7171 silver badges8787 bronze badges\n\nAdd a comment |\n\nThis answer is useful\n\n1\n\nSave this answer.\n\nShow activity on this post.\n\nMaybe any simple JS minifier will help you. You'll need only to integrate it\non serialization and deserialization points only. I think it'd be the easiest\nsolution.\n\nShare\n\nCC BY-SA 3.0\n\nImprove this answer\n\nFollow this answer to receive notifications\n\nanswered Feb 22, 2014 at 8:23\n\nnot-found.404not-found.404\n\n7033 bronze badges\n\nAdd a comment |\n\nThis answer is useful\n\n1\n\nSave this answer.\n\nShow activity on this post.\n\nShort\n\nUse a URL packing scheme such as my own, starting only from the params section\nof your URL.\n\nLonger\n\nAs other's here have pointed out, typical compression systems don't work for\nshort strings. But, it's important to recognise that URLs and Params are a\nserialization format of a data model: a text human-readable format with\nspecific sections - we know that the scheme is first, the host is found\ndirectly after, the port is implied but can be overridden, etc...\n\nWith the underlying conceptual data model, one can serialize with a more bit-\nefficient serialization scheme. In fact, I have created such a serialization\nmyself which archives around 50% compression: see\nhttp://blog.alivate.com.au/packed-url/\n\nConceptually, my scheme was written with the conceptual data model in mind, it\ndoesn't deserialize the URL into that conceptual model as a distinct step.\nHowever, that's possible, and that formal approach might yield greater\nefficiencies, where the bits don't need to be in the same order as what a\nstring URL might be.\n\nShare\n\nCC BY-SA 4.0\n\nImprove this answer\n\nFollow this answer to receive notifications\n\nedited May 26, 2020 at 2:32\n\nanswered Jun 7, 2018 at 23:31\n\nKind ContributorKind Contributor\n\n18k66 gold badges5353 silver badges7070 bronze badges\n\nAdd a comment |\n\nThis answer is useful\n\n0\n\nSave this answer.\n\nShow activity on this post.\n\nI created a module to deal with this. It uses the browsers built in gzip-\nfunctionality to compress the string as much as possible.\nhttps://www.npmjs.com/package/gzip-string It conveniently comes directly with\nURI encoding support and can from my tests make the strings considerably\nsmaller than lz-string or comparable solutions.\n\nShare\n\nCC BY-SA 4.0\n\nImprove this answer\n\nFollow this answer to receive notifications\n\nanswered Oct 27, 2023 at 9:11\n\nJohan J\u00f6nssonJohan J\u00f6nsson\n\n1\n\nAdd a comment |\n\n##\n\nNot the answer you're looking for? Browse other questions tagged\n\n  * javascript\n  * url\n  * browser\n  * compression\n  * single-page-application\n\nor ask your own question.\n\n  * The Overflow Blog\n  * Is GenAI the next dot-com bubble?\n\n  * Featured on Meta\n  * New Focus Styles & Updated Styling for Button Groups\n\n  * Upcoming initiatives on Stack Overflow and across the Stack Exchange network\n\n  * Pausing the 1-rep voting experiment on Stack Overflow: reflecting on the...\n\n  * Temporary policy: Generative AI (e.g., ChatGPT) is banned\n\n#### Linked\n\n149\n\nHow to escape a JSON string to have it in a URL?\n\n6\n\nHow should I handle very very long URL?\n\n1\n\nHTTP GET request with many items in query string\n\n3\n\nPlay 2.2.x: Query parameters in POST body to avoid exceeding URL limit\n\n1\n\nQuery String Parameter Compression Asp Net Core\n\n#### Related\n\n0\n\nJavaScript compression\n\n5\n\nCompressing parameters in the URL\n\n177\n\nHow to encode URL parameters?\n\n3\n\nJavaScript minification and compression\n\n6\n\nHow to compress GET Parameters in Javascript to avoid hitting the browser size\nlimit?\n\n2\n\nHow to efficiently store game data in a URL query string?\n\n8\n\nAny way to reliably compress a short string?\n\n9\n\nJavascript string compression for URL hash parameter\n\n0\n\nJavascript, url object compression\n\n0\n\nHow much can I compress 400 characters made up of 40 different characters?\n\n#### Hot Network Questions\n\n  * Does this \"Ballygullion\" anecdote, published as true in a law journal, originally come from a work of fiction?\n\n  * Which female character in the MCU had the earliest comic book debut?\n\n  * Bismarck urged not to hinder Russia from going deeper into the \"oriental dead end.\" What did he mean by \"oriental dead end?\"\n\n  * Is it impossible to protect an API from data redistribution?\n\n  * How would a predator adapt to prey on sapient species?\n\n  * Rock as a heat sink\n\n  * Canada visitor visa denied\n\n  * How can I blend 3 images in GIMP, where each image provides an equal HSV contribution?\n\n  * Plot number of concurrent jobs on time axel\n\n  * When talking about a broken device, would there be any difference between: \"I will get it working.\" and \"I will get it to work.\"\n\n  * Does fully frozen food (bread) give off any moisture?\n\n  * Is it a cartesian product?\n\n  * Where can I get an earth-centric map of space?\n\n  * Could a historic (1500- 1700 AD) bicycle stand rough terrain? If yes how?\n\n  * Booking hotel relative to local or home timezone\n\n  * Is Batman's utility belt ever missing something he needs?\n\n  * Why does the BRK instruction set the B flag?\n\n  * Is this job a scam or legit?\n\n  * Can the Sunburst spell kill a vampire?\n\n  * Why would two different sized bikes not arrive at the same time starting from rest on the same slope?\n\n  * Model and implication of bidirectional time\n\n  * Are gate-checked bags screened for items not allowed in the hold?\n\n  * Taking a scene from a video I made\n\n  * Is putting a silly name on a diploma a bad idea?\n\nQuestion feed\n\n# Subscribe to RSS\n\nlang-js\n\n  * Blog\n  * Facebook\n  * Twitter\n  * LinkedIn\n  * Instagram\n\nSite design / logo \u00a9 2024 Stack Exchange Inc; user contributions licensed\nunder CC BY-SA. rev 2024.4.25.8243\n\n## We Care About Your Privacy\n\nWe and our 4 partners store and/or access information on a device, such as\nunique IDs in cookies to process personal data. You may accept or manage your\nchoices by clicking below, including your right to object where legitimate\ninterest is used, or at any time in the privacy policy page. These choices\nwill be signaled to our partners and will not affect browsing data.\n\nCookie Policy.\n\n### We and our partners perform the following based on your settings:\n\nUse precise geolocation data. Actively scan device characteristics for\nidentification. Understand audiences through statistics or combinations of\ndata from different sources. Store and/or access information on a device.\nDevelop and improve services. Create profiles to personalise content. Measure\ncontent performance. Use limited data to select content. Measure advertising\nperformance. Use limited data to select advertising. Create profiles for\npersonalised advertising. Use profiles to select personalised advertising. Use\nprofiles to select personalised content.\n\n", "frontpage": false}
