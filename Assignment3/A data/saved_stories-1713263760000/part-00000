{"aid": "40048391", "title": "Programs get run on Linux (2015)", "url": "https://lwn.net/Articles/630727/", "domain": "lwn.net", "votes": 1, "user": "whereistimbo", "posted_at": "2024-04-16 04:33:54", "comments": 0, "source_title": "How programs get run [LWN.net]", "source_text": "How programs get run [LWN.net]\n\nLWN .net News from the source\n\n  * Content\n\n    * Weekly Edition\n    * Archives\n    * Search\n    * Kernel\n    * Security\n    * Events calendar\n    * Unread comments\n    * LWN FAQ\n    * Write for us\n  * Edition\n\n    * Return to the Kernel page\n\n| |\n\nSubscribe / Log in / New account\n\n# How programs get run\n\nPlease consider subscribing to LWNSubscriptions are the lifeblood of LWN.net.\nIf you appreciate this content and would like to see more of it, your\nsubscription will help to ensure that LWN continues to thrive. Please visit\nthis page to join up and keep LWN on the net.  \n---  \n  \nJanuary 28, 2015\n\nThis article was contributed by David Drysdale\n\nThis is the first in pair of articles that describe how the kernel runs\nprograms: what happens under the covers when a user program invokes the\nexecve() system call? I recently worked on the implementation of a new\nexecveat() system call, which is a close variant of execve() that allows the\ncaller to specify the invoked program by a combination of file descriptor and\npath, as with other *at() system calls. (This will, in turn, enable an\nimplementation of the fexecve() library function that doesn't rely on access\nto the /proc filesystem, which is important for sandboxed environments such as\nCapsicum.)\n\nAlong the way, I explored the existing execve() implementation, and so these\narticles present the details of that functionality. In this one, we'll focus\non the general mechanisms that the kernel uses for program invocation, which\nallow for different program formats; the second article will focus on the\ndetails of running ELF binaries.\n\n#### The view from user space\n\nBefore diving into the kernel, we'll start by exploring the behavior of\nprogram execution from user space (there's also a good description of this\nbehavior in chapter 27 of The Linux Programming Interface). For Linux versions\nup to and including 3.18, the only system call that invokes a new program is\nexecve(), which has the following prototype:\n\n    \n    \n    int execve(const char *filename, char *const argv[], char *const envp[]);\n\nThe filename argument specifies the program to be executed, and the argv and\nenvp arguments are NULL-terminated lists that specify the command line\narguments and environment variables for the new program. A simple skeleton\ndriver program (do_execve.c) allows us to explore how this behaves, by feeding\nin \"zero\", \"one\", \"two\" as arguments and \"ENVVAR1=1\", \"ENVVAR2=2\" as\nenvironment variables. To see the result in the invoked program, we use\nanother simple program (show_info.c) that just outputs its command-line\narguments (argv) and environment (environ).\n\nPutting these together gives the expected result \u2014 the arguments and\nenvironment are passed through to the invoked program. Notice, though, that\nthe argv[0] for the invoked binary is just the value specified by the caller\nof execve(); having the program's name in argv[0] isn't a convention that's\nrequired or policed by execve() itself, at least for binaries.\n\n    \n    \n    % ./do_execve ./show_info argv[0] = 'zero' argv[1] = 'one' argv[2] = 'two' ENVVAR1=1 ENVVAR2=2\n\nThings change slightly when the program being invoked is a script rather than\na binary program. To explore this, we use a shell script equivalent\n(show_info.sh) of our environment-outputting program; putting this together\nwith the original program that invokes execve(), we see a couple of\ndifferences:\n\n    \n    \n    % ./do_execve ./show_info.sh $0 = './show_info.sh' $1 = 'one' $2 = 'two' ENVVAR1=1 ENVVAR2=2 PWD=/home/drysdale/src/lwn/exec\n\nFirst, the environment has gained an extra PWD value, indicating the current\ndirectory. Secondly, the initial argument to the script is now the script\nfilename, rather than the \"zero\" value that the invoker specified. A further\nexperiment reveals that the /bin/sh script interpreter added the PWD\nenvironment variable, but the kernel itself modified the arguments:\n\n    \n    \n    % cat ./wrapper #!./show_info % ./do_execve ./wrapper argv[0] = './show_info' argv[1] = './wrapper' argv[2] = 'one' argv[3] = 'two' ENVVAR1=1 ENVVAR2=2\n\nMore specifically, the kernel has removed the first (\"zero\") argument and\nreplaced it with two arguments \u2014 the name of the script interpreter program\n(taken from the first line of the script) and the name of the invoked file\n(which holds the script text). If the first line of the script also includes\ncommand-line arguments for the interpreter (for example, awk needs an -f\noption to treat its input as a filename rather than script text), a third\nextra argument is also inserted, holding all of the extra options:\n\n    \n    \n    % cat ./wrapper_args #!./show_info -a -b -c % ./do_execve ./wrapper_args argv[0] = './show_info' argv[1] = '-a -b -c' argv[2] = './wrapper_args' argv[3] = 'one' argv[4] = 'two' ENVVAR1=1 ENVVAR2=2\n\nUp to a point, we can also repeat this pop-one, push-two alteration of the\narguments, by invoking scripts that wrap scripts and so on; each such\nalteration effectively pushes the wrapper script name in at argv[1]:\n\n    \n    \n    argv[0]: 'zero'=>'./wrapper4'=>'./wrapper3'=>'./wrapper2'=>'./wrapper' =>'./show_info' argv[1]: 'one' './wrapper5' './wrapper4' './wrapper3' './wrapper2' './wrapper' argv[2]: 'two' 'one' './wrapper5' './wrapper4' './wrapper3' './wrapper2' argv[3]: 'two' 'one' './wrapper5' './wrapper4' './wrapper3' argv[4]: 'two' 'one' './wrapper5' './wrapper4' argv[5]: 'two' 'one' './wrapper5' argv[6]: 'two' 'one' argv[7]: 'two'\n\nHowever, this doesn't continue forever \u2014 once there are too many levels of\nwrappers, the process fails with ELOOP:\n\n    \n    \n    % ./do_execve ./wrapper6 Failed to execute './wrapper6', Too many levels of symbolic links\n\n#### Into the kernel: struct linux_binprm\n\nNow we move into kernel space and begin delving into the code that implements\nthe execve() system call. A previous article explored the general system call\nmachinery (and the special wrinkles needed for execve()), so we can pick up\nthe story at the do_execve_common() function in fs/exec.c. The main purpose of\nthe code in this function is to build a new struct linux_binprm instance that\ndescribes the current program invocation operation. In the structure:\n\n  * The file field is set to a freshly opened struct file for the program being invoked; this allows the kernel to read the file contents and decide how to handle the file.\n  * The filename and interp fields are both set to the name of the file holding the program; we'll see later why there are two distinct fields here.\n  * The bprm_mm_init() function allocates and sets up the associated struct mm_struct and struct vm_area_struct data structures in preparation for managing the virtual memory of the new program. In particular, the new program's virtual memory ends at the highest possible address for the architecture; its stack will grow downward from there.\n  * The p field is set to point at the end of memory space for the new program, but leaves space for a NULL pointer as an end marker for the stack. The value of p will be updated (downward) as more information is added to the new program's stack.\n  * The argc and envc fields are set to hold the counts of arguments and environment values so that this information can be propagated to the new program later in the invocation process.\n  * The unsafe field is set up to hold a bitmask of reasons why the program execution might not be safe; for example, if the process is being traced with ptrace() or has the PR_SET_NO_NEW_PRIVS bit set. The Linux Security Module (LSM) may subsequently use this information to deny the program execution operation.\n  * The cred field is a separately allocated object of type struct cred that holds information about the credentials for the new program. These are generally inherited from the process that called execve(), but are updated to allow for setuid / setgid bits and other complications. The presence of setuid/setgid bits also disallows a collection of compatibility features because they have an adverse effect on security; the per_clear field records the bits in the process's personality that will be cleared later.\n  * The security field allows an LSM to store LSM-specific information with the linux_binprm; the LSM is notified via a call to security_bprm_set_creds() and the bprm_set_creds LSM hook. The default implementation of this hook updates the new program's Linux capabilities to allow for the file capabilities of the program file; other LSM implementations chain this behavior into their own implementations of the hook (e.g. Smack, SELinux).\n  * The buf scratch space is filled with the first chunk (128 bytes) of data from the program file. This data will be used later to detect the binary format so it can be processed appropriately.\n\nThe parts of this setup process that depend on the particular file that's\nbeing executed are performed in an inner prepare_binprm() function; this\nfunction can be called again later to update those fields if a different file\n(e.g. a script interpreter) is actually run.\n\nFinally, information about the program invocation is copied into the top of\nnew program's stack, using the local copy_strings() and copy_strings_kernel()\nutility functions. First, the program filename is pushed to the stack (and its\nlocation is saved in the exec field of the linux_bprm instance), followed by\nall of the environment values, then by all of the arguments. At the end of\nthis process, the stack looks like:\n\n    \n    \n    ---------Memory limit--------- NULL pointer program_filename string envp[envc-1] string ... envp[1] string envp[0] string argv[argc-1] string ... argv[1] string argv[0] string\n\n#### Binary format handler iteration: struct linux_binfmt\n\nWith a complete struct linux_binprm in hand, the real business of program\nexecution is performed in exec_binprm() and (more importantly)\nsearch_binary_handler(). This code iterates over a list of struct linux_binfmt\nobjects, each of which provides a handler for a particular format of binary\nprograms. A binary handler could potentially be defined in a kernel module, so\nthe code calls try_module_get() for each format to ensure the relevant code\ncan't be unloaded by another task while it's being used here.\n\nFor each struct linux_binfmt handler object, the load_binary() function\npointer is called, passing in the linux_binprm object. If the handler code\nsupports the binary format, it does whatever is needed to prepare the program\nfor execution and returns success (>= 0). Otherwise, the handler returns a\nfailure code (< 0) and iteration continues with the next handler.\n\nExecution of a particular program may itself rely on execution of a different\nprogram; the obvious example is executable scripts, which need to invoke the\nscript interpreter. To cope with this, the search_binary_handler() code can be\ncalled recursively, re-using the struct linux_binprm object. However,\nrecursion depth is limited to prevent infinite recursion, giving the ELOOP\nerror behavior seen earlier.\n\nThe system's LSM also gets a say in the operation; before the iteration over\nbinary formats starts, the bprm_check_security LSM hook is triggered, allowing\nthe LSM to make a decision on whether to allow the operation. To do so, it may\nuse the state it stored in the linux_binprm.security field earlier.\n\nAt the end of the iteration, if no formats that can handle the program have\nbeen found (and the program appears to be binary rather than text, at least\naccording to the first four bytes), then the code will also attempt to load a\nmodule named \"binfmt-XXXX\", where XXXX is the hex value of bytes three and\nfour in the program file. This is an old mechanism (added in 1996 for Linux\n1.3.57) to allow for a more dynamic way of associating binary format handlers\nwith formats; the more recent binfmt_misc mechanism (described below) allows a\nmore flexible way of doing something similar.\n\n#### Binary formats\n\nSo what are the binary formats available in the standard kernel? A search for\ncode that registers instances of struct linux_binfmt (via register_binfmt()\nand insert_binfmt()) gives us quite a collection of possible formats, all of\nwhich are configured and explained in the fs/Kconfig.binfmts file:\n\n  * binfmt_script.c: Support for interpreted scripts, starting with a #! line.\n  * binfmt_misc.c: Support miscellaneous binary formats, according to runtime configuration.\n  * binfmt_elf.c: Support for ELF format binaries.\n  * binfmt_aout.c: Support for traditional a.out format binaries.\n  * binfmt_flat.c: Support for flat format binaries.\n  * binfmt_em86.c: Support for Intel ELF binaries running on Alpha machines.\n  * binfmt_elf_fdpic.c: Support for ELF FDPIC binaries.\n  * binfmt_som.c: Support for SOM format binaries (an HP/UX PA-RISC format).\n\n(plus a couple of other architecture-specific formats).\n\nThe next sections will examine the most important of these: interpreted\nscripts and the \"miscellaneous\" mechanism for supporting arbitrary formats;\nthe next article will examine the ELF binary format \u2014 which is typically where\nall program execution ends up.\n\n#### Script invocation: binfmt_script.c\n\nFiles that start with the character sequence #! (and have the execute bit set)\nare treated as scripts, handled by the fs/binfmt_script.c handler. After\nchecking those first two bytes, this code parses the rest of the script-\ninvocation line, splitting it into an interpreter name (everything after #! up\nto the first white space) and possible arguments (everything else up to the\nend of the line, stripping external white space).\n\n(One detail to note: back when the struct linux_binprm object was created,\nonly the first 128 bytes of the program were retrieved. This means that if the\ninterpreter name and arguments are longer than this, the results will be\ntruncated.)\n\nWith these in hand, the code then removes argv[0] from the top of the new\nprogram's stack (i.e. at the lowest address), and in its place pushes the\nfollowing, adjusting the argc value in the linux_binprm object along the way:\n\n  * the program name\n  * (optionally) the collected interpreter arguments\n  * the name of the interpreter program\n\nTaken together, this explains the user space behavior we observed at the\nbeginning of the article; our new program's stack is modified to look like:\n\n    \n    \n    ---------Memory limit--------- NULL pointer program_filename string envp[envc-1] string ... envp[1] string envp[0] string argv[argc-1] string ... argv[1] string program_filename string ( interpreter_args ) interpreter_filename string\n\nThe code also changes the interp value in the linux_binprm structure so that\nit references the interpreter filename, rather than the script filename. This\nexplains why the linux_binprm structure refers to two strings: one (interp) is\nthe program that we currently want to execute, and one is the name (filename)\nthat was originally invoked in the execve() call. Along similar lines, the\nfile field in the linux_binprm is also updated to reference the new\ninterpreter program, and the first 128 bytes of its contents read into the buf\nscratch space.\n\nThe script handler code then recurses into search_binary_handler() to repeat\nthe whole process for the script interpreter program. If the interpreter is\nitself a script, then the interp value will be changed once again but the\nfilename will stay unchanged.\n\n#### Miscellaneous interpreter detection: binfmt_misc.c\n\nWe saw previously that early versions of the Linux kernel supported a rough-\nand-ready way of dynamically adding format support, by hunting for a kernel\nmodule with a name containing the early bytes of the binary. That's not\nparticularly convenient \u2014 only searching on a couple of bytes is very limited\n(compare the vast range of detection signatures that the file command uses)\nand requiring a kernel module raises the barrier to entry.\n\nThe miscellaneous binary format handler allows a more flexible and dynamic\nmethod of dealing with new formats, by allowing run-time configuration (via a\nspecial filesystem mounted under /proc/sys/fs/binfmt_misc) to specify:\n\n  * How to recognize a supported format, based on filename extension or a magic value at a particular offset. (As with parsing script interpreters, this magic value has to fall within the first 128 bytes of the program file.)\n  * The interpreter program to invoke, which will get the program filename passed to it as argv[1] (as with script invocation).\n\nA good example of the miscellaneous format handler in use is for Java files:\ndetect .class files (based on their 0xCAFEBABE prefix) or .jar files (based on\nthe .jar extension) and automatically invoke the JVM executable on them. This\nwill require a wrapper script to provide the relevant command-line arguments,\nas the miscellaneous configuration doesn't allow arguments to be specified \u2014\nwhich means that the miscellaneous handler will invoke the script handler,\nwhich will then invoke the ELF handler for the JVM executable (and which will\nprobably in turn invoke the dynamic linker ld.so, although that's a somewhat\ndifferent story).\n\nInternally, the kernel implementation for this format is similar to the\nhandler for script programs described above, except that there is an initial\nsearch for a matching configuration entry, and that configuration is used to\nmake some of the details (such as removing argv[0]) optional.\n\nThe format handlers for both scripts and miscellaneous formats recurse on to\nattempt to invoke the interpreter program that is needed for that particular\nformat. This recursion has to end at some point, and on a modern Linux system\nthis is almost always at an ELF binary program \u2014 the subject of the next\narticle \u2014 stay tuned.\n\nIndex entries for this article  \n---  \nKernel| exec()  \nGuestArticles| Drysdale, David  \n  \n(Log in to post comments)\n\n### How programs get run\n\nPosted Jan 29, 2015 6:16 UTC (Thu) by wahern (subscriber, #37304) [Link]\n\n> After checking those first two bytes, this code parses the rest of the\n> script-invocation line, splitting it into an interpreter name (everything\n> after #! up to the first white space) and possible arguments (everything\n> else up to the end of the line, stripping external white space).\n\nLinux passes the remainder of the line as a _single_ argument. You show this\nin your example where \"-a -b -c\" are all located in argv[1]. But you say\n\n> ... a third extra argument is also inserted, holding all of the extra\n> options:\n\nThose aren't extra options--the plural is misleading. The distinction matters\nbecause neither getopt nor getopt_long will parse \"-a -b -c\" as three separate\noptions. Rather, it'll be parsed as optc='a' and optarg=\" -b -c\", or it will\nparse as optc='a', optc=' ', optc='-', optc='b', etc. Most likely it'll just\nfail because your option specification won't match the parse. If a, b, and c\nare all single options without arguments, then you could put \"-abc\" on the\nshebang line. But you can't space them out, and you can't use an option that\ntakes an argument unless the argument is the path of the script, as with the\n-f option for awk. And you can't mix non-argument with argument options unless\nthe sole argument-taking option comes last. For example, \"-abcf\".\n\nOS X, by contrast, will field-split the trailing shebang line in the kernel so\nthat the script \"#!./show_info -a -b -c\" will print out\n\n    \n    \n    argv[0] = './show_info' argv[1] = '-a' argv[2] = '-b' argv[3] = '-c'\n\nSolaris is quirky. It will field-split, but only includes the first field. So\n\"#!./show_info -a -b -c\" will print out\n\n    \n    \n    argv[0] = './show_info' argv[1] = '-a'\n\nFWIW, OpenBSD 5.5, NetBSD 6.1, and FreeBSD 9.0 all behave like Linux. Which\nwas surprising because I could have sworn that either FreeBSD or NetBSD (or\nboth) would field-split the remainder of the shebang line.\n\n### How programs get run\n\nPosted Jan 29, 2015 9:50 UTC (Thu) by drysdale (guest, #95971) [Link]\n\nThanks for the clarification & comparisons with other OSes -- I should have\nmade clear that the bundling together of arguments into argv[1] means that\nmultiple interpreter arguments basically won't work.\n\n### How programs get run\n\nPosted Jan 29, 2015 17:17 UTC (Thu) by vonbrand (guest, #4458) [Link]\n\nPlease do update the article with this information. It is definitely one to\nbookmark.\n\n### How programs get run\n\nPosted Jan 29, 2015 21:13 UTC (Thu) by wahern (subscriber, #37304) [Link]\n\nFWIW, Linux and OS X are the only systems I'm aware of that permit recursive\nshebang execution. Some systems, like Free/Net/OpenBSD, will recursively\nsearch for the binary interpreter, but they won't stack the paths of the\nintervening interpreters. Instead the binary interpreter is only passed the\noriginal file path. (And any trailing shebang arguments in the scripts seem to\nget dropped altogether.)\n\nThat's not germane to how Linux executes binaries. But I have a feeling this\npage might end up near the top of the Google results (as all good LWN articles\ndo) for shebang-related queries, so it's worth putting out there.\n\nBecause shells parse scripts line-by-line, if you can come up with a construct\nthat is both valid shell code and valid code in your other language, you can\nmix interpreters portably. For example, the following is a mixed shell/Lua\nscript which will locate a Lua interpreter. Because both the locations _and_\ninterpreter names of Lua differ across systems, even across Linux\ndistributions, and even for the same version of Lua, you can't use the\n#!/usr/bin/env trick to run your Lua scripts and expect it to work even\nremotely reliably.\n\n    \n    \n    #!/bin/sh _=[[ # variable assignment in shell, beginning of long string in Lua IFS=: for D in ${PATH:-$(command -p getconf PATH)}; do for F in ${D}/lua*; do # check if it's our preferred version if ...; then exec \"${F}\" \"$0\" \"$@\" fi done done printf \"%s: unable to locate Lua interpreter\\n\" \"${0##*/}\" >&2 exit 1 ]] -- begin pure Lua code print(_VERSION)\n\nI recently published a script, runlua, for portable execution of Lua scripts,\nwhich is why all of this stuff is still fresh in my mind.\n\n### How programs get run\n\nPosted Jan 29, 2015 21:56 UTC (Thu) by peter-b (guest, #66996) [Link]\n\nGNU Guile has a special \"meta switch\" which instructs the interpreter to\ninterpret the first few lines of the file -- up to a line containing only \"!#\"\n-- as arguments to the interpreter rather than as source code. It seems to\nwork quite well:\n\n    \n    \n    #!/usr/local/bin/guile \\ -e main -s !# (define (main args) (map (lambda (arg) (display arg) (display \" \")) (cdr args)) (newline))\n\n### How programs get run\n\nPosted Feb 5, 2015 8:50 UTC (Thu) by grawity (subscriber, #80596) [Link]\n\nSven Mascheck's website has loads of information regarding OS differences in\n#! handling.\n\n### How programs get run\n\nPosted Nov 25, 2019 9:34 UTC (Mon) by Profpatsch (guest, #130533) [Link]\n\nThis here is the bible of shebang interpretations: https://www.in-\nulm.de/~mascheck/various/shebang/\n\nI have to look through it surprisingly often.\n\n### How programs get run\n\nPosted Nov 25, 2019 9:35 UTC (Mon) by Profpatsch (guest, #130533) [Link]\n\nAh, grawity beat me to it (by about 4 years).\n\n### How programs get run\n\nPosted Jan 29, 2015 14:43 UTC (Thu) by jem (subscriber, #24231) [Link]\n\nThis reminds me of the simplest way to make a Linux script that outputs some\nstatic text:\n\n    \n    \n    #!/usr/bin/tail --lines=+2 Text goes here. More text. Last line.\n\n### How programs get run\n\nPosted Nov 25, 2019 9:37 UTC (Mon) by Profpatsch (guest, #130533) [Link]\n\nThe source code links are broken. This is such a valuable resource, it would\nbe great if they could be rewritten to an archive.org link or something.\n\nCopyright \u00a9 2015, Eklektix, Inc. Comments and public postings are copyrighted\nby their creators. Linux is a registered trademark of Linus Torvalds\n\n", "frontpage": false}
