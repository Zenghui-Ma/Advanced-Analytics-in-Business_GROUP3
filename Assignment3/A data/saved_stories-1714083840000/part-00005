{"aid": "40158889", "title": "Effectful \u2013 An easy to use, performant extensible effects library", "url": "https://flora.pm/packages/@hackage/effectful", "domain": "flora.pm", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-25 15:42:53", "comments": 0, "source_title": "@hackage/effectful", "source_text": "@hackage/effectful\n\n# @hackage effectful2.3.0.0\n\nAn easy to use, performant extensible effects library.\n\n  * ### Categories\n\n  * ### License\n\nBSD-3-Clause\n\n  * ### Maintainer\n\nandrzej@rybczak.net\n\n  * ### Links\n\n    * Homepage\n    * Documentation\n    * Source repository\n    * Changelog\n  * ### Versions\n\n    * 2.3.0.0 Wed, 13 Sep 2023\n    * 2.2.2.0 Wed, 11 Jan 2023\n    * 2.2.1.0 Wed, 9 Nov 2022\n    * 2.2.0.0 Mon, 24 Oct 2022\n    * 2.1.0.0 Mon, 22 Aug 2022\n    * 2.0.0.0 Fri, 12 Aug 2022\n\nShow all...\n\n# effectful\n\nAn easy to use, fast extensible effects library with seamless integration with\nthe existing Haskell ecosystem.\n\nMain features:\n\n  1. Very fast (benchmarks).\n\n  2. Easy to use API (comparable with usage of the MonadUnliftIO class).\n\n  3. Correct semantics in presence of runtime exceptions (no more discarded state updates).\n\n  4. Seamless integration with the existing ecosystem (exceptions, monad-control, unliftio-core, resourcet etc.).\n\n  5. Support for thread local and shared state (e.g. StateT provides a thread local state, while MVar holds a shared state, both approaches have their merits).\n\n  6. Support for statically (implementation determined at compile time) and dynamically (implementation determined at run time) dispatched effects.\n\n## Motivation\n\nDo we really need yet another library for handling effects? There's freer-\nsimple, fused-effects, polysemy, eff and probably a few more.\n\nIt needs to be noted that of all of them only the work-in-progress eff library\nis a promising proposition because of reasonable performance characteristics\n(see the talk Effects for Less for more information) and potential for good\ninteroperability with the existing ecosystem.\n\nThe second point is arguably the most important, because it allows focusing on\nthings that matter instead of reinventing all kinds of wheels, hence being a\nnecessary condition for broader adoption of the library.\n\nUnfortunately, the development of eff has stalled due to a few subtle issues\nrelated to its use of delimited continuations underneath.\n\n### What about mtl?\n\nIt's true that its \"effects as classes\" approach is widely known and used\noften.\n\nHowever:\n\n  * mtl style effects are slow.\n\n  * The majority of popular monad transformers (except ReaderT) used for effect implementations are rife with subtle issues.\n\nThese are problematic enough that the ReaderT design pattern was invented. Its\nfundamentals are solid, but it's not an effect system.\n\nA solution? Use the ReaderT pattern as a base and build around it to make an\nextensible effects library! This is where effectful comes in. The Eff monad it\nuses is essentially a ReaderT over IO on steroids, allowing us to extend its\nenvironment with data types representing effects.\n\nThis concept is quite simple, so:\n\n  * It's reasonably easy to understand what is going on under the hood.\n\n  * The Eff monad being a reader allows for seamless interoperability with ubiquitous classes such as MonadBaseControl and MonadUnliftIO and solves issues of monad transformers mentioned above.\n\nWhat is more, the Eff monad is concrete, so GHC has many possibilities for\noptimization, which results in a very fast code at a default optimization\nlevel. There is no need to explicitly mark functions with INLINE pragmas or\nenable additional optimization passes, it just works.\n\n### Any downsides?\n\nAs always, there's no free lunch. The Eff monad doesn't support effect\nhandlers that require the ability to suspend or capture the rest of the\ncomputation and resume it later (potentially multiple times). This prevents\neffectful from providing (in particular):\n\n  * A NonDet effect handler that executes multiple Alternative branches and collects their results.\n\n  * A Coroutine effect.\n\nIt needs to be noted however that such NonDet effect handler in existing\nlibraries is broken and none of the ones with support for higher order effects\nprovide the Coroutine effect, so arguably it's not a big loss.\n\nIf you need such capability in your application, there are well established\nlibraries such as conduit or list-t that can be used with effectful without\nany hassle.\n\n### Summary\n\neffectful is an extensible effects library that aims to be the replacement\nfor:\n\n  * The bare ReaderT pattern by being essentially its enriched version.\n\n  * Monad transformer stacks typically encountered in the wild (i.e. consisting of a dozen of newtype'd ExceptT, ReaderT, StateT and WriterT transformers and their derivatives) by providing equivalent effects with improved semantics, performance, usability and making it easy to reuse them for your own effects.\n\nIt doesn't try to make monad transformers obsolete, so you're free to use it\nwith ConduitT, ContT, ListT etc. when necessary.\n\n## Package structure\n\nThe library is split among several packages:\n\n  * The effectful-core package contains the core of the library along with basic effects. It aims for a small dependency footprint and provides building blocks for more advanced effects.\n\n  * The effectful-plugin package provides an optional GHC plugin for improving disambiguation of effects (see here for more information).\n\n  * The effectful-th package provides utilities for generating bits of effect-related boilerplate via Template Haskell.\n\n  * The effectful package re-exports public modules of effectful-core and additionally provides most features of the unliftio package divided into appropriate effects.\n\n## Examples\n\nFor the examples see the Introduction sections of Effectful.Dispatch.Dynamic\nand Effectful.Dispatch.Static.\n\n## Acknowledgements\n\nTo all contributors of existing effect libraries - thank you for putting the\ntime and effort to explore the space. In particular, conversations in issue\ntrackers of cleff, eff, freer-simple, fused-effects and polysemy repositories\nwere invaluable in helping me discover and understand challenges in the space.\n\n### Resources\n\nResources that inspired the rise of this library and had a lot of impact on\nits design.\n\nTalks:\n\n  * Effects for Less by Alexis King.\n\n  * Monad Transformer State by Michael Snoyman.\n\nBlog posts:\n\n  * ReaderT design pattern by Michael Snoyman.\n\n  * Exceptions Best Practices by Michael Snoyman.\n\nIcons made by Freepik from www.flaticon.com\n\n  * ### \n\nInstallation\n\n  * ### Tested Compilers\n\n    * 9.8.1\n    * 9.6.2\n    * 9.4.7\n    * 9.2.8\n    * 9.0.2\n    * 8.10.7\n    * 8.8.4\n  * ### Dependencies (9)\n\n    * base >=4.13 && <5\n    * bytestring >=0.10\n    * directory >=1.3.2\n    * process >=1.6.9\n    * stm >=2.5.0.0\n    * async >=2.2.2\n\nShow all...\n\n  * ### Dependents (6)\n\n@hackage/web-view, @hackage/glualint, @hackage/typed-process-effectful,\n@hackage/hyperbole, @hackage/effectful-th, @hackage/hasql-effectful\n\n### Package Flags\n\n", "frontpage": false}
