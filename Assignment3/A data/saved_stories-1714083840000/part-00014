{"aid": "40158980", "title": "Getting your Haskell executable statically linked without Nix", "url": "https://hasufell.github.io/posts/2024-04-21-static-linking.html", "domain": "hasufell.github.io", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-25 15:49:56", "comments": 0, "source_title": "2024-04-21-static-linking \u00b7 Hasufell's blog", "source_text": "2024-04-21-static-linking \u00b7 Hasufell's blog\n\nHasufell's blog\n\n\u00a9 2021. All rights reserved.\n\nSite created with Hakyll. Modified theme lanyon-hakyll based on Lanyon.\n\n### Hasufell's blog haskell and tech, mostly\n\n# 2024-04-21-static-linking\n\nApril 21, 2024,\n\n# Getting your Haskell executable statically linked without Nix\n\n## Motivation\n\nFollowing the excellent post from Tom Sydney \u201cGetting your Haskell executable\nstatically linked with Nix\u201d, I want to present an alternative approach.\n\nI believe nix has questionable ergnomics and most Haskell developers don\u2019t\nneed it, even if they want to link their binaries statically.\n\n## Musl and Alpine Linux\n\nGHC/cabal don\u2019t really know how to do partial static linking, unless you\nemploy some trickery. So we need a system where we can link everything\nstatically, including libc. This leads us to the Musl libc, which has good\nsupport for static linking.\n\nTwo prominent choices for musl based Linux distributions are:\n\n  * Alpine Linux\n  * Void Linux musl\n\nIn this guide, we pick Alpine.\n\n## GHCup and GHC\n\nIn order to use Alpine Linux as a build environment, we need proper toolchain\nsupport. GHCup supports Alpine Linux as a first class citizen, so you should\nbe able to install GHC on Alpine. If you run into issues, open a bug report.\n\nNote that you do not need a statically linked GHC to build a static binary.\nThis is a misconception.\n\n## Build environment\n\nWe need a clean build environment that is reproducible (-ish). We can use\ndocker, which has excellent support for Alpine Linux containers.\n\n## Tying everything together\n\nTo tie everything together, we start an interactive shell in a docker\ncontainer:\n\n    \n    \n    $ docker run --rm -ti alpine:3.19 sh\n\nThen we install pre-requisites:\n\n    \n    \n    $ apk update $ apk add curl gcc g++ git gmp-dev libc-dev libffi-dev make musl-dev ncurses-dev perl tar xz\n\nWe install GHCup:\n\n    \n    \n    $ curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | BOOTSTRAP_HASKELL_NONINTERACTIVE=1 sh source ~/.ghcup/env\n\nLet\u2019s create a dummy app:\n\n    \n    \n    $ mkdir test-app $ cd test-app $ cabal init --non-interactive $ cabal build --enable-executable-static $ mkdir out/ $ cp $(cabal -v0 list-bin exe:test-app) out/\n\nWe use cabal build in combination with cabal list-bin, because some versions\nof cabal are buggy when combining --enable-executable-static with install:\nhttps://github.com/haskell/cabal/pull/9697\n\nIt is also possible to pass -ghc-options='-optl-static' instead of --enable-\nexecutable-static.\n\nNow we examine the binary:\n\n    \n    \n    $ apk add file $ file out/test-app out/test-app: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=ab54deda534ac8065f5e263e84f168fb46eb8227, with debug_info, not stripped\n\nThat looks good.\n\n## Linking against system libraries\n\nIf your binary depends on system C libraries, you will need to install those\npackages. E.g. if you link against zlib, you need the -dev and sometimes\n-static packages:\n\n    \n    \n    apk add zlib-dev zlib-static\n\nYou can search for libraries and installed files at\nhttps://pkgs.alpinelinux.org/packages\n\n## Github CI\n\nExamples of Github actions using alpine and building static release binaries\ncan be found here:\n\n  * https://github.com/haskell/ghcup-hs/blob/master/.github/workflows/release.yaml\n  * https://github.com/hasufell/stack2cabal/blob/master/.github/workflows/release.yaml\n  * https://github.com/stable-haskell/cabal/blob/cabal-install-v3.10.3.0/.github/workflows/release.yaml\n\n## Conclusion\n\nThis approach has been used in GHCup since its rewrite in Haskell. It has\nworked very well.\n\nThe only downside is that you rely on Alpine Linux packaging of system C\nlibraries. If you link to a package that is not in the Alpine repos, you will\nneed more manual work.\n\nIn that case it might be worthwhile to check Void Linux as an alternative.\n\n## Related posts\n\n  * ### 2023-11-14-ghcup-is-not-an-installer November 14, 2023\n\n  * ### 2022-06-29-fixing-haskell-filepaths June 29, 2022\n\n  * ### From conduit to streamly October 22, 2021\n\n## Comments\n\n", "frontpage": false}
